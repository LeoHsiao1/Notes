# 线程

## 定义

- 线程（Thread）是进程运行、CPU 调度的最小单位。
  - 每个进程至少包含一个线程，其中第一个创建的线程称为主线程（main thread）。
  - 启动一个程序时，至少要创建一个进程，来执行程序指令。但进程只是一个空空的线程组，其中的线程才是实体，决定了 CPU 实际执行的程序指令。

- 每个线程可以创建任意个新线程。
  - 新线程属于当前线程的线程组，即属于同一个进程。
  - 进程之间可以存在父子关系，而线程之间不存在父子关系。同一进程中的所有线程，相互平等，除了主线程。

- 每个线程可以创建任意个新进程。不过此时看作是该线程所属的进程创建了新进程，考虑进程级别的概念，而不是线程级别。

### 占用资源

- Linux 给一个进程分配的系统资源，大部分会被该进程下的各个线程共享。包括：
  - PID、PPID
  - User ID 、Group ID
  - 内存，包括：
    - 虚拟内存空间，寻址相同
    - 堆区，用于存储静态变量、全局变量等数据
  - 打开的文件描述符，比如 Socket
  - 环境变量，比如 PWD、HOSTNAME
  - 进程间通信的 signals 和 signal handlers

- 每个线程有一些独立分配的系统资源。包括：
  - TID
  - CPU 调度，比如占用 CPU 时长、使用哪些寄存器
  - 栈区，用于存储局部变量等数据

- 任一线程终止时，Linux 可以释放其线程级别的资源（比如栈区），但不能释放进程级别的资源（比如堆区），因为依然被其它线程使用。
  - 当一个进程中所有线程都终止时，Linux 才认为该进程已终止，释放该进程占用的系统资源。

## LWP

- 上述的线程特点，是参考 [POSIX 线程标准](https://man7.org/linux/man-pages/man7/pthreads.7.html) ，简称为 pthread 。
  - 但 Linux 系统不完全遵循 POSIX 标准。因为 Linux 内核的可调度实体（schedulable entities）只能是进程，不支持创建线程。
  - 为了兼容 POSIX 风格的软件，Linux 允许调用 pthread.h 库的 `pthread_create()` 函数，创建轻量级进程（Light Weight Process ，LWP），用它模拟线程。

- LWP 的原理。
  - LWP 本质上是 Linux 进程，不是真正的 POSIX 线程。
    - Linux 创建进程、线程时，底层都是调用 clone() 来实现的。
    - 例如调用 pthread_create() 创建线程时，实际上会调用 clone() 创建一个子进程，并指定 CLONE_VM、CLONE_THREAD 等 flags ，使得子进程符合线程的特征。

  - 在以下方面，LWP 符合 POSIX 线程的标准：
    - 每个进程可以创建多个 LWP ，它们之间共享系统资源，因此可以模拟线程。
    - 每个进程中，第一个创建的 LWP （即主线程）的 TID ，总是等于该进程的 PID 。

  - 在以下方面，LWP 不符合 POSIX 线程的标准：
    - 一个进程中的每个线程使用一个独立的 task_struct ，而不共享当前进程的 task_struct 。
    - 每个线程的 task_struct 中，分配一个唯一的 PID ，当作 TID 使用。

- Linux v2.6 版本增加了 NPTL（Native POSIX Thread Library）线程库，用于创建完全符合 POSIX 标准的线程。

<!-- 线程比进程更轻量级，创建一个线程的时间、资源开销，比进程小很多。 -->


## 相关 API

### pthread.h

```c
#include <pthread.h>

int pthread_create(pthread_t *tid,              // 传入用于存储线程 TID 的指针变量
                   const pthread_attr_t *attr,  // 传入线程的属性（传入 NULL 则是默认属性）
                   void *(*)(void *),           // 传入要运行的函数，该函数头的格式应该定义成：void *fun(void *arg)
                   void *arg);                  // 传入要运行的函数的实参，没有参数则填 NULL
    // 用于创建一个线程，运行指定的函数
    // 如果创建成功，则将线程的 TID 存储到变量 tid 中，并返回 0

int pthread_join(pthread_t tid, void **retval);
    // 阻塞当前线程的执行，等待当前进程中指定 tid 的线程终止，然后才继续执行当前线程
    // 当目标线程终止时，会将其退出码存储到变量 retval 中

void pthread_exit(void *retval);
    // 使当前线程退出，且采用 retval 的值作为退出码

int pthread_cancel(pthread_t tid);
    // 向当前进程中指定 tid 的线程，发送 cancel 请求
    // 如果该函数的返回值为 0 ，则表示成功发送了 cancel 请求，但不知道目标线程会如何处理请求
    // 每个线程收到 cancel 请求时，默认会立即终止。但也可以忽略 cancel 请求，或者自定义一个处理 cancel 请求的函数

int pthread_kill(pthread_t tid, int sig);
    // 向当前进程中指定 tid 的线程，发送 sig 信号
    // 如果该函数的返回值为 0 ，则表示成功发送了信号，但不知道目标线程会如何处理信号
```
- 编译时需要链接 pthread.h 库，例如：`gcc test.c -o test -l pthread`
- 例：
  ```c
  #include <stdio.h>
  #include <pthread.h>

  void *fun1(){
      puts("fun1() end.");
      return 0;
  }

  int main(){
      int rc;
      pthread_t tid;

      rc = pthread_create(&tid, NULL, fun1, NULL);
      if(rc)
          puts("Failed to create the thread fun1().");

      pthread_join(tid, NULL); // 阻塞主线程的运行。以免主线程执行完毕，提前终止子线程
      puts("main() end.");
      return 0;
  }
  ```

### 终止

- 终止线程的几种方式：
  - 如果一个线程调用 pthread_exit() ，则会使当前线程退出，不影响其它线程。
  - 如果一个线程的主函数执行到 return 语句，则考虑该线程的身份：
    - 如果该线程是普通线程，则会隐式调用 pthread_exit() ，使当前线程退出。
    - 如果该线程是主线程，则会隐式调用 exit() ，使整个进程退出。
      - 因此，创建多线程时，通常要用 pthread_join()、死循环等方式让主线程保持运行，避免子线程还没执行完毕就被终止。
  - 如果任一线程调用 exit() ，则会使整个进程退出。
    - 此时 Linux 会直接终止当前进程的所有线程，不会发送 SIGTERM 等信号。
  - 一个线程调用 pthread_cancel() ，向其它线程发送 cancel 请求。
  - 一个线程调用 pthread_kill() ，向其它线程发送终止信号。

<!-- - 总之，建议不要从外部终止某个线程，而是让每个线程自行终止，通过执行 pthread_exit() 或 return 语句。 -->

- 何时释放线程占用的资源？有两种策略：
  - joinable
    - ：默认策略。当线程终止时，不立即释放它占用的资源，而是等其它线程调用 pthread_join() 来获取该线程的退出码时，才释放资源。
  - detached
    - ：当线程终止时，立即释放它占用的资源。
    - 优点：避免出现僵尸线程。
    - 缺点：其它线程不知道该线程的退出时刻、退出码。

## 多线程

### 优点

- 当一个程序需要让 CPU 执行多个任务时（比如执行多个函数），有几种策略：
  - 单线程：只创建一个线程，让 CPU 串行执行这些任务。
  - 多进程：创建多个进程，每个进程至少包含一个线程，并行执行。
  - 多线程：创建一个进程，包含多个线程，并行执行。

- 多进程（multiprocess）的优点：
  - 每个进程使用的虚拟内存空间、物理内存等资源相互独立，不会相互影响。
  - 每个进程独立运行。一个进程挂掉了，通常不会影响其它进程。

- 多线程（multithreading）的优点：
  - 与单线程相比，可以提高 CPU 的使用率。
    - 例如一个线程因为等待 IO 而暂停运行时，其它线程依然可以运行。
    - 例如一个线程占用了 CPU 的一个核心时，其它线程可以在 CPU 的其它核心上运行。
    - 处理 IO 密集型任务时，多线程、多进程都可以提高 CPU 的使用率，从而提高处理速度。
    - 处理 CPU 密集型任务时，多线程、多进程都不能提高处理速度。
  - 多线程相当于轻量级的多进程，开销更小。
    - 创建一个进程的开销，大于创建一个线程，需要分配虚拟内存空间等资源。
    - CPU 进程上下文切换的开销，大于 CPU 线程上下文切换。例如 CPU 原本执行进程 A （中的线程），想切换执行进程 B （中的线程），则需要切换进程使用的内存、堆栈等资源。
  - 与进程间通信相比，线程间通信更容易。
    - 同一个进程的多个线程之间，可以采用全局变量作为通信媒介，因为它们访问的是同一个堆区。

### 线程间通信

- 线程间通信的频率：
  - 轮询（poll）
    - ：线程 A 执行一个循环语句，反复获取线程 B 的数据，比如读取某个全局变量。
    - 优点：只要提高循环的频率，就可以实时获取线程 B 的数据。
    - 缺点：频繁轮询，会增加线程 A 的开销。比如占用更多 CPU 时长、不能长时间执行其它任务。
  - 回调（callback）
    - ：线程 A 将自己某个函数的地址传给线程 B ，让线程 B 在必要时刻调用该函数，从而触发线程 A 的相关逻辑代码。
    - 该函数称为回调函数。
    - 优点：线程 A 是被动获取数据，不用频繁主动轮询，开销低。
    - 缺点：线程 B 不一定会及时调用该函数，导致线程 A 不能及时获取数据。

### 线程安全

- 多进程、多线程可以并行工作，但可能出现以下问题：
  - 一个线程在访问当前进程的共享资源时，该资源被其它线程修改。
    - 对策：可以给该资源上锁，保证同时只能被一个线程访问。
  - 一个线程在 CPU 执行任务时，被其它线程打断、抢占 CPU 。
    - 对策：可以阻塞其它线程，先让该线程执行完任务。
