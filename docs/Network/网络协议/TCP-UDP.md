# TCP/UDP

- 大部分应用层协议，在传输层是基于 TCP/UDP 协议进行通信的。
  - 例如 HTTP、FTP、SMTP 是基于 TCP 协议。
  - 例如 DHCP、DNS、SNMP（简单网络管理协议）、TFTP（通用文件传输协议）、NFS（网络文件系统）是基于 UDP 协议。

## TCP

：传输控制协议（Transmission Control Protocol）
- 属于传输层协议，用于让一个主机向另一个主机传输网络数据包。
- 特点：
  - 全双工通信。
  - 面向连接：通信双方在通信之前要先建立连接，作为信道。
    - 这里的连接是指逻辑网络上的连接，不是通过物理介质连接。
  - 传输可靠：可实现顺序控制、差错控制、流量控制、拥塞控制。

### 架构

- TCP 协议采用 C/S 架构：
  - server
    - ：称为服务器、被动连接方，由一个主机担任。需要持续监听某个 TCP 端口，供 client 连接。
    - Linux 系统通常可监听的端口号范围为 0~65535 ，例如 HTTP 服务器通常监听 TCP 80 端口。
  - client
    - ：称为客户端、主动连接方，由任意个主机担任，可以连接到 server 。

- 假设 client 想与某个 server 按 TCP 协议进行通信（比如传输一张图片），通常流程如下：
  1. client 事先知道 server 的 IP 地址、监听的端口号。
  2. 建立连接：client 发送几个特殊的 TCP 数据包给 server ，请求用 client 的随机一个端口，连接到 server 的指定一个端口。
  3. 正式通信：双方端口组成一个全双工信道，可以发送任意个包含任意 Payload 的 TCP 数据包。

- 在类 Unix 系统中进行 TCP/UDP 通信时，通信双方需要各创建一个 Socket 文件，以读写文件的方式进行通信。
  - 比如 client 向本机的 Socket 文件写入数据，会被自动传输到 server 端的 Socket 文件，被 server 读取到数据。

### 数据包结构

TCP segment 的结构如下：

![](./tcp.jpg)

- Source Port ：源端口，长度为 16 bit 。
- Dest Port ：目标端口，16 bit 。
- Seq number ：序列号，32 bit 。表示发送方已发送的最后一个字节的序列号。
- Ack number ：确认号，32 bit 。表示接收方期望收到的下一个字节的序列号。
- Data offset ：偏移量，4 bit 。表示 Payload 的起始坐标，即 TCP headers 的总长度。
- Reserved ：保留给未来使用，3 bit ，默认值为 0 。
- Flag ：标志符，9 bit 。每个 bit 代表一个标志位，默认值为 0 。
  - NS
  - CWR
  - ECE
  - URG=1 ：表示该 TCP 数据包是紧急数据，应该被优先处理。
  - ACK=1 ：表示确认。注意它与 Ack number 是不同字段。
  - PSH=1 ：表示该 TCP 数据包应该被发送方立即发送、被接收方立即上报。
    - 例如 Linux 在 TCP 通信时设计了发送缓冲区、接收缓冲区，可缓冲一定体积的多个数据包。
      - 发送 TCP 数据包时，默认会等发送缓冲区满了，才下发到网络层。
      - 接收 TCP 数据包时，默认会等接收缓冲区满了，才上报到应用层。
      - 使用缓冲区，能提高通信效率，但增加了通信延迟。
    - 例如一个应用层的 HTTP 报文可能拆分成多个 TCP 数据包发送，最后一个 TCP 数据包设置了 PSH=1 。
    - 假设缓冲区已有一些数据包，此时新增一个数据包：
      - 如果该数据包设置了 URG=1 ，则会立即处理该包，跳过处理缓冲区已有的包。
      - 如果该数据包设置了 PSH=1 ，则会立即处理该包以及缓冲区已有的包。
  - RST=1 ：表示拒绝 TCP 连接，不愿意接收对方发送的数据包。
  - SYN=1 ：表示请求建立 TCP 连接。
  - FIN=1 ：表示请求关闭 TCP 连接，但依然愿意接收对方发送的数据包，直到正式关闭连接。
- Window size
- Checksum ：校验和，16 bit 。
  - 计算方法：
    1. 将 TCP headers 中的 Checksum 清零。
    2. 在 TCP headers 之前加上 12 bytes 的伪头部，包含几个字段：Source IP、Dest IP、1 个 保留字节、protocol（传输层协议号）、length（原 headers + payload 的长度）。
    3. 计算整个 TCP 数据包（包括伪头部、原 headers、payload）的 Checksum ，记录到 TCP headers 中。
- Urgent pointer
- Options
- Payload ：载体，即该数据包要传递的实际数据。
  - Payload 之前的其它数据都只是用于描述 TCP 数据包的元数据，称为 TCP headers 。
  - 以太网中网卡的 MTU 通常设置为 1500 Bytes ，因此如果一个 TCP 数据包超过该长度，需要拆分成多个 IP 数据包才能传输。

### 建立连接

- 建立 TCP 连接时需要经过三个步骤，称为 "三次握手" ：

  ![](./socket_1.png)

  1. client 发送一个 SYN=1 的 TCP 包给 server ，表示请求连接到 server 的指定一个 TCP 端口。
  2. server 收到后，回复一个 SYN=1、ACK=1 的 TCP 包，表示允许连接。
      - 如果 client 收到该包，就证明自己发送的包能被对方接收，而对方发送的包也能被自己接收。因此从 client 的角度来看，判断双方能相互通信。
  3. client 收到后，发送一个 ACK=1 的 TCP 包，表示正式建立连接。
      - 如果 server 收到该包，则从 server 的角度来看，判断双方能相互通信。
      - 如果 server 一直未收到 ACK 包，处于 SYN_RECV 状态，则会在超时之后重新发送 SYN+ACK 包，再次等待。多次超时之后，server 会关闭该连接。

- 建立 TCP 连接时的 Socket 状态变化：
  - `LISTEN`      ：server 正在监听该 Socket ，允许接收 TCP 包。
  - `SYN_SENT`    ：client 已发出 SYN=1 的 TCP 包，还没有收到 SYN+ACK 包。
  - `SYN_RECV`    ：server 已收到 SYN 包，还没有收到 ACK 包。
  - `ESTABLISHED` ：已建立连接。

### 关闭连接

- 关闭 TCP 连接时需要经过四个步骤，称为 "四次分手" ：

  ![](./socket_2.png)

  1. 主动关闭方发送一个 FIN=1 的 TCP 包，表示请求关闭连接。
  2. 被动关闭方收到后，先回复一个 ACK 包，表示同意关闭连接。等自己准备好之后也发送一个 FIN 包，表示请求关闭连接。
  3. 主动关闭方收到后，发送一个 ACK 包，表示自己已关闭连接。
  4. 被动关闭方收到后，正式关闭连接。

- 只有 client 能主动建立连接，但 client、server 都可以主动关闭连接。
  - 建立连接时，通信双方都要发送一个 SYN 包、一个 ACK 包。
  - 关闭连接时，通信双方都要发送一个 FIN 包、一个 ACK 包。

- 关闭 TCP 连接时的 Socket 状态变化：
  - `FIN-WAIT-1`
  - `FIN-WAIT-2`
  - `TIME-WAIT`
    - 主动关闭方在第 3 步之后，已关闭 TCP 连接，而 Socket 处于 TIME-WAIT 状态，还要等待 2*MSL 时间才能变成 CLOSED 状态，从而避免对方来不及关闭 TCP 连接。
    - MSL（Maximum Segment Lifetime）：TCP 段在网络传输中的最大生存时间，超过该时长则会被丢弃。
      - RFC 793 定义的 MSL 为 2 分钟，而 Linux 中 MSL 通常为 30 秒。
    - 如果一个 server 被大量 client 建立 TCP 连接，则建议 server 不要主动关闭 TCP 连接，避免产生大量 TIME-WAIT 状态的 Socket ，浪费内存。这样有两种结果：
      - client 主动关闭连接，则 server 可立即关闭 Socket ，而 client 要保留 TIME-WAIT 状态的 Socket 一段时间。
      - client 不主动关闭连接，则 server 可等 TCP 连接长时间空闲、未用于传输数据，才主动关闭它。
  - `CLOSE-WAIT`
    - 在第 2 步，如果被动关闭方没有立即调用 close() 关闭端口，则会长时间处于 CLOSE-WAIT 状态。
  - `LAST-ACK`
  - `CLOSED` ：TCP、Socket 都已关闭。

### 数据包传输

- 建立 TCP 连接之后，通信双方就可以开始传输包含自定义 payload 的数据包。
- 一般将 TCP 连接保持一段时间，供双方多次通信，称为 keepalive 。等双方不再使用时，才关闭 TCP 连接。



#### 差错控制

- 确认
  - ：发送方每发送一个数据包，都要确认是否传输成功，流程如下：
    1. 发送方发送一个数据包，包含一个序列号 Seq number 。
    2. 接收方收到数据包，然后回复一个包含相同序列号的 ACK 包。
    3. 发送方收到 ACK 包，才确认指定序列号的数据包传输成功。

- 校验和
  - ：接收方每接收一个数据包，都要计算一次 Checksum ，检查它是否与数据包原有的 Checksum 相同，从而确保数据包在网络传输过程中没有变化。
  - 如果一个数据包不通过校验，或序列号重复，则接收方会丢弃该数据包，导致发送方会超时重传。

- 超时重传
  - ：如果发送方发送一个数据包之后，超过 RTO（Retransmission Timeout，重传超时）时长未收到 ACK 包，则重新发送原数据包。
  - 超时的常见原因：
    - 网络延迟突然变大
    - 发送的数据包丢失
    - 回复的 ACK 包丢失
  - 发送方设置 RTO 的值时，应该略大于 RTT 。
    - RTT（Round Trip Time，往返时间）：表示一个主机与另一个主机通信时，从发出数据包到收到回复的耗时，是端到端延迟的两倍。
    - 如果 RTO 比 RTT 大很多，则数据包丢失时，要等更久时间才重发。
    - 如果 RTO 比 RTT 小很多，则数据包没有丢失时，也容易重发，加剧了网络拥塞。
    - 例如 Linux 会根据网络最近一段时间的 RTT 平均值，动态设置 RTO 。

- 快速重传（Fast retransmit）
  - ：如果发送方发送一个数据包之后，没有收到 ACK 包，但之后发送的 3 个数据包都收到 ACK 包，则认为前一个数据包发送失败，不等超时就重传。

#### 流量控制

- 发送窗口
  - ：指发送方最多有多少个数据包已发送但未收到 ACK 确认。
  - 发送方可以同时发送多个数据包，等待 ACK 确认。如果发送窗口满了，就不能发送新的数据包。
  - 发送窗口不能超过接收方的接收缓冲区，否则会丢包。因此发送窗口取决于接收窗口，差不多相等。

- 滑动窗口
  - ：接收方将接收窗口的大小告诉发送方，发送方由此确定发送窗口。
  - 通过滑动窗口这个机制，可实现流量控制，控制传输速度。

#### 拥塞控制

- 网络拥塞：当网络延迟变大、发生丢包时，会引发超时重传，但重传的数据包又会增加网络负载，导致延迟更大、丢包率更高。
- 为了减轻网络拥塞，发送方会动态计算一个拥塞窗口（cwnd），然后将接收窗口、拥塞窗口中较小的一个值，设置为发送窗口的大小。
<!-- - 慢启动：刚建立 TCP 连接时，发送方给 cwnd 设置一个较小的值。之后每经过一次 rtt 往返通信，就将 cwnd 加 1 。 -->
<!-- 拥塞避免：，，， -->

- BBR
  - ：Google 于 2016 年发布的一个 TCP 拥塞控制算法。在网络延迟超过 100ms 、丢包率超过 1% 的场景下，能在发送 TCP 包时明显降低延迟、提高吞吐量。
  - 当网络链路拥塞时，传统的拥塞控制算法 Reno、Cubic 会将数据包放到缓冲区再发送，因此增加了延迟。而 BBR 算法会避免使用缓冲区。
  - Linux 内核 4.9 加入了 BBR 算法，可通过 sysctl 启用。
  - 拥塞控制算法只是 TCP 通信的单独一方的行为，因此发送方、接收方可以采用不同的算法。

## UDP

：用户数据报协议（User Datagram Protocol）
- 属于传输层协议，与 TCP 类似。
- 特点：
  - 全双工通信。
  - 面向无连接。
  - 传输不可靠。
- 对比 UDP 与 TCP ：
  - UDP 没有 TCP 的顺序控制、差错控制等功能，只是简单地发送数据包。
    - 使用 UDP 时，如果需要顺序控制、差错控制等功能，可在应用层实现。
  - UDP 的开销更低。比如 TCP 需要一直运行一个服务器，而 UDP 适用于即时通信、广播消息。



<!-- ## QUIC
 -->
