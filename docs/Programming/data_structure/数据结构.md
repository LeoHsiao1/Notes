# 数据结构

## 简介

- 什么是数据类型？
  - 现实世界中各种类型的信息，在计算机中可以用各种类型的数据表示，比如文本、图片。
  - 从机器语言的角度来看，各种类型的数据，都是存储成二进制格式，也就是一些 bits 。
  - 从汇编语言的角度来看，以 bit 为单位处理数据比较麻烦，通常以 byte 为单位处理数据。
    - 为了方便人类阅读，通常将每个 byte 的数据，表示为十六进制数字，取值范围为 00~FF 。
    - 也可以将每个 byte 的数据，表示为十进制数字，取值范围为 0~255 。
  - 从高级语言的角度来看，为了方便人类阅读数据，byte 数据可以表示为多种形式，比如十进制整数、十进制小数、英文字母。
    - 比如 C 语言的 int、float、char 数据类型，就是以不同形式表示数据，这些数据在底层都是存储成二进制格式。
    - 总之，机器语言、汇编语言通常不考虑数据类型，而高级语言通常划分了多种数据类型。

- 什么是数据结构？
  - 数据类型，是研究单个变量，如何存储、表示。
  - 数据结构，是研究由多个变量（又称为元素、节点）组成的一个集体，如何存储、表示。
  - 研究数据结构时，不一定严格要求其中元素的数据类型。
    - 比如 C 语言的数组，要求每个元素采用相同的数据类型。
    - 比如 Python 的列表，允许每个元素采用不同的数据类型。

- 人们发明了多种数据结构，按照是否有序，可以分为两大类：
  - 线性结构
    - ：所有元素，可以按照某种顺序，在逻辑上排列成一条线。
    - 有了顺序，就可以给每个元素分配一个序号，从 0 开始递增。
    - 线性结构是指逻辑上有序。在存储时，不一定有顺序。比如链表中的所有元素，分散存储，但逻辑上有序。
  - 非线性结构
    - 比如树形结构，每个元素只有一个父元素，但可以有一个或多个子元素。
    - 比如图形结构，任意两个元素之间都可能建立联系。因此访问一个元素之后，访问的下一个元素可能是任一元素。

## 数组

- 原理：
  - 将一组元素，存储在一组地址连续的存储空间中。
  - 每个元素占用的存储空间，大小相同，都是 Size 个字节。
  - 记录第 0 个元素的存储地址，称为 first_address 。

- 例如 C 语言中，使用数组：
  ```c
  int array[10];            // 创建一个数组，可以存储 10 个 int 类型的元素
  array[0] = 5;             // 给数组中第 0 个元素赋值
  printf("%d\n", array[0]); // 读取数组中第 0 个元素
  ```

- 特点：
  - 连续存储
  - 线性结构
    - 所有元素，可以按照存储顺序，在逻辑上排列成一条线。
  - 支持正序访问
    - 用户可以先访问 0_address ，里面存储的是第 0 个元素。然后访问下一块相邻的存储地址，里面存储的是第 1 个元素。然后访问下一块相邻的存储地址，里面存储的是第 2 个元素。以此类推。
    - 因此，用户可以按照 0->1->2 的顺序，依次访问所有元素。
  - 支持随机访问
    - 用户可以不遵守顺序，直接访问任一元素。
    - 假设用户想访问第 i 个元素，则可以计算出第 i 个元素的存储地址为 `first_address + i * Size` ，然后访问该地址。

## 栈

- 栈（stack）的原理：
  - 将一组元素，存储在一组地址连续的存储空间中。
  - 记录最后一个元素（称为栈顶元素）的存储地址。

- 提供 stack 这种数据结构的程序，一般允许用户执行以下几种操作：
  - 入栈（push）
    - ：将一个新元素，加入 stack ，成为新的栈顶元素。
  - 出栈（pop）
    - ：将栈顶元素，从 stack 取出，并读取该元素的值。同时，倒数第二个元素，会成为新的栈顶元素。
    - 打个比方，stack 像将多本书堆成一叠。用户要么在顶部加一本书，要么拿走顶部的那本书。用户不能操作非顶部的书。
    - push、pop 属于基础操作，时间复杂度为 O(1) 。
  - peek
    - ：读取栈顶元素的值，但不将它出栈。
    - 程序不一定支持 peek 。有的程序，必须将栈顶元素出栈，才能读取其值。
  - is_empty
    - ：检查 stack 是否为空，即不存在元素。
    - 如果 stack 为空，则 pop、peek 操作会失败，甚至可能导致程序 bug 。
    - 为了避免这种问题，有的程序会在每次 pop、peek 之前，自动检查 stack 是否为空。如果为空，则不进行 pop、peek 。
  - is_full
    - ：检查 stack 是否写满。
    - 创建一个 stack 时，一般要限制它的最大容量。如果 stack 写满了元素，则 push 操作会失败，甚至可能导致程序 bug 。
    - 为了避免这种问题，有的程序会在每次 push 之前，自动检查 stack 是否写满。如果写满，则不进行 push 。

- 特点：
  - 连续存储
  - 线性结构
  - 支持倒序访问
    - 用户执行一次出栈，就会取出栈顶元素。再执行一次出栈，就会读取下一个元素。
    - 这里采用的是倒序，又称为 LIFO（Last In First Out，后进先出），最后一个被写入 stack 的元素，会最先出栈、被读取到。
    - 读取数组中的元素时，不会修改数组。而读取 stack 中的元素时，需要出栈，删除栈顶元素。如果将 stack 中的所有元素出栈，则该 stack 内容为空。
  - 不支持随机访问
    - stack 中，每个元素占用的存储空间，大小不一定相同。因此用户想访问第 i 个元素时，不能计算出其存储地址。
    - 从技术上来说，如果用户记录了每个元素的存储地址，就支持随机访问。但 stack 是一种基础的数据结构，为了减少开销，只记录最后一个元素的存储地址。

## 队列

- 队列（queue）的原理：
  - 将一组元素，存储在一组地址连续的存储空间中。
  - 记录第一个元素（称为队头）的存储地址。
  - 记录最后一个元素（称为队尾）的存储地址。

- 提供 queue 这种数据结构的程序，一般允许用户执行以下几种操作：
  - 入队（enqueue）
    - ：将一个新元素，加入 queue ，成为新的队尾元素。
  - 出队（dequeue）
    - ：将队尾元素，从 queue 取出，并读取该元素的值。
    - 打个比方，queue 像一根水管，只能从一端塞入乒乓球，球会从另一端出来。
  - peek
    - ：读取队尾元素的值，但不将它出队。
  - is_empty
  - is_full
    - 创建一个 queue 时，一般要限制它的最大容量，最多存储 N 个元素。如果 queue 写满了元素，则 enqueue 操作会失败，甚至可能导致程序 bug 。
    - 为了避免这种问题，有的程序会在每次 enqueue 之前，自动检查 queue 是否写满。如果写满，则不进行 enqueue 。
    - 另一种方案是，如果 queue 写满，则每次 enqueue 之前，自动 dequeue 一个元素，从而腾出空间。

- 特点：
  - 连续存储
  - 线性结构
  - 支持正序访问
    - 这里采用的顺序是正序，又称为先进先出（First-In First-Out ，FIFO），最先被写入队列的元素，会最出队、被读取到。
  - 不支持随机访问

- 除了普通的队列，还有几种相似的数据结构：
  - 双端队列
    - ：队列的两端，都可以写入元素、取出元素。因此不遵循 FIFO 顺序。
  - 循环队列
    - ：让队尾元素的下一个元素，指向队头元素，使得队列收尾相连，在逻辑上形成一个圆圈。
  - 优先级队列
    - ：给每个元素设置一个优先级（priority），取值范围为 0~100 。每次出队时，找出当前优先级最高的元素。
      - 如果只有一个元素的优先级最高，则取出该元素。
      - 如果有多个元素的优先级最高且相等，则按照 FIFO 顺序，取出这些元素中最早入队的那个元素。


<!--
- 线性表，典型的例子就是数组。

- 堆(heap)：一种完全二叉树，读写顺序任意。
- 链表：像数组，但是属于链式存储结构，每个节点包含一个指向下一个节点的指针。
  - 顺序存储可以访问任意节点，而链表只能从第一个节点开始逐个访问。
  - 例：
typedef struct Node{
    int id;
    struct Node *next;            // 只有一个指向下一个节点的指针，称为单向链表
    // struct Node *last;            // 加上指向上一个节点的指针，就变成了双向链表
};
Node *n = malloc(sizeof(Node));    // 创建一个节点
n->id = 0;
n->next = NULL;                    // 初始化
-->

## 线性表

- 节点之间的连接线段称为边（edge）。

## 树

：树形结构。包含一些用边连接的节点，存在层级关系。
- 特点：
  - 有且仅有一个根节点。
  - 除了根节点以外，其它节点都有且仅有一个父节点。
  - 除了叶子节点以外，其它节点都有一个或多个子节点。

- 图例：

  ![](./binary_tree.png)

- 相关概念：
  - 森林（Forest）：包含多个不相交的树。
  - 根节点：唯一一个没有父节点的节点，是其它节点的父节点或祖父节点。
  - 叶子节点（leaf nodes）：没有子节点的节点，又称为外部节点（external nodes）。
  - 内部节点（internal node）：非叶子节点。
  - 节点的度（degree）：指该节点的子节点个数。
    - 叶子节点的度为 0 。
    - 树中节点的最大度数，称为树的阶数（order）。
  - 节点的路径（path）：指从根节点到该节点依次经过了哪些节点。
  - 节点的深度（depth）：指从根节点（深度为 0 ）往下到该节点经过的边数。
  - 节点的高度（height）：指从叶子节点（高度为 0 ）往上到该节点经过的边数。
    - 树中节点的最大高度（总是根节点），称为树的高度。

### 二叉树

：Binary Tree
- 特点：每个节点最多有两个子节点，称为左子树、右子树。

二叉树的常见类型：
- 满二叉树（Full Binary Tree）
  - 特点：内部节点都拥有两个子节点。
  - 只存在根节点时，也属于满二叉树。
- 完美二叉树（Perfect Binary Tree）
  - 特点：属于满二叉树，且叶子结点都位于最底一层，即深度相同。
- 完全二叉树（Complete Binary Tree）
  - 特点：叶子结点都位于最底一层，且集中在左侧。
  - 完全二叉树相当于完美二叉树去掉了最底一层的右侧部分叶子节点。
  - 例如上图属于完全二叉树，不属于满二叉树、完美二叉树。
- 平衡二叉树（Balanced Binary Tree）
  - 特点：在同一个父节点下，左子树与右子树的高度差不超过 1 。

#### 遍历

将二叉树转换成线形结构时，有多种遍历方法：
- 层序遍历（level order traversal）
  - ：从上到下逐层遍历，每层从左到右遍历。
  - 上图的遍历顺序是 abcdef 。
- 前序遍历（preorder traversal）
  - ：先访问父节点，再访问左子树的所有节点，最后访问右子树的所有节点。
    - 前序是指父节点最先访问。
    - 对于子树则递归遍历。
  - 上图的遍历顺序是 abdecf 。
- 中序遍历（inorder traversal）
  - ：先访问左子树，再访问父节点，最后访问右子树。
  - 上图的遍历顺序是 dbeafc 。
- 后序遍历（postorder traversal）
  - ：先访问左子树，再访问右子树，最后访问父节点。
  - 上图的遍历顺序是 debfca 。

Python 代码示例：
```py
class Node:
    def __init__(self, name, data=None, left=None, right=None):
        self.name  = name   # 节点名，必须指定
        self.data  = data   # 节点存储的数据，默认为空
        self.left  = left   # 左子节点，默认为空
        self.right = right  # 右子节点，默认为空
    def __repr__(self):
        return "Node('{}')".format(self.name)

def preorder(node):
    """ 前序遍历 """
    if not node:
        return []
    result = []
    result.append(node)
    result.extend(preorder(node.left))
    result.extend(preorder(node.right))
    return result

# 创建各节点
root            = Node('a')
root.left       = Node('b')
root.right      = Node('c')
root.left.left  = Node('d')
root.left.right = Node('e')
root.right.left = Node('f')
# 开始遍历
preorder(root)
```

改进 Node 的定义：
```py
class Node:
    node_dict = {}    # 记录所有节点
    def __new__(cls, name, *args, **kwargs):
        """ 创建节点时，如果已存在同名节点，则返回其实例 """
        instance = cls.node_dict.get(name)
        if instance:
            return instance
        else:
            instance = super().__new__(cls)
            cls.node_dict[name] = instance
            return instance
    def __init__(self, name, data=None, left=None, right=None):
        self.name  = name
        self.data  = data
        self.left  = left
        self.right = right
    def __repr__(self):
        return "Node('{}')".format(self.name)

Node('a').left  = Node('b')
Node('a').right = Node('c')
```
- 这里的每个 Node 存放一个数据元素，只需指定节点的 name ，就可找到对应的 data 。
  - 多个 Node 之间通过比较 name 的大小来排序。

#### 排序

二叉树常见的排序算法：
- 二叉查找树（Binary Search Tree ，BST）
  - ：一种便于查找节点的二叉树，将所有节点中序排列，即：
    - 左子树的所有节点都小于父节点。
    - 右子树的所有节点都大于父节点。
  - 读取一个节点时，可以根据二分法快速定位，时间复杂度为 O(log n) 。
    - 插入、删除一个节点时，需要先根据二分法定位，然后移动中序的后继节点，比较麻烦。
  - 如果二叉查找树只存在一条路径，呈线形结构，则定位的时间复杂度为 O(n) 。
    - 使用 AVL tree 可以保证树的自平衡，避免这种情况。

- AVL tree
  - ：一种自平衡的二叉查找树。
  - 每个节点会记录自己的平衡因子，其值等于左子树的高度 - 右子树的高度，取值范围为 -1、0、1 。
  - 插入、删除节点时，通常需要进行左旋、右旋操作，移动节点的位置，从而维持平衡。

- B tree（B- Tree）
  - ：一种具有自平衡、查找特性的树，不属于二叉树 。特点如下：
    - 叶子结点都位于最底一层。
    - 假设树的阶数为 n ，则每个节点拥有 [n/2, n] 个子节点。
    - 每个节点存放最多 n-1 个数据元素。
      - 每个元素以 name:data 键值对形式存储，按升序排列。
      - 根节点可以只存放 1 个元素。
      - 叶子节点的元素数量等于子节点数减一，从而与子节点呈中序排列。
  - 与 AVL tree 相比，B tree 的每个节点存放更多元素，因此减少了节点数，减少了左旋、右旋操作，减少了磁盘 IO 。

- BPlus tree（B+ tree）
  - ：在 B tree 的基础上，增加定义：
    - 内部节点只存放元素 name ，用于索引。其完整的元素 name、data 存放在叶子节点，是叶子节点中的第一个元素。
    - 在最底一层，每个叶子节点会记录相邻的下一个叶子节点的指针，因此形成了线形结构，允许进行更快的顺序遍历。
  - 例：一个 4 阶的 B+ tree 图

    ![](./bplus_tree.png)

  - 例：B+ tree 的节点定义
    ```py
    class BPTreeNode:
        def __init__(self, order):
            self.order      = order   # 记录树的阶数
            self.values     = []      # 一组元素的值
            self.keys       = []      # 一组元素的名称
            self.parent     = None    # 父节点
            self.children   = []      # 一组子节点
            self.next       = None    # 下一个叶子节点
            self.check_leaf = False   # 表示该节点是否为叶子节点
    ```

- 红黑树（Red-Black Tree，rbtree）
  - ：一种具有自平衡、查找特性的二叉树，采用较弱的平衡条件：
    - 叶子节点为空，只有内部节点存放数据元素。
    - 根节点、叶子节点总是黑色。
    - 其它内部节点可以是黑色或红色，只需要满足以下条件：
      - 每个红色节点的子节点都是黑色。
      - 对于任一节点，从该节点到其各个叶子节点，经过的黑色节点数相同。
  - 与 BST 相比，红黑树的平衡性保证了树中的最长路径不超过最短路径的两倍，因此查找耗时更稳定。
  - 与 AVL tree 相比，红黑树的平衡性较弱，减少了左旋、右旋操作，因此开销更低。

### 字典树

：又称为前缀树、trie ，是将前缀相同的单词存放在树的同一条路径上，方便查找单词。
- 原理：
  - 除了根节点以外，每个节点存放一个字母。
  - 每个节点可以有任意个子节点，每个子节点存放的字母不同。
- 使用单词的存放路径作为 key ，查找单词的 value 。
  - 树的高度等于最长的一个单词的长度。假设树的高度为 n ，则查找一个单词的时间复杂度为 O(n) 。
- 图例：

  ![](./trie.jpg)

## 图

：图形结构。包含一些用边连接的节点。
- 如果两个节点直接相连，则称为相邻。
- 线下结构属于树形结构，而树形结构属于图形结构。
  - 如果图形结构中的节点存在层级关系，则形成了树形结构。
  - 如果树形结构中只存在一条路径，则形成了线形结构。

