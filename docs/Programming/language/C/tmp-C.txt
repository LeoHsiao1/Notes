::: v-pre






 
C语言简介
## C语言的语法特点。
- C语言是强类型语言，变量都需要先声明数据类型才能使用。
- C语言是编译型语言，代码要编译成二进制程序才能运行。
- C语言代码中可以定义多个函数，每个函数实现一部分功能，并让函数之间相互调用。
  - 每个函数由一系列语句组成，按从上往下的顺序依次执行。
- C语言的源代码一般保存为两种文件。
  - 源文件：扩展名为.c，主要用于保存一些函数。
  - 头文件：扩展名为.h，主要用于保存一些变量、函数的声明语句。
- C语言的源代码不能直接执行，要编译成可执行文件之后才能执行（此时是转换成了当前机器上的机器语言）。
  - 具体编译过程请看GCC编译器的笔记。
## 语句是C语言的基本执行单位，用于描述数据或操作。
- 每行语句以分号 ; 结尾。
  - 可以一行写多条语句（每个都要以分号结尾），也可以将一条语句分成多行写（只能在空格处换行）。
  - 用 /* 和 */ 声明多行注释，C99开始可以用 // 声明单行注释。
  - 注释和除号都是用正斜杠 /（它是45度角），而转义字符是用反斜杠 \ 。
- C语言的语句分为四种：
  - 声明语句
  - 执行语句
  - 空语句（仅有一个分号）
  - 复合语句：用花括号 { } 包住多条语句，构成一个语句块，相当于一条语句。
## C语言的优点。
- 高级语言：C语言是高级语言，比使用汇编语言编程方便很多，可以定义函数。
  - 但是C语言不能面向对象，编写大型程序时比较麻烦。
- 接近底层：能实现汇编语言的部分功能，比如位运算、直接访问物理地址，因此C语言的运行效率高。
- 语法限制小：C语言的语法限制较小，编程时的灵活度高，但这也导致容易出错。
  - 比如，C语言不会检查数组的下标是否越界，由程序员自己检查。
- 结构化：支持分支、顺序、循环的流程控制结构，因此属于结构化语言。（早期的编程语言是非结构化语言）
- 模块化：可以将代码模块化，组合使用。
- 移植性好：C语言的编译器比较简单，容易移植。
##
##
##
 

 
基本语法
程序示例
## 如下是一个简单的输入输出程序：
#include <stdio.h>        // 导入头文件stdio.h，从而可以使用printf()和scanf()函数

void main(void){                                    // 定义main()函数
int x=0,y=0;                                    // 创建两个变量
printf("Please input integers (x,y) :\n");        // 显示一行字符
scanf("%d, %d", &x, &y);                        // 从终端读取两个值，保存到两个变量中
printf("x=%d, and y=%d\n ", x, y);                // 显示两个变量的值
return 0;                                        // 函数最后返回0值，告诉外界它运行正常
}
## main函数又称为主函数。
- 程序会从main函数处开始运行。
- 每个程序有且仅有一个主函数。
## main函数常见的三种函数头：
- void main(void)                        //没有返回值，没有形参
  - void表示主函数没有返回值，而main()括号内的void表示该函数不允许输入参数。
- int main(void)                         //有返回值，没有形参
- int main(int argc, char *argv[])         //有返回值，有形参
  - 在终端运行C语言程序时，可以给main函数传递一些参数。例如：
C:\Users\Will>D:\1.exe a b 3 4
  - argc用于存储从命令行输入的参数的个数。（在上例中为5）
  - argv[]用于存储argc个参数，其中argv[0]存储的是程序名。（在上例中为D:\1.exe）
  - 需要注意的是，argv[]是char *型指针数组，其中存储的参数都是字符串的形式。
##
##
##
 
输入输出
## printf是格式化输出函数，语法为：printf("格式控制字符串", 输出项);
- &x表示将输入值存储在变量x的内存空间中，& 称为取地址运算符。
- 格式控制字符串中的格式控制符会被变量替换，而其它字符会原样输出到终端（或从终端输入，用于排版）。
- 格式控制符说明了此处是什么类型的数据。如下。
  - %d    ：int或short类型
  - %u    ：unsigned int、unsigned short
  - %ld    ：long
  - %lu    ：unsigned long
  - %f    ：float
  - %lf    ：double、long double
  - %e    ：指数格式的float
  - %c    ：char
  - %s    ：字符串
  - %o    ：八进制
  - %x    ：十六进制
- 可以用 print("%m.nf",x) 的格式控制输出的位数，规定总位数（包括小数点）为m、小数点后的位数为n。
  - 例如：print("%.2f",x);
  - 输出浮点型数据时，小数点后默认是6位。
  - 实际总位数大于m时留下实际位数，小于m时在前面加空格补上。
  - 小数点后实际位数大于n时四舍五入再丢掉多余的位数，小于n时在后面加0补上。
  - %+m.n是让正负号都输出，%-m.n是让输出改为左对齐。
- 输出十六进制值的例子。
int i = 47;
printf("%x\n", i);        // %x表示输出小写的十六进制值
printf("%X\n", i);        // %X表示输出大写的十六进制值
printf("%#x\n", i);        // 加上#表示输出的十六进制加上0x前缀，即标准格式
printf("%#X\n", i);
// 输出分别为2f、2F、0x2f、0X2F
## scanf是格式化输入函数，语法为：scanf("格式控制字符串", 输出项);
- 可以用 scanf("%3d",&x) 的格式控制输入的位数，这里是取前三位。
  - 不过scanf函数不能控制输入的小数位数。
- 若在scanf()的%后插入 * ，比如 %*d ，则这个输入值被读取后不会存储。
- 例：
  - scanf("%2d",&x);                // 输入123456，则x=12
  - scanf("x=%d,y=%d",&x,&y);        // 格式控制字符串中包含非格式字符，输入时要对齐排版，即输入x=~,y=~
  - scanf("%d%d",&x,&y);            // 两个格式控制符之间没有间隔，输入时要用空格或Tab或回车作为定界符
  - scanf("%2d%2d",&x,&y);        // 输入123456，则x=12，y=34
- 使用 %[扫描列表]s 的格式读取输入时，只存储扫描列表中包含的字符，其它字符则看作定界符。
  - 减号 – 应放在扫描列表的最后位置。
  - 使用 %[^非扫描列表] 的格式读取输入时，会将非扫描列表中的字符都看作定界符。
  - 例如 scanf("%3[abcd]s",&x); ，若输入"abcdabcd"，则存储的结果为"abc"。若输入"abecd"，则存储的结果为"ab"。若输入"eabcd"，则没有存储的数据。
## 定界符：用于标明数据值的界限。例如字符的定界符是单引号 ' ，字符串的定界符是双引号 " 。
- scanf()中，%s默认的定界符是空格，即出现空格就表示这次输入结束。scanf()会从第一个非空格字符开始读取数据，所以有效字符之前的空格都无效。
  - 例如，若输入"Hello C!"，用 scanf("%s", &x); 只会得到空格前的Hello，而用 gets(x); 则会得到回车前的全部内容。
##
##
##
 
运算符
## 表达式由运算符（又称为操作符）和操作数组成。
- 运算符表示运算的类型，主要分为：
  - 算术运算符：加、减、乘、除、取模
  - 关系运算符：>  <  >=  <=  ==  !=
  - 逻辑运算符：&& 与、|| 或、! 非
  - 条件运算符：… ? … : …
  - 位运算符
  - 其它运算符
- 操作数是操作符的操作对象。
  - 比如a+b中，+是运算符，a、b是操作数。
- 任何表达式都有一个值，即运算结果。
  - 运算结果是数值的表达式就是算术表达式。
  - 逻辑表达式的值不是ture就是false。
## C语言的所有运算符按优先级从大到小的顺序排列如下。优先级相同的运算符，就看它是左结合性（即从左到右的顺序）还是右结合性。
- () 括号、[] 下标
  - 当表达式包含的运算符比较复杂时，可加上括号辅助分析。例如：
if(x-->5)等价于if((x--)>5)
if(!x||y--)等价于if((!x)||(y--))
- ! 逻辑非、++ 自增、-- 自减、+ - 正负号、& 取地址
  - 这一级都是右结合性。
  - ++a前缀自增是先自增再被引用，a++后缀自增是先被引用再自增，自减同理。
  - 自增、自减运算符只能作用于变量。比如++x++按右结合性来看相当于++(x++)，左边的自增作用于表达式，故语法错误。
- * 乘、/ 除、% 取模
  - C语言的除号不会四舍五入，因此精确计算时要先把操作数转换为浮点型。
  - 取模运算符的两个操作数必须是整型，结果的正负取决于被除数的正负。比如-7%3等于-1、7%-3等于1。
- + 加、- 减
- << 左移运算符、>> 右移运算符
- >  <  >=  <=
- ==  !=
- && 逻辑与
  - 例如：if((x>=2)&&!(x==3))
- || 逻辑或
- <表达式1> ? <表达式2> : <表达式3>
  - 条件运算符的语法是：若表达式1为真，则执行表达式2并返回运算结果；若表达式1为假，则执行表达式3并返回运算结果。
  - 条件运算符是C语言中唯一的三目运算符，有三个操作对象，又称为三元运算符。例如，加、减属于二目、二元运算符，正负号、自增自减属于单目、一元运算符。
- = 赋值运算符、复合赋值运算符
  - 复合赋值运算符是在赋值运算符的前面加上一个二目运算符。比如a+=5，是先执行a+5，再把这个结果赋值给a。
- 逗号运算符（优先级最低）
  - 由逗号运算符连接起来的多个表达式称为逗号表达式，程序会从左往右计算各个表达式，逗号表达式的值是取最后一个表达式。比如a=(2,3,6);的结果是a=6。
## 位运算符：对操作数（只能是整型）进行二进制位运算。
- a & b    ：按位与运算符，只有当两个操作数的对应位都是1时，结果位才为1，否则为0。如下图：

- a | b    ：按位或运算符，只要两个操作数的对应位有一个为1，结果位就为1。
- a ^ b    ：按位异或运算符，只有当两个操作数的对应位不相同时，结果位才为1。
- a << 3    ：按位左移运算符，将操作数的二进制值左移n位，并在右边空位补上0。
- a >> 3    ：按位右移运算符。
- ~a        ：按位取反运算符，将操作数的每一位的值取反。
##
##
##
 
选择结构
## if语句：又称为条件语句，根据条件表达式的真假来选择执行语句1或语句2。
- C语言本来没有bool类型，因此使用整数1、0分别记录条件表达式的真、假。
  - 例如if(1<3<2)，程序先判断1<3为真，得到1。再拿1与2比较，判断为真，得到1。最后表达式的结果为1。
  - 如果条件表达式的结果是其它数字、字符、字符串，则只要不等于数字0，就都视作真。
- if语句有以下三种语法格式：
  - if(条件表达式)    // 一路选择结构，当条件表达式的结果为true时才执行语句块
语句块        // 不管if语句的语句块有多少行，它都只算一个if语句
  - if(条件表达式)    // 两路选择结构，当条件表达式的结果为true时执行语句块1，否则执行语句块2
语句块1
else
语句块2
  - if(条件表达式)    // 多路选择结构，属于嵌套（即条件语句中的某个语句块也是条件语句）
语句块1
else if(条件表达式)
语句块2
else                // else会与它前面最近的一个if配对
语句块3
## switch语句：适合判断多种条件的情况，比嵌套的if语句更直观。
- 语法：若switch条件表达式的值与某个case后的值相等，则执行这个case以后的所有语句，直到switch语句结束或者遇到break语句。
  - 若没有一个相等的case，则执行default后的语句块（可以省略）。
  - switch条件表达式和case表达式的结果只能是整型或字符、字符串，而且case表达式还必须是常量表达式。比如1、'one'，
- switch(表达式){            // switch语句的内容要用花括号包起来
case 表达式1:        // 注意case语句的结尾有冒号
语句块
break;
case 表达式2:        // 多个case可以共用一个语句块
case 表达式3:
语句块
break;
default:
语句块3
}
##
##
##
 
循环结构
## for语句：
- 语法：在进入时执行一次表达式1，然后判断条件表达式2的真假——
  - 如果条件表达式2为真，则执行作为循环体的语句块，然后执行一次表达式3，接着重复判断条件表达式2的真假。
  - 如果条件表达式2为假，则结束循环。
- for(表达式1; 条件表达式2; 表达式3)
循环体;
  - 在循环体中用break语句可以直接跳出该层循环结构，用continue语句可以结束本次循环跳到下一次循环。
  - 在for语句中，每次循环的第一步是执行表达式3；在while语句、do-while语句中，每次循环的第一步是判断条件表达式。
## while语句：判断条件表达式的真假，如果为真则执行循环体，否则结束循环。
- while(条件表达式)
循环体;
## do-while语句：先执行一次循环体，再判断条件表达式的真假，如果为真则执行循环体，否则结束循环。
- do
循环体;
while(条件表达式);      //注意do-while语句的结尾有分号
##
## goto语句：可以跳转到标签所在处，不过容易将程序变得复杂。
- one: printf();
goto one;
##
##
##
 
变量
## 各种对象的名称统称为标识符。
- 标识符不能使用保留字（系统保留了它们的使用权）。
  - 保留字分为两种，一种是关键字，它们有特殊含义，另一种是留给未来使用的，现在还没有特殊含义。
- C语言中，标识符只能由字母（区分大小写）、数字和下划线（看作字母）组成，且开头不能是数字。
  - 变量名、函数名一般小写首字母，而后面的各个单词一般大写首字母。
  - 常量名应该大写全部字母。
  - 类名、结构体名一般大写首字母。
## 变量：用一个标识符表示某个值，并且取值可以改变。比如用a表示1。
- 变量会占用一定的内存空间来存储其值。
## 创建变量。
- 访问（读值或赋值）一个变量之前要先创建它：
int x;        // 创建一个int型的变量，名为x
x = 1;        // 给变量x赋值
  - 用int、float等关键字可以定义变量的数据类型，此外还可以用static、const等关键字声明变量的特殊属性。
  - 在变量的定义语句之前访问该变量会报错，除非它是外部作用域的全局变量。
  - 刚创建的变量的取值不确定（某些编译器会初始化为0），要立即分配一个值进行初始化，以免被程序使用导致出错。
- 可以在创建变量的同时赋值：
int x = 1;
- 可以在一个语句中同时创建多个变量：
int x, y;
int a = 1, b =2;
- 同一个变量名不能重复创建：
int x;
int x;        // 运行时会报错
- 等号 = 称为赋值号，用于将等号右边的值分配给等号左边的变量。
  - 赋值表达式的返回值为所赋的值，因此可以在一个语句中使用多个赋值号：
int x, y;
x = y = 1;            // 相当于 x = 1
x = (y=1) +1;            // 相当于 x = 1 + 1
  - 不能在创建变量的同时多重赋值：
int x = y = 1;    // 该语句被从左向右执行，用y给x赋值时，变量y还没有被创建
##
##
##
 
变量的作用域
## 一般对象（比如变量、函数）的作用域都是从其定义语句或声明语句开始，到其所在的代码块末尾结束。
- 定义语句用于定义对象的实际内容，会让编译器创建相应的标识符、内存空间。
  - 声明语句用于声明对象的存在，会让编译器创建相应的标识符，然后去寻找其定义语句（可能在当前位置的后面，也可能在其它文件中）。
- 一般对象只能有一个定义语句，但可以有多个声明语句。
## 变量的作用域：变量可以被访问的位置。
int a = 0;        // 全局变量
extern void Fis_Cal(void);    // 外部变量

int main(void){
    int a = 0;    // 局部变量
    static int b = 0;
    return 0;
}
- 局部变量：在函数、for、while等代码块中定义，作用域从其定义语句开始，到代码块末尾结束。
  - 当程序运行到作用域之外时，局部变量会被编译器自动销毁，因此不能在外部访问该变量。
  - 例如：如果在函数内定义一个数组，存储某些值，然后把数组的首地址返回到函数外部。当函数运行结束之后，该数组就会过时，其地址空间中存储的数据随时可能被覆盖。
  - 在局部作用域中，如果编译器遇到一个局部变量与一个外部变量重名，则优先使用局部变量。
- 全局变量：在函数之外定义，作用域从其定义语句开始，到源文件末尾结束。
  - 全局变量应该尽量减少使用，因为它的缺点有：一直占用栈空间、使代码耦合。
## 用关键字static可以把变量声明为静态变量，在其作用域结束之后不会被编译器自动销毁。
static int x = 1;
- 如果把一个函数内的局部变量声明为静态变量，那么当函数运行结束后它不会被销毁，下一次运行该函数时还可以读取到它的值。
  - 静态局部变量在编译时就会被创建、赋初值，重复执行其定义语句时会被忽略。
- 静态变量的作用域不会改变，依然只能在其原来的作用域内被访问。
- 静态变量会一直占用内存空间，因此不能存在太多。
## 在变量、函数的声明语句中，用关键字extern可以把变量或函数声明为外部变量、外部函数。此时，编译器会先在当前文件中寻找其定义语句，找不到的话再去其它导入的文件中寻找。
extern int x;
- 一般的函数都默认为外部函数，所以不必再用extern声明。但可以用static声明，不允许被其它文件调用，从而避免与其它文件的函数发生重名冲突。
## C语言中，变量的存储方式分为以下几种。同时只能用一种存储类型说明符来声明变量。
- auto：自动类型。需要用到时会由编译器自动分配内存空间，用完就自动销毁。
  - 比如函数的形参、函数内的局部变量，它们默认就是用关键字auto声明的：
int fun1(int x){
    int y;        // 相当于 auto int y;
    return x+y;
}
- static：静态类型。需要用到时会由编译器自动分配内存空间，但是用完了不会自动销毁，可保留到下一次使用。
  - 用关键字static声明：
static int x;
- extern
- typedef
- register：寄存器类型。存储在寄存器中，使得CPU的读写速度更快。
  - 用关键字static声明：
register int x;
##
##
##
 
数据类型
## C语言中，变量的数据类型分为四大类：空类型（void）、基本类型、指针类型、构造类型。
- 变量的基本数据类型分为整型、浮点型、字符型三类，具体包括int、short、float、double、char等。
  - C语言中没有字符串型变量（C++中才有），只有字符串型常量。
## 数据类型的转换。
- 自动类型转换：不同类型的数据混合运算时会按运算符优先级顺序转换为保值精度更高的数据类型，即short,char-->int-->unsigned int-->long-->unsigned long-->double。
  - 另外，float参与运算时一律先转换为double，甚至两个float之间都要先转换为double再运算。
- 强制类型转换有两种情况：
  - 赋值号右边的数据会强制转换成左边变量的数据类型。
  - 用 (类型说明符)(表达式) 的格式进行强制类型转换。但只会转换最近的一个数，比如 (int)x/3.14 相当于先int x再x/3.14。
浮点型转换为整型时会直接丢掉小数部分，比如 int x=3.14; 的结果为 x==3 。
double型转换为float型时会四舍五入再丢掉多余的位数。比如float x = 123456789; 的结果为 x==123456792.000000，因为float的有效位数为前七位，从第八位起的数据都是不准确的。
- 自动和强制类型转换都只是临时的转换，只影响计算结果，不会改变原变量的数据类型。
## 用 sizeof(变量名) 或 sizeof(数据类型名) 的格式，可以得到变量或数据类型所占的内存大小（单位为bytes）。
- sizeof不是函数，而是容量运算符、关键字。

sizeof 不是操纵符，也不是函数，因为在运行阶段没有它，它没有被编译成机器
指令。可以把它看做一个宏。

sizeof 在编译期间就处理完成了。所以像size(a=3)这种，a是不会被赋值的。
a还是原来的值。


cout<<sizeof(int)<<endl;
cout<<4<<endl;        \\ 实际上编译器看到的
- 变量所占的内存大小由其数据类型决定，但也会受到CPU、编译器影响。
  - int型的取值范围是-231~(231-1)。因为总共32位二进制数，去掉一个最高位符号位，再因为从0开始计数而减一。
  - unsigned int型的取值范围是0~(232-1)。
- “字节”是计算机最基本的存储单位，而“位”是最小的存储单位。
  - 1个字节等于8位即1Byte =8bit（binary digit的缩写，一位是指二进制的0或1）。大写的B表示字节，小写的b表示位。
  - 1KB即1千字节等于1024字节，这些字节从0到1023编号。
  - 二进制中，1024是10位1，1M是20位1、1G是30位1。
## 可以用typedef关键字定义某种数据类型的别名。如下：
typedef unsigned int u16;        // 最后一个字段是别名，在typedef与最后一个字段之间的是实际的数据类型
u16 i;
typedef char * String;
String p;                    // 相当于char *p;
typedef struct{...} Horse;    // 相当于定义一个类
##
##
##
 
基本数据类型
## 整型：用于存储整数。
- int：基本整型，。
- short：短整型（是short int的简写）。
- long：长整型（是long int的简写）。
  - 在32位、64位CPU上，long与指针的容量都相同，因此可以用long型变量来存储指针地址。
- long long：双长整型（是long long int的简写），只能在64位机上定义，占8字节。
容量\CPU位数    32bit    64bit
char    1 Byte    1 Byte
short    2    2
int    4    4
long    4    8
指针    4    8
## 浮点型：用于存储实数。浮点是指小数点位置的浮动。
- float：单精度浮点型，占4字节。
  - 用小数给float型变量赋值时应该加上 f 后缀。
float pi = 3.14f;        // 3.14f会被看作float型的常量，赋值给float型的变量pi
float pi = 3.14;        // 3.14会被看作double型的常量，赋值时会被强制转换成float型
- double：双精度浮点型，占8字节。
- long double：长双精度浮点型，占16字节。
- 每种浮点型还有两种表示形式：
  - 小数形式：比如 3.14 。
  - 指数形式：比如 3.14E5 、-3.1415e-3f ，E或e的前面必须要有数字，后面必须是整数。
## 字符型。
- char：存储单个字符，占1字节。
  - 例：
char c = 'A';        // 将单个字符'A'存储到变量c中（实际上存储的是'A'的ASCII码值65）
char c = 65;        // 将整数65转换成char类型再存储到变量c中（此时c=='A'）
- C语言中没有String类型变量，要通过数组等方式存储字符串。
## 整型和字符型还可分为两种情况：
- signed：有符号型，将最高位用作符号位，表示正负。
  - 默认是这种。例如 int x = 1; 相当于 signed int x = 1;
- unsigned：无符号型，将最高位用于存储数据。只能存储非负整数，但容量大了1倍。
## bool：布尔类型，取值为true或false。在C99中加入的新类型。
- 导入头文件<stdbool.h>后便可以创建bool类型。
- 也可以自己定义bool类型，例如：
typedef char bool;
# define true 1
# define false 0

bool flag;
flag=1;            // bool实际上是char型，所以可以拿各种数字赋值，使用时就判断是否为0
flag=false；        // 如果拿除了false、true以外的其它字符串赋值就会报错说未定义（大小写也必须一致）
##
##
##
 
常量
## 常量：取值不能改变的对象。分为以下几类：
- 整型常量        ：比如123456。
- 浮点型常量    ：比如3.14。
- 字符常量        ：只有一个字符，用单引号包住，比如'A'、'B'。
- 字符串常量    ：包含不止一个字符，用双引号包住，比如"hello world"。
  - 存储字符串时，最后一个字符必须是空字符 \0（其ASCII码为0，用十六进制表示为\x00），表示字符串的结束。
- 符号常量        ：用一个标识符代表一个上述类型的常量。
  - 用宏定义可以定义符号常量。比如：#define PI 3.14
  - 用关键字const可以把变量声明为只读变量，在初始化之后就不能再赋值。比如：const float pi = 3.14f;
## 判断常量的数据类型。
- 如果常量由纯数字组成，则：
  - 如果不包含小数点，则视作整数。
默认为int型；如果以 L 或 l 结尾，则视作 long 型。
  - 如果为小数形式或指数形式，则视作浮点数。
默认为double型；如果以 F 或 f 结尾，则视作float型；如果以 L 或 l 结尾，则视作long double型。
  - 如果以 U 或 u 结尾，则视作无符号型。
比如3U会被视作unsigned int型；3.14U是非法的，因为浮点型不能无符号位。
- 如果常量不是由纯数字组成，则：
  - 如果以单引号 ' 作为定界符，则视作字符类型。
  - 如果以双引号 " 作为定界符，则视作字符串类型。
- 例如：
float x = 3.14;        // 正确，此时3.14会从double型转化成float型再赋值
float x = 3.14f;       // 正确，此时3.14直接赋值给float型的变量x
float x = 3f;             // 错误，3是整数，不能声明为float型
##
##
##
 
数组
## 数组：一组数量固定、类型相同的数据项（又称为元素）。
- 定义数组后会创建一段连续的内存空间，来存储数组元素。
  - 数组名同时也是数组的首地址，因此调用数组元素的格式是array[下标]。
  - 下标从0开始，即第一个元素是array[0]。
  - 下标可以是变量。
- 定义一个整型一维数组的例子：
  - int array[10];            // 定义数组时必须用常量设置数组长度（因为在程序编译时就要给数组分配内存空间）
  - int array[]={0,1,2,3};    // 或者通过完全赋值来确定数组长度
  - int array[10]={0,1};      // 或者在设置数组长度的同时进行部分赋值
  - int array[];                // 语法错误，没有定义数组长度
- 定义一个整型二维数组的例子:
  - int array[2][3];                // 定义一个2行3列的二维数组
  - int array[2][3]={0,1,2,3};    // 按顺序对前4个元素赋值
  - int array[2][3]={{0,1,2},{3}};
  - int array[][3]={{0,1,2},{3}};
## 用for语句输入、输出一个二维数组的例子：
int main(void){
int array[2][3];
int i = 0, j = 0;
printf("Please input the array:\n");
for (i; i < 2; i++){
    for (j = 0; j < 3; j++){
        scanf("%d", &array[i][j]);
    }
}

int num = sizeof(array) / sizeof(int);            //得到二维数组的总长度
int len2 = sizeof(array[0]) / sizeof(int);        //得到二维数组第二维的长度
int len1 = num  / len2;                        //得到二维数组第一维的长度

printf("The array is:\n");
for (i = 0; i < len1; i++)
{
    for (j = 0; j < len2; j++)
    {
        printf("%d ", array[i][j]);
    }
    printf("\n");
}
system("pause");
return 0;
}
##
##
##
 
结构体
## 结构体：由多个变量组成的数据结构，相当于一种用户自定义的数据类型。
- 用struct关键字可以定义结构体。
  - 结构体名可以与某个变量名相同，但是会影响程序可读性。
  - 结构体中的各个变量称为结构成员，可以是不同的数据类型，比如整型、数组、指针，甚至是另一个结构体。
  - 用“struct 结构体名”的格式可以把结构体名作为一个数据类型名使用。比如sizeof(struct Horse)
  - 用“struct 结构体名 结构变量名”的格式可以定义一个指定结构类型的结构变量。
  - 用 "结构变量名.结构成员名" 的格式可以引用一个结构变量的结构成员，其中 . 是成员运算符。
  - 一个结构变量所占内存空间等于其全部结构成员所占内存空间的总和。
- 例子：
struct Horse{        // 定义一个结构体，名为Horse
    char name[10];    // 不能在定义结构体时初始化结构成员
    int age;
};                      // 定义语句的结尾注意加分号

struct Horse h1 = {"Jack", 0}, h2;        // 定义Horse类型的结构变量h1, h2
h2 = h1;                                // 同类型的结构变量之间可以直接赋值
printf("Please enter the name:\n");
scanf("%s", h1.name);                    // 这里name是数组，所以不需要用&取地址
printf("Please enter the age:\n");
scanf("%d", &h1.age);
  - 可以在定义结构体的同时创建结构变量：
struct Horse{
    char name[10];
    int age;
} h1 = {"Jack", 0};
  - 可以定义某种结构体的数组：
struct Horse list[10];
list[0].age = 10;
list[1] = list[0];
  - 可以定义某种结构体的指针：
struct Horse *phorse = &list[0];
(*phorse).age = 10;                        // 先取消对phorse的引用再选择结构成员
printf("The age is %d\n", phorse->age);    // -> 等价于 (* ).
## 结构体与类的区别：
- 结构体只是把一些变量封装在一起，而类是一种抽象描述，最大的优点就是可以被继承。
- 结构体是一种值类型，存储的是实际的数据。而类是引用类型，存储的是对象的地址。
- 结构体不能在定义时初始化结构成员，而类可以。
##
##
##
 
指针变量
## 指针变量（pointer）：用于存储某个对象的内存地址（又称为指针）的变量。通常可简称为指针。
- 指针变量必须与对象的数据类型相同。
  - 比如int *类型的指针只能存储int类型的变量的地址。
  - 这是因为，指针变量必须根据正确的数据类型，才能从目标变量的内存地址中读取出正确的值。
## 指针变量的定义。例如：
int x = 1;
int *p;                // 定义一个int *类型的指针变量，此时它是野指针
int *p2 = NULL;        // 定义一个int *类型的指针变量，同时初始化为空指针
int *p3 = &x;            // 定义一个int *类型的指针变量，指向int类型的变量x的地址
p = &x;                // 用变量x的地址给指针p赋值，使它指向该地址
(*p)++;                // 使指针p所指变量的值加一
printf("%d\n", *p);    // 显示p所指的变量的值
scanf("%d", p);        // 读取一个值存储到p所指的变量中（p本身就是一个地址，不需要使用 &p）


通过下标访问数组元素时，实际上是通过指针访问指定位置的数组元素。
例如 `array[2]` 等价于 `*(array+2)` 中，数组名 array 是一个指针，指向数组的第一个元素。下标二表示将指针指向的地址加 2 个单位。

- 用取地址运算符 & 可读取对象的内存地址。
- 用取消引用运算符 * 可读取指针所指对象的值。
  - 在定义语句中， * 不是取消引用符，而是数据类型int *的一部分。
- 自增 ++ 、自减 -- 与取消引用运算符 * 的优先级相同。因此 *p++ 是使p所存储的地址值加一，(*p)++ 是使p所指的变量的值加一。
  - *p++并不只是把地址值增加一个bit，而是增加一倍的sizeof(*p)。这样访问一系列地址连续的对象（比如数组）时很方便，便于指向下一个同类对象。同理，*(p+2)是指向下下个同类对象。
- 一个指针变量所占的内存空间通常是4字节，但也可能受到CPU、编译器影响。
  - 不管指针指向的变量有多大，一个指针只需要存储一个固定长度的地址值。如下：
int x;
long y;
int *a = &x;
long *b = &y;
printf("%d, %ld\n", sizeof(a), sizeof(b));        // 显示为4, 4
- 可以将一串地址直接赋值给指针：
unsigned int addr = 34926608;
int *p = (int *)addr;            // 将普通类型转换成指针类型
void *p2 = (void *)p;            // 强制转换指针类型
printf("%d\n", p);            // 显示地址
##
##
##
 
指针的类型
## 特殊类型的指针。
- 通用指针：即void *类型的指针，它可以指向任意数据类型的对象。
  - 把通用指针赋值给其它类型的指针时，会自动转换指针的数据类型。
  - 通用指针不能取消引用，因为不知道对象的数据类型。
- 空指针：值为NULL，即没有存储任何地址。
  - NULL的值被宏定义为0，因此也可以空指针赋值为0。
- 野指针：指向一个内容未知的内存空间的指针，贸然读取它的值容易使程序出错。
  - 一个指针刚被创建出来时是野指针，应该将它立即赋值或初始化为NULL。
- 常量指针：指向常量的指针。
  - 比如const int *p = &x; 不能用*p=3改变x的值，但可以用p=&y改变指针的指向。
- 指针常量：指针变量本身是常量，不能修改其存储的地址值。
  - 比如int *const p = &x; 可以用*p=3改变x的值，但不可以用p=&y改变指针的指向。
  - 特别的，const int *const p=&x; 定义的是一个指向常量的指针常量。
## 功能强大的指针。
- 数组指针：数组名本身就是数组的首地址、数组第一个元素的地址，因此可以把数组名赋值给指针。如下：
int a[10];
int *p = a;
p[0] = 1;        // 可以把数组指针当做数组名使用，相当于增加了指针功能的数组名
*(p+2) = 2;        // *(p+n)相当于a[n]
  - 对于一维数组a[10]，有：a == &a[0]
  - 对于二维数组a[10][10]，有：
a == a[0]、a[0] == &a[0][0]、a[1] == &a[1][0]
int *p = a; (++p) == &a[0][1])
*a == a[0]、**a == a[0][0]
- 指针数组：创建一个数组，每个元素都是一个指针。如下：
int *a[3], x=0;
a[0] = &x;
- 函数指针：函数名本身就是函数的地址，因此可以把函数名赋值给指针。如下：
int sum(int a, int b);            // 声明一个函数
int (*psum0)(int, int);            // 定义一个函数指针
int (*psum)(int, int) = sum;        // 定义一个函数指针并赋值
int result = psum(2, 3);            // 可以把函数指针当做函数名使用，相当于增加了指针功能的函数名
int average(int x, int y);        // 声明另一个函数
psum = average;                    // 让函数指针指向另一个函数（函数头必须一致）
  - 定义函数指针时，要像声明函数头一样写明返回值类型、形参类型，而且函数指针要用括号包住，否则就变成了指针函数。
  - 定义函数指针的数组：
int (*psum[10])(int,int);
psum[0] = sum;
  - 函数指针不能进行 ++、+2 等算术运算。
## 下例是将指针转换成数字地址、字符串地址。
#include <stdio.h>

int main(){
    // 创建一个指针
    char str[]="Hello";
    printf("%p\n", str);
    // 显示为：0x7fffbc9e0630

    // 将任意类型的指针转换成long型变量
    long addr = (long)str;
    printf("%lx\n", addr);
    // 显示为：7fffbc9e0630

    // 将long型变量转换成任意类型的指针
    char *p = (char *)addr;
    printf("%s\n", p);
    // 显示为：Hello

    // 将long型变量打印到字符串中
    char buffer[20];
    sprintf(buffer, "%lx", addr);
    printf("%s\n", buffer);
    // 显示为：7fffbc9e0630

    // 从字符串中读取long型变量
    long addr2 = 0;
    sscanf(buffer, "%lx", &addr2);
    printf("%lx\n", addr2);
    // 显示为：7fffbc9e0630

    return 0;
}
##
##
##
 
<stdlib.h>
## 动态分配内存。
- void *malloc(size_t size);
  - 请求分配一块内存空间，大小为size字节。如果请求成功则返回一个指向该内存地址的void *指针，否则返回NULL。
  - 例如：
char *str1 = malloc(10*sizeof(char));
if(str1 == NULL)            // 动态分配内存之后应该先检查返回的指针是否有效
    return -1;            // windows存在虚拟内存机制，因此一般不会无内存可分配
printf("%s\n", str1);        // 显示为乱码，因为该内存空间存储着垃圾数据
strcpy(str1, "Hello");
printf("%s\n", str1);        // 显示为：Hello
free(str1);                // 使用完之后应该及时释放这块内存空间
  - malloc()返回的指针类型是void *，但是不必转换其数据类型，因为：
1. void *指针在赋值时会自动转换指针的数据类型。
2. C语言中，如果编译器调用一个函数时没有找到它的声明，则会自动进行隐式声明（implicit declaration），使其返回值为int型。因此如果忘了导入头文件stdlib.h，malloc()函数的返回值会是int型，不能给指针类型的变量赋值，编译时就会及时报错。
  - 如下，C++中使用malloc()函数时需要进行强制类型转换，否则会报错：无法从 void * 类型转换成 char *类型。
char *str1 = (char *)malloc(10*sizeof(char));
- void *calloc(size_t num, size_t size);
  - 请求分配一块内存空间，大小为num*size字节，并将其初始化为0。如果请求成功则返回一个指向该内存地址的void *指针，否则返回NULL。
  - 例如：
char *str1 = calloc(10, sizeof(char));        // 相当于malloc(10*sizeof(char))
if(str1 == NULL)
    return -1;
printf("%s\n", str1);        // 显示为空
strcpy(str1, "Hello");
printf("%s\n", str1);        // 显示为： Hello
free(str1);
- void *realloc(void *p, size_t size);
  - p指向一个用malloc()或calloc()分配的内存空间，请求改变其大小为size字节。如果请求成功则返回原指针p，否则返回NULL。
  - 如果p为空指针，则realloc()会创建一个size字节的内存空间。
  - 例如：
char *str1 = malloc(10*sizeof(char));
char *rc = realloc(str1, 20);
if(rc == NULL)
    return -1;
- void free(void *);            // 释放动态分配的内存空间
  - 应该及时释放不用的内存，以免程序占用越来越多的内存，导致内存泄露（memory leaks），使得系统变得卡顿甚至使程序奔溃。
##
##
##
 
内存问题


C程序启动时，会向操作系统申请一定大小的内存空间。然后将该内存空间划分成几个区域：
- 堆区（heap）：动态存储区
  - 堆区内存由程序员主动分配、释放（通过执行malloc、free等函数），如果没有释放则会一直保留，当程序终止时会被系统自动释放。
  - 存储结构类似于数据结构中的链表，而不是堆。
- 栈区（stack）：局部变量区
  - 栈区的内存由系统在运行程序时自动按需分配、释放。
  - 存储结构类似于数据结构中的栈。
- 静态变量区（static）
  - 全局变量也是采用静态存储方式，存储在这里
- 常量区 ：存放常量字符串。
- 代码区 ：存放二进制代码。


## C语言编译器给程序分配内存时有两种方式：
- 静态的内存分配方式：在程序编译时就分配好内存空间，此后一直不变，直到程序终止才释放。
  - 比如函数、数组、全局变量、静态变量。
- 动态的内存分配方式：当程序需要用到时才分配分配、释放内存空间。
  - 比如局部变量、动态分配的内存。
## 常见的内存问题。

- 访问无效的内存地址：可能导致程序崩溃。比如访问已经被销毁的内存地址。
- 内存越界访问
  - ：访问一个对象时，使用了不合理的内存地址，超出该对象的内存地址范围。
  - 例如：程序用 malloc() 申请一块 2 bytes 的内存空间，得到一个指针。然后往该指针指向的内存地址，写入 3 bytes 的数据。此时第 3 个 byte ，就写到了当前内存的地址范围之外。
  - 为什么程序会发生内存越界访问？通常是因为编程时没有检查写入值的长度。例如：
    - 申请一块内存空间，准备写入一个字符串。但使用 strcpy、strcat、sprintf、gets() 等函数，没有限制字符串的长度，因此字符串可能超出预期长度，导致内存越界访问。建议换成 strncpy、strncat、snprintf 等函数。
  - 根据访问方式，分为两种情况：
    - 读越界：可能读取到错误的数据，导致程序出错，甚至崩溃。
    - 写越界：可能修改其它变量使用的内存空间，导致程序出错，甚至崩溃。
  - Linux 内核会为每个进程维护一个页表，记录该进程申请使用了哪些堆内存地址。当进程访问一个内存地址时，
    - 如果该内存地址包含于当前页表中，则说明已分配给该进程。因此内核会允许该进程访问，不管是否越界。这可能产生几种越界情况：
      - 该内存地址正在被当前进程的其它变量使用。
      - 该内存地址未被当前进程使用，但以后可能被使用。
    - 如果该内存地址不在当前页表中，则说明未分配给该进程。因此内核会拒绝该进程访问，发出 segment fault 信号，导致进程崩溃。
  - 除了堆内存，如果进程越界访问内核内存空间、只读存储区、代码段，Linux 内核也会拒绝该进程访问，发出 segment fault 信号，导致进程崩溃。

- 栈溢出（stack overflow）
  - ：在栈区发生的内存越界访问。
  - 程序运行时，会将所有函数参数、局部变量存储在内存的栈区。对这些变量的访问可能越界，例如：
    - 读写数组时下标越界。这可能会读写隔壁变量的内存空间。
      恶意用户可利用程序的栈溢出漏洞，修改程序中某些重要的变量。该操作称为栈溢出攻击。
    - 创建太大的数组，超出栈区的容量，导致程序崩溃。
    - 每次调用一个函数，都会在栈区分配一块内存来存储函数参数、局部变量，当函数执行完毕时才释放内存。如果一个函数调用另一个函数，如此嵌套，调用层数太深，则占用内存可能超出栈区的容量，导致程序崩溃。

- 缓冲区溢出攻击（Buffer Overflow Attack）
  - ：一种攻击方式。通常是程序的开发者，将程序交给其他人使用，但有人故意引发内存越界访问，从而控制该程序执行不合理的操作。
  - 原理：攻击者向程序的一个变量（通常用作缓冲区，允许用户修改）中，故意写入过长的数据，超出该变量的内存地址范围，写入到了该变量隔壁的内存地址，从而修改隔壁的数据（比如变量、函数返回地址）。
  - 栈溢出攻击：缓冲区溢出攻击的一种形式，在栈区发生。


- 内存泄漏（memory leak）：给程序分配了堆区的内存之后一直没有释放，还不断地继续分配内存，导致程序占用的堆区内存越来越多、系统的可用内存越来越少。
- 内存溢出（out of memory）：程序耗尽了系统的所有内存。此时程序可能被系统强制终止。
  - C程序在Windows上运行时，分配的是虚拟内存，理论上难以出现内存溢出的情况。
  - C++使用malloc或关键字new来分配堆中的内存，Java、C# 使用关键字new来分配堆中的内存。
  - Java的垃圾收集器会自动收走堆中不再使用的数据。

## 预防措施。
- 每次申请分配内存之后，检查是否分配成功，即检查返回的指针是否为NULL。
- 如果成功分配了内存，就用memset()初始化该内存。
  - 否则，如果之后读取这块内存，会读取到垃圾数据；如果往这块内存写入数据，只要没完全覆盖这块内存，就会留下一些垃圾数据。
- 使用指针时，检查指针是否正确。
  - 如果访问一个不存在的内存地址，程序可能会崩溃。
  - 如果访问一个存在的、意料之外的内存地址，会造成不可预知的后果。
- 访问一块内存时，检查是否会内存越界。

分配一块内存之后，在使用之后忘记释放。这会导致内存泄漏。
重复释放一块已经被释放的内存。这会导致内存访问越界，通常会使程序崩溃。

可以采用以下流程动态分配内存，提高代码的健壮性。
// 申请
char *p = malloc(10*sizeof(char));
if(str1)            // 动态分配内存之后应该先检查返回的指针是否有效
    return -1;
// 释放
if(p){
    free(p);
    p = NULL;
}
##
##
##
 
字符串
字符串的存储
## 存储单个字符串的方法：
- 创建char型一维数组，存储字符串。
char str[] = "Hello World!";
printf("%s\n", str);
// 显示：Hello World!
printf("len = %d\n",sizeof(str));
// 显示：len = 13
  - 存储字符串时，编译器会自动在字符串末尾加上一个空字符 \0 ，因此数组的实际存储长度 = 字符总数 + 1 。
  - 不能把一个字符串或一个字符数组直接赋值给另一个字符数组：
char str2[10];
str2 = "Hello";        // 错误，因为不能批量修改数组的元素
str2 = str;            // 错误，因为不能修改数组名的地址
- 创建char *型指针，指向字符串的地址。
char *pstr = "Hi";            // 让char *型指针指向字符串常量的地址
pstr = str;                    // 让char *型指针指向char型数组的地址
printf("%s\n", pstr);
// 显示：Hello World!
printf("%c\n", *pstr);        // 取消对字符指针的引用时，只能得到字符串的第一项元素（相当于str[0]）
// 显示：H
printf("%s\n", pstr + 1);        // 从字符串的指定位置开始显示，直到遇到末尾的空字符 \0
// 显示：ello World!
printf("%c\n", pstr);            // 以%c格式显示一个字符串
// 显示：▊
  - 不能取消char *型指针的引用，否则只能得到一个字符。
## 存储多个字符串的方法：
- 创建char型二维数组，数组第一维的每项元素可以存储一个字符串。
char strs[][10] = {"Hello", "World!"};
printf("%s\n", strs[0]);
// 显示：Hello
- 创建char *型指针数组，数组第一维的每项元素可以指向一个字符串的地址。
char *pstrs[] = {"Hi", "World!"};
pstrs[0] = strs[0];
printf("%s\n", pstrs[0]);
// 显示：Hello
- 创建char **型二级指针，指向char *型指针数组。
char **ppstr = pstrs;
printf("%s\n", *ppstr);            // *ppstr指向一个字符串
//显示：Hello
  - 不能用 char **ppstr = {"Hi", "World!"}; 或 char **ppstr = strs; 赋值，否则程序运行时会报错。
  - 例：
int n = 4, i = 0;
char **ppstr = malloc(sizeof(char *) * n);        // 分配n个char *型指针的内存，地址连续
*ppstr = NULL;
*(ppstr + 1) = "Hello";
*(ppstr + 2) = "World!";
*(ppstr + 3) = malloc(sizeof(char)*10);

for (i = 0; i < n; i++){
    printf("%s\n", *(ppstr + i));
}
##
##
##
 
字符串的类型转换
## 将十六进制数字转换成字符串。
- 通过计算ASCII码值把数字逐个转换成字符。
int x = rand() % 15;
char c;
if (x >= 0 && x <= 9)    //数字、大写字母（'A'=65）、小写字母三段的ASCII码并不是连续的，所以要分段处理
    c = '0' + x;
else if (x >= 10 && x <= 15)
    c = 'A' + x % 10;
else
    return -1;
- 用sprintf()函数将数字输出到指定字符串（会覆盖原字符串的内容）。
int x = rand() % 15;
char str1[10];
while (1)
{
    sprintf(str1, "color 0%x", x);
    system(str1);
    y = rand() % (999 - 100) + 100;
    printf("%d", y);
}
## 将字符串转换成数字。
- stdlib.h定义了将字符串转换成数字的函数atoi()、atol()、atof()。
- int atoi(const char *);            //将字符串转换成int型（ascii to int），默认返回值为0
  - 例如：
int x = atoi("3.14");            //x的值为 3
- long atol(const char *);            //将字符串转换成long型（ascii to long），默认返回值为0
- double atof(const char *);        //将字符串转换成double型（ascii to float），默认返回值为0.000000
  - 例如：
double d = atof("3.14");        //d的值为3.140000
##
##
##
 
<string.h>
## string.h提供了一些处理字符串的函数。
## 获取字符串的信息。
- size_t strlen(const char *);
// 返回字符串的长度（不包括末尾的空字符）
  - 例：
char *pstr = "Hello World!";
int len = strlen (pstr);        // len为12
- int strcmp(const char *, const char *);
// 逐个字符地比较两个字符串，如果所有字符都相同则返回0，否则返回非零。
- int strncmp(const char *, const char *, size_t n);
// 最多比较n个字符
  - 例：
int a = strcmp(pstr, "Hello");            // a为非零值
int b = strncmp(pstr, "Hello", 5);        // b为0
- char *strchr(const char *, int);
// 在字符串中查找指定字符（根据ASCII码），返回第一次找到的地址。如果没有找到则返回NULL。
- char *strstr(const char *, const char *);
// 在字符串中查找指定字符串，返回第一次找到的地址。如果没有找到则返回NULL。
  - 例：
char *p1 = strchr(pstr, 'W');
char *p2 = strstr(pstr, "World");        // 此时p2 == p1
## 拷贝字符串。
- char *strcpy(char *, const char *);
// 拷贝第二个字符串（包括空字符），覆盖第一个字符串的原有字符。函数执行成功后会返回目的字符串的地址。
  - 例：
char *pstr = malloc(10*sizeof(char));
strcpy(pstr, "Hello");        // 直接拷贝字符串常量
char str[] = "Hello";
strcpy(pstr, str);            // 根据地址拷贝字符串
  - 其源码为：
char *strcpy(char *dst, const char *src){
    char *r = dst;
    assert((dst != NULL) && (src != NULL));
    while (*r++ = *src++);    // 逐个字符地赋值，当赋值到最后空字符（ASCII码为0）时，结束while循环
    return dst;
}
- int strncpy(const char *dst, const char *src, size_t n);
// 拷贝n个字符（包括空字符在内）。
  - 如果strlen(str) + 1 < n，则strncpy()会将不足的位用空字符补齐。
  - 如果strlen(str) + 1 > n，则strncpy()会拷贝不到源字符串末尾的空字符，导致目的字符串变得危险。
  - 因此，要谨慎设置目的字符串的长度。如下：
int len = (strlen(str) + 1);
char *pstr = malloc(sizeof(char) * len);
strncpy(pstr, str, len);
- char *strcat(char *, const char *);
// 拷贝第二个字符串，放到第一个字符串的原有字符之后
- char *strncat(char *, const char *, size_t n);
// 拷贝n个字符
- void *memcpy(void *dst, const void *src, size_t n);
// 从内存src拷贝n个字节到内存dst中
- void *memset(void *src, int x, size_t n);
// 将内存src的前n个字节赋值为x
  - 创建一个用于存储字符串的数组或内存空间之后，它存储的是垃圾值，应该用memset初始化后再使用。例如：
char str[10];
memset(str, NULL, sizeof(str));
  - 函数memcpy()、memset()不止可以处理字符串，还可以处理其它类型的内存空间。
用strcpy()拷贝时，遇到空字符就会停止。而用memcpy()拷贝时，即使数据中包含空字符，也会固定拷贝n个字节。
##
##
##
 
ASCII码
## C语言按照ASCII码表处理每个字符的编码，总共有128种字符。
- 非打印字符：不能显示（或者显示时会乱码），用于控制排版、传输。
十进制值    名称
0    NULL（空字符）
1    SOH(标题开始)
2    STX（正文开始）
3    ETX（正文结束）
4    EOT（传输结束）
5    ENQ（请求）
6    ACK（确认）
7    BEL（响铃）
8    Backspace（退格）
9    HT（水平制表符）
10    LF（换行符）
11    VT（垂直制表符）
12    换页符
13    CR（回车符）

127    DEL（删除）
- 可打印字符：可以在文本阅读器中显示出来，用于表示文本信息。
32    space（空格）
33    !

48    0
57    9

65    A
90    Z

97    a
122    z
## 转义字符：一些以反斜杠 \ 开头的特殊字符。
- \' 表示单引号、\" 表示双引号、\n 表示换行符、\b表示退格、\t 表示输出八个空格、\\ 表示反斜杠。
- 特别地，百分号的转义字符是 %% 。
##
##
##
 
共用体
## 共用体：一个与结构体类似的数据类型。
- 用union关键字可以定义共用体。
  - 共用体的各个成员共用同一段内存空间，只能同时存储一个成员的值（即最后被赋值的那个成员，它会覆盖旧成员存储的值）。
  - 共用体变量以及其各个成员的内存地址是相同的。
  - 一个共用体变量所占内存空间等于其最大的一个成员所占的内存空间。
- 例子：
union Horse {            // 定义格式与结构体类似
    char name;
    int age;
};

union Horse h1;
h1.name = 'J';
h1.age = 10;                // 此时会覆盖h1的值
printf("%d\n", h1);        // 显示为10
  - 在初始化共用体变量时，只能同时给一个成员赋值：
union Horse h2 = {'J'};    // h2 = {'J', 10} 是语法错误
  - 可以在定义共用体的同时创建共用体变量：
union Horse {            // 定义格式与结构体类似
    char name;
    int age;
} h1;

##
##
##
 
枚举
## 枚举：列举出变量可能的各种取值。
- 例子：
enum Day{Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};
enum Day d1;
d1 = Sunday;                // 给枚举变量赋值
printf("%d\n", d1);        // 显示为6
d1 = 10;                    // 理论上只能给枚举变量赋值一个已有的枚举元素，但编译器不一定会报错
  - 这里Day是枚举类型名，d1是这种类型的枚举变量，Monday、Tuesday……是枚举元素。
  - 可以在定义枚举类型的同时创建枚举变量：
enum Day{Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday} d1;
- 枚举元素是一些符号常量，像宏定义。默认取值依次为0、1、2、3……。
  - 可以在定义枚举类型时设置枚举元素的值（可以为int型、char型）：
enum Day{Monday ='M', Tuesday='T', Wednesday, Thursday, Friday, Saturday, Sunday='S'};
  - 可以像普通常量一样使用枚举元素：
d1 = Monday;
if(d1 == Monday)
    printf("This is Monday.");
  - 枚举元素是符号常量，不能修改其值:
Sunday = 7;    // 错误
- 其它例子：
enum Bool{false=0,true=1};
enum Bool b1 = true;
##
##
##
 
函数
## 函数：被封装的一个语句块，可以被调用。
## 函数的定义。
int sum(int x, int y){
    return x + y;
}
- 第一行是函数头，它定义了函数返回值的类型、函数名、函数参数。
- 第一行之下的语句块称为函数体。
  - 不能在函数体内定义另一个函数。
  - 编译器会从上往下执行函数体中的每条语句，当执行完函数体之后就会结束函数。如果遇到return语句，就会提前结束函数。
- 关于return语句。
  - 当函数运行结束之后，在函数内定义局部变量都会被销毁。因此通常要用return语句返回一个值给外部，表示函数的运行结果。
  - return语句只能返回一个值，可以是任意的数据类型，但必须与函数头中定义的一致。
  - 函数体中可以写多条return语句，但编译器执行第一个遇到的return语句时就会结束函数，不会执行后面的。
  - 如果函数返回值的类型是void，则表示没有返回值，不能使用return语句，或者使用return ;。
- 除了return语句，函数还可以采用以下方法影响外部：
  - 修改全局变量
  - 获得外部变量的地址，通过指针来修改其值
## 函数的声明。
- 函数的声明语句用于声明函数原型，相当于以分号结尾的函数头。
- 可以在1.c中定义一个函数fun1()，并在1.h中声明该函数原型。然后在2.c中导入1.h，就同时导入了该函数的声明语句，从而可以调用该函数。
## 函数的调用。
- 如果在一个函数中调用另一个函数，则前者称为“主调函数”，后者称为“被调函数”。
  - 一般的函数都必须在定义语句或声明语句之后才能调用。
- 调用函数的一般步骤如下：
1.    检查函数是否在当前作用域中已定义或声明。
2.    通过函数名调用函数，可能还需要传入函数参数。
3.    接收函数的返回值。
- 如果定义函数时规定了函数参数，调用函数时就必须传入数量相同、数据类型相同的函数参数。
  - 定义、声明函数时写的函数参数称为形参，如下：
int sum(int x, int y);
int sum(int, int);            // 声明函数时，形参可以不写变量名，只写数据类型
  - 调用函数时写的函数参数称为实参，如下：
sum(1, 2);
printf("%d\n", fun1(fun1(2)));    // 可以把其它函数的返回值直接用作实参
- 调用函数时，时主调函数会将实参的值存储到一个副本，然后赋值给被调函数的形参变量，这个过程称为“按值传递”。
  - 因此，当被调函数修改形参的值时，并不会影响实参的值。除非实参是一个指针，然后被调函数修改该指针所指对象的值、。
## 特殊类型的函数。
- 指针函数：返回一个指针的函数。比如：int *psum(int, int);
- 变参函数：调用该函数时可以传入数量不定、类型不定的参数。比如printf()、scanf()。定义方法如下：
#include <stdarg.h>                        // 导入头文件stdarg.h

int print_int(int argc, ...)                // 定义函数时，形参只有一个参数，然后是省略号
{
    va_list ap;                            // 创建一个va_list类型的变量，用于存储变参列表
    va_start(ap, argc);                    // 初始化变参列表，存储argc个变参
    for (int i = 0; i < argc; i++)
        printf("%d\n", va_arg(ap, int));    // 读取下一个变参，其类型应该为int
    va_end(ap);                            // 销毁变参列表
    return 0;
}

print_int(3, 10, 20, 30);                    // 调用函数
##
##
##
 
预处理指令
## 预处理指令：在源代码的开头用井号 # 声明的命令，会在编译之前被执行。
- 它不是语句，末尾不需要加分号 ; 。
## 用`#include 头文件`的格式可以导入一个头文件（相当于拷贝其全部内容）。
- 如果头文件名用尖括号 < > 包住，则编译器会到系统默认目录（即环境变量PATH中包含的路径）下寻找该头文件。
#include <stdio.h>
- 如果头文件名用双引号 " " 包住，则编译器会先在当前目录下寻找该头文件，再到系统默认目录下寻找。
#include "myheader.h"
- 如果头文件名中包含了路径，则编译器只会到该路径下寻找头文件。
#include <C:\MinGW\include\windows.h>
- 当源文件数量较多时应该分类存放，比如将头文件、源文件分别放在include、src目录下，然后用makefile来编译。
## 用宏定义`#define 表达式1 表达式2`可以定义一个宏，会在编译之前进行文本替换。
- 例：
#define value(x,y) x*y       // 定义一个宏
result = value(m, n+1);      // 这行代码在编译之前会被替换成result = m*n + 1;
- 通常把宏名看作常量，全部大写。
##
##
##
 
宏定义
## 宏定义也可以使用类似if语句的条件编译。如下：
#if defined PI        // 如果PI已经被定义，则进行以下编译
#undef PI            // 取消PI的定义
#define PI 3
#endif

#if PI==3.14            // 两路选择结构
...
#else
...
#endif

#if !(defined PI && defined DEBUG)        // 多路选择结构
...
#elif
...
#else
...
#endif
## 宏定义可以在代码的任何位置出现，编译器会从上到下依次处理。即使宏定义放在一个不会被调用的函数中，也会被编译器处理。
## 使用宏替换可以进行一些简单的运算，比定义一个函数的开销小、更灵活，但是没有使用函数那么可靠。
- 使用宏替换时，要将输入参数和输出参数都用括号包住，以免因为遇到优先级混乱的运算符而出错。例如：
# define MAX(x, y) ((x) > (y) ? (x) : (y))
- 由于宏替换只进行简单的字符替换，可能因为输入参数的格式超出预料而出错。例如：
int x = 1, y = 2;
printf("max = %d\n", MAX(x++, y++));
//显示为：max = 3
- 在宏替换的输入参数前加上井号 # ，可以将该变量的标识符转换成字符串。例如：
# define SHOW(x) printf("This parameter is: "# x"\n")
    int i = 0;
    SHOW(i);
    //显示为：This parameter is: i
## 内置的宏。
- 编译器内置了一些宏，不需要包含头文件就能使用，如下。
    printf("in file %s, line %d\n", __FILE__, __LINE__);
    //显示为：in file d:\1\test_C\1.c, line 17
    printf("at %s, %s\n", __TIME__, __DATE__);
    //显示为：at 15:20:16, Jan 19 2019
  - __FILE__、__LINE__代表源文件的文件名（字符串型数据）、编译时所在行（int型数据）。
  - __TIME__、__DATE__代表编译时的时刻、日期。
##
##
##
 
头文件
## 头文件：扩展名为 .h ，用于保存一些预处理指令、变量或函数的声明语句。
- 头文件名不区分大小写，但通常都小写。
- 头文件中不能包含可执行语句，但是可以定义函数或变量。
- 头文件的最大作用是让一个源文件可以调用另一个源文件的函数或变量。
  - 例如，在源文件1.c中定义某个函数，把该函数的声明语句放到对应的头文件1.h中。然后在另一个源文件2.c中导入头文件1.h，就可以调用该函数。
## 一个头文件可能被某个源文件重复导入。例如，源文件A 导入了头文件B和头文件C，如果头文件B已经导入了头文件C，就会导致重复导入。因此，要用宏定义判断是否已经导入了该头文件，如下：
#ifndef _MYHEADER_H_
#define _MYHEADER_H_
...
#endif
- 宏名_MYHEADER_H_由头文件myheader.h转换而来。转换时将每个字母大写，将小数点转换成下划线，再在前、后加上一个下划线
##
##
##
 
C语言的标准库
## C语言的标准库里定义了一些基本的函数、常量、宏定义等，通过包含对应的头文件来调用。
- 在MinGW库中，所有头文件都导入了基本的<_mingw.h>。
## stddef.h：定义了一些变量类型和宏，其它标准库头文件通常都导入了这个头文件。
- 宏定义了一种数据类型size_t。
  - 在32位机上，size_t被定义为long unsigned int，占4个字节。
size_t t = 4;
printf("%d, %d\n", t, sizeof(t));        //显示为 4, 4
##
##
##
 
<stdio.h>
## stdio.h是标准输入输出库（standard input and output）。
- 定义了一种结构体FILE，主要用于存储文件流。
## 格式化输入/输出函数。
- int scanf(const char *, args...);
// 从stdin读取一个字符串，提取输入参数
- int printf(const char *, args...);
// 生成一个字符串，输出到stdout
- int sscanf(const char *buffer, const char *format, args...);
// 从buffer读取一个字符串，提取输入参数
- int sprintf(char *buffer, const char *format, args...);
// 生成一个字符串，写入buffer
// 如果函数执行成功，则返回生成的字符串长度（不包括末尾的空字符\0）；否则返回一个负数。
- int snprintf (char *buffer, size_t n, const char *, args...);
// 生成的字符串最大长度为n（包括末尾的空字符\0）
// 如果生成的字符串长度大于n，则只取前 n-1 个字符，然后加上一个空字符结尾，写入buffer。
// 如果函数执行成功，不管生成的字符串长度是否大于n，总是返回生成的字符串长度
  - 例：
char *buffer = malloc(sizeof(char) * 10);
int x = 1, len = 0;
len = snprintf(buffer, 10, "x=%d.0123456789\n", x);        // 结果len为15
## 非格式化输入/输出函数。
- int getchar(void);                // 从stdin读取一个字符
  - 例如：char c = getchar();
- int putchar(int);                    // 输出一个字符到stdin
  - 例如：putchar('\n');
- char *gets(char *);                // 从stdin读取一个字符串
- int puts(const char *);            // 输出一个字符串到stdout，并在末尾加上\n
## 错误处理。
- void perror(const char *str);        //输出一个字符串到标准错误stderr
  - 例如运行语句 perror("Error"); 会显示 Error: No error 。会自动在后面加上一个冒号和空格。
##
##
##
 
<stdlib.h>
## stdlib.h是标准函数库（standard library）。
## 随机数。
- int rand(void);                    //按预定的序列生成伪随机数，每次重新运行程序时得到的随机数是相同的
  - <stdlib.h>里宏定义了rand()返回的最大值为0x7FFF、最小值为0。
  - 例如：
x = rand()%(B-A)+A;            //生成A与B之间的伪随机数
- void srand(unsigned int);            //用于设置随机数的种子，使得rand()函数产生不同的随机数序列
  - 例如：
srand(time(0));
x = rand();
## 调用系统的API
- int system(const char *string);    //给DOS窗口发出一个命令（采用字符串的形式）
  - 例如：
system("pause");            //暂停运行，按下任意键继续
system("cls");            //清屏
system("color 0A");        //设置DOS窗口的颜色，取值为0~F，前一位0表示背景色，后一位A表示前景色
system("del D:\\1.txt");    //删除文件D:\1.txt（在字符串中输入 \ 要转义，所以是 \\）
system("dir");            //列出当前目录下的所有文件和文件夹列表
system("dir D:\");        //列出指定目录下的所有文件和文件夹列表
system("D:");            //进入D盘
system("cd D:\1");        //进入指定目录（cd代表change directory），cd只能在同一个盘符内移动
system("exit");            //退出DOS窗口
- void abort(void);                //使进程非正常终止
- void exit(int status);        //使进程正常终止，并向父进程返回一个状态值
##
##
##
 

 
<time.h>
## time.h提供了获取时间、日期的函数。如下：
#include <time.h>

time_t timep;
struct tm *ptime;
time(&timep);
ptime = localtime(&timep);        // 获取当前时间（本地时区）
printf("Year:  %d\n", 1900 + ptime->tm_year);
printf("Month:  %d\n", 1 + ptime->tm_mon);
printf("Day:  %d\n", ptime->tm_mday);
printf("Hour:  %d\n", ptime->tm_hour);
printf("Minute:  %d\n", ptime->tm_min);
printf("Second:  %d\n", ptime->tm_sec);
printf("Weekday:  %d\n", ptime->tm_wday);
##
##
##
 
<assert.h>
## assert.h提供了断言函数assert()，适用于打印调试信息。
- assert()被宏定义如下：
# undef assert
# ifdef NDEBUG
# define assert(x)    ((void)0)
# else
# define assert(e)    ((e) ? (void)0 : _assert(# e, __FILE__, __LINE__))
# endif
  - 当assert()的输入为假时，它会向stderr打印错误信息，并调用函数abort()来终止程序。当assert()的输入为真时，它不会起作用。
  - void _assert(const char *, const char *, int)会显示错误信息并调用abort()终止程序。
  - 在生产环境，可以宏定义NDEBUG，使assert()失效。（要保证该宏定义在头文件assert.h之前被编译）
- 例如，在以下语句中插入断言，
    int x = 0;
    while(1)
    {
        printf("%d", x++);
        assert(0 < x && x < 10);
    }
// 显示为：0123456789Assertion failed: 0 < x && x < 10, file d:\1\test_C\1.c, line 21
##
##
##
 
<math.h>
## math.h提供了一些数学函数。
## 三角函数。
- double sin(double);        // 参数为弧度值
- double cos(double);        // 参数为弧度值
- double tan(double);        // 参数为弧度值
## 反三角函数。
- double asin(double);
- double acos(double);
- double atan(double);
## 其它。
- double fabs(double);        // 返回x的绝对值
- double floor(double);        // 返回不大于x的最大整数
- double ceil(double);        // 返回不小于x的最小整数
##
##
##
 
第三方库
## windows.h：导入了很多Windows系统的头文件，提供了很多Windows系统的API。
- void Sleep(DWORD);        // 使进程暂停一定毫秒
-
##
## curl/curl.h：提供一些通过URL通信的函数。它来自libcurl库，支持http、https、ftp、telnet等协议。
## cJSON.h：提供一些用于构建、解析JSON格式的字符串的函数。
- JSON原本是JavaScript的对象表示格式，后来发展成为一种独立的、用于数据交换的文本格式，可用于多种编程语言。
## mosquitto.h：提供一些实现mqtt协议的函数。
- mosquitto是一款实现了mqtt协议的开源消息代理服务软件。
## hmac_sha256.h：提供一些实现哈希算法sha-256的函数。
##
## stdafx.h：VS2010中把stdio.h、stdlib.h、windows.h等头文件都包含到了stdafx.h（标准应用程序框架的扩展）中，所以编程时要调用stdafx.h，而且要用双引号的格式调用。stdafx.h属于预编译头文件，把一些经常调用的代码预先编译好了。
##
##
##
##
##
##
 
访问文件
## 访问文件的原理。
- 数据的输入、输出都称为流(stream)，例如一个文件和一个输入流关联时，就可以从这个文件读取数据。
  - 程序运行时会自动打开标准输入流stdin、标准输出流stdout、标准错误流stderr，它们默认映射到终端的输入、输出。
- 读、写文件的内容之前，要先调用fopen()函数打开文件，这会创建一个文件缓冲区（大小由编译器决定）。
  - 当处理完文件之后，要调用fclose()函数关闭文件，这会销毁文件缓冲区。
  - 如果没有关闭文件，程序就会一直占用该文件，导致该文件不能被改名或删除。
- 程序从文件中读取数据时，会先将数据暂存到文件缓冲区中，再加载到一块内存空间中。最后返回一个文件指针，指向这个内存空间的地址。
  - 程序写入数据到文件时，会先将内存空间中的数据暂存到文件缓冲区中，等缓冲区满了之后再写入文件。
  - 读取文件时，每读取一个字符文件指针就会后移一位，直到移动到文件末尾，读取到文件结束符EOF（宏定义为-1）。
  - 写入文件时，每写入一个字符文件指针就会后移一位。
- 文件模式。
  - "r"    ：只读模式。文件指针指向文件开头，如果文件不存在就报错。
  - "w"    ：只写模式。文件指针指向文件开头（因此写入时会覆盖原数据），如果文件不存在就创建它。
  - "a"    ：追加（只写）模式。文件指针指向文件末尾，如果文件不存在就报错。
  - "r+"    ：读写模式。如果文件不存在就报错。
  - "w+"    ：读写模式。如果文件不存在就创建它。
  - "a+"    ：读写模式。如果文件不存在就报错。
  - 以上模式都是以文本形式打开文件（属于字符流），加上 b 就会以二进制形式打开文件（属于二进制流）：
"rb"、"wb"、"ab"、"rb+"、"wb+"、"ab+"
## 导入头文件<stdio.h>之后可使用一些访问文件的函数。
- 例：
FILE *f = fopen("D://test_C//1.c", "r");    // 打开文件
if(f == NULL){
    printf("Failed to open the file.");
    return -1;
}

int c;
while (c != EOF){            // 判断文件是否结束，相当于while(!feof(f))
    c = fgetc(pfile);        // 从文件中读取一个字符
    putchar(c);
}

fclose(pfile);        // 关闭文件

- 使用fprintf()和fscanf()的例子：
FILE *f = 0;
char *filename = "D://test_C//1.c";
f = fopen(filename, "w");
int x = 1, y = 2;
fprintf(f, "%d%d", x, y);
fclose(f);                //关闭文件再换成读取模式打开，直接切换模式可能导致缓存区的数据丢失
f = fopen(filename, "r");
fscanf(f, "%d%d", &x, &y);
fclose(f);
##
##
##
 
<stdlib.h>
## 打开、关闭文件。
- FILE *fopen(const char *filename, const char *mode);    // 以指定模式打开文件
  - 函数运行成功后会返回一个FILE*类型的指针（称为文件指针），否则返回NULL。
  - 文件名可以是相对路径或绝对路径。
- int fclose(FILE *stream);            // 关闭文件
  - 函数运行成功后会返回0，否则返回EOF。
- int feof(FILE *stream);            // 判断文件是否结束
  - 如果上一次fread()等函数读取到的是EOF，或读取出错，feof()就返回非零值，否则返回0。
- long ftell(FILE *stream);            // 返回文件指针相对于文件开头的偏移量（单位为字节）
  - 函数运行成功后会返回一个带符号的long型值，否则返回-1L。
  - 例：
fseek(f, 10L, 0);
long site = ftell(f);
if(site == -1L)
    return -1;
- void rewind(FILE *);                // 将文件指针移动到文件开头
- int fseek(FILE *, long, int);        // 将文件指针移动一定距离（单位为字节）
  - 第二个参数表示偏移量，为带符号的long型值。
  - 第三个参数表示偏移的起点，可为0（表示文件开头）、1（表示当前位置）、2（表示文件末尾）。
- int ferror (FILE *);        // 检查上一次调用文件读、写函数是否出错，如果没出错就返回0，否则返回非零值
  - 用fopen()打开文件时，编译器会将文件错误标志初始化为0。
  - 程序每次调用文件读、写函数时，会将文件错误标志复位为0。如果出错，就将它置一。
- void clearerr (FILE *);    // 将文件错误标志、文件结束标志复位为0
## 读、写字符流。
- int fgetc(FILE *)                                // 从stream读取一个字符
  - 函数运行成功后会返回该字符，否则返回EOF。
- int fputc(int, FILE *);                        // 输出一个字符到stream
  - 函数运行成功后会返回该字符，否则返回EOF。
- char *fgets(char *p, int n, FILE *);            // 从stream读取一行字符串，保存到指针p中
  - fgets()会读取一连串字符，直到遇到换行符（会将这个换行符也读取），或EOF，或读取了n-1个字符。
  - 函数运行成功后会返回指针p，否则返回NULL。
- int fputs(const char *, FILE *);                // 输出一个字符串到stream
  - 函数运行成功后会返回0，否则返回非零值。
- int fscanf(FILE *stream, const char *, ...);            // 从stream读取输入
- int fprintf(FILE *stream, const char *format, ...);        // 输出字符串到stream
## 读写二进制流。
- int fread(void *p, int size, int count, FILE *f);
  - 从f中读取二进制数据，每次读取size字节，读取count次，保存到p中。
  - 函数运行成功后会返回count。
- int fwrite(const void *p, int size, int count, FILE *f);
  - 从p中读取二进制数据，写入到f中，每次写入size字节，写入count次。
  - 函数运行成功后会返回count。
## 管理文件。
- int remove(const char *filename);
- int rename(const char *old_filename, const char *new_filename);
##
##
##
 
读写二进制文件
## 以下例子是以二进制形式读写文件，而且是直接读写结构体类型的数据。
#define COUNT 10
// 构造数据
struct Horse
{
    char name[10];
    int age;
} list[COUNT];

// 写入
FILE *f = fopen("1.txt", "wb");
if (f == NULL)
{
    printf("Failed to open the file.");
    return -1;
}
for (i = 0; i < COUNT; i++)
{
    if (fwrite(&list[i], sizeof(struct Horse), 1, f) != 1)
    {
        printf("Error writing the file.");
        return -1;
    }
}
fclose(f);

// 读取
f = fopen("1.txt", "rb");
if (f == NULL)
{
    printf("Failed to open the file.");
    return -1;
}
for (i = 0; i < COUNT; i++)
{
    if (fread(&list[i], sizeof(struct Horse), 1, f) != 1)
    {
        printf("Error reading the file.");
        return -1;
    }
    printf("Name: %s, Age: %d\n", list[i].name, list[i].age);
}
fclose(f);

 
读取JSON文件
## 以下例子是读取JSON文件并解析。
- 主要逻辑：
  - 先计算文件的大小，然后创建一个相应大小的内存空间，再读取文件内容。
static char* read_json_file(const char* file)
{
  FILE* fp;
  char* file_stream = NULL;
  size_t file_len = 0;
  if (!file) {
    return NULL;
  }
  fp = fopen(file, "r");
  if (fp == NULL) {
    TRACE_ERROR("Failed to open the file.");
    return NULL;
  }

  /*seek to end*/
  fseek(fp, 0, SEEK_END);

  /*Get file length*/
  file_len = ftell(fp);

  /*seek to head*/
  fseek(fp, 0, SEEK_SET);

  file_stream = (char*)malloc(sizeof(char)*(file_len + 1));
  if (file_stream != NULL) {
    memset(file_stream, 0, sizeof(char)*(file_len + 1));
    fread(file_stream, sizeof(char), file_len, fp);
  }
  fclose(fp);
  return file_stream;
}

int get_device_config(char* pid, char* did, char* secret, char* url)
{
  cJSON* config_json = NULL;
  char* json_string = NULL;

  json_string = read_json_file(DEVICE_CONFIG_FILE);
  if (NULL == json_string) {
    return -1;
  }
  config_json = cJSON_Parse(json_string);

  if (NULL != config_json) {
    if ((NULL
         != cJSON_GetObjectItem(config_json,
                                "pid"))
        && (NULL
            != cJSON_GetObjectItem(config_json,
                                   "did"))
        && (NULL
            != cJSON_GetObjectItem(config_json,
                                   "secret"))
        && (NULL != cJSON_GetObjectItem(config_json, "url"))) {
      strncpy(pid,
              cJSON_GetObjectItem(config_json, "pid")->valuestring,
              CONFIG_LEN);
      strncpy(did,
              cJSON_GetObjectItem(config_json, "did")->valuestring,
              CONFIG_LEN);
      strncpy(secret,
              cJSON_GetObjectItem(config_json, "secret")->valuestring,
              CONFIG_LEN);
      strncpy(url,
              cJSON_GetObjectItem(config_json, "url")->valuestring,
              CONFIG_LEN);
      cJSON_Delete(config_json);
      free(json_string);
      json_string = NULL;
      return 0;
    }
    cJSON_Delete(config_json);
    free(json_string);
    json_string = NULL;
  }

  return -1;
}

##
##
##
 
多线程
## C语言的线程库。
- 在Linux系统上，可使用pthread.h的API创建线程。比如pthread_create()。
  - pthread.h符合POSIX标准，适用于类Unix系统。也有兼容Windows的版本——pthreads-w32。
  - 编译时要链接pthread库，比如：gcc test.c -o test -l pthread
- 在Windows系统上，可使用windows.h的API创建线程。比如CreateProcess()。
- C11制定了一个标准的线程库threads.h，但部分编译器不支持它。
##
##
##
 
<pthread.h>
## pthread.h的常用函数。（API列表：https://www.sourceware.org/pthreads-win32/manual/index.html）
- pthread_t                // 一种数据类型，用于存储线程ID
- pthread_attr_t            // 一种数据类型，用于存储线程属性
- int pthread_create(pthread_t *id,                // 传入一个pthread_t类型的变量的地址
const pthread_attr_t * attr,    // 传入线程的属性（传入NULL则是默认属性）
void *(*) (void *),            // 传入要运行的函数名
void *arg);        // 传入要运行的函数的参数（没有参数则填NULL，有多个则封装成一个结构体）
  - 功能：创建一个线程来运行一个函数。
  - 线程创建成功后会将该线程的ID存储到变量id中，并返回0。线程创建失败时会返回非零值。
  - 要运行的函数应该定义成 void *fun(void *arg) 的格式。
- void pthread_exit(void *retval);
  - 功能：终止当前线程。retval用于存储当前线程的返回值，可在其它线程中查看该变量的值。
  - 当一个线程的代码运行结束时，该线程就会自动终止。也可以调用一些函数来主动结束线程。
- int pthread_cancel(pthread_t id);
  - 功能：向某个线程发送取消请求。
  - 目标线程可能立即终止，也可能稍后终止，也可能忽略取消请求。
- int pthread_join(pthread_t id, void **retval);
  - 功能：暂停当前线程的运行，等待id所指的线程终止。当它终止之后，其返回值会存储在retval变量中。
-
## 例：
#include <stdio.h>
#include <pthread.h>

void *fun1(){
    puts("fun1() end.");
    return 0;
}

typedef struct{
    int age;
    char name[10];
} Horse;

void *fun2(void *p){
    Horse h = *(Horse *)p;
    printf("age: %d, name: %s.\n", h.age, h.name);
    puts("fun2() end.");
    return 0;
}

int main(){
    int rc;
    pthread_t id;

    // 创建第一个线程
    rc = pthread_create(&id, NULL, fun1, NULL);
    if (rc)
        puts("Failed to create the thread fun1().");

    // 创建第二个线程
    Horse horse = {5, "Jack"};
    rc = pthread_create(&id, NULL, fun2, &horse);
    if (rc)
        puts("Failed to create the thread fun2().");

    // 阻塞主线程的运行，以免提前终止子线程
    pthread_join(id, NULL);
    puts("main() end.");
    return 0;
}
##
##
##
 
:::