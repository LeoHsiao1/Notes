::: v-pre





 

##
##
##
 
<assert.h>
- assert.h提供了断言函数assert()，适用于打印调试信息。
- assert()被宏定义如下：
# undef assert
# ifdef NDEBUG
# define assert(x)    ((void)0)
# else
# define assert(e)    ((e) ? (void)0 : _assert(# e, __FILE__, __LINE__))
# endif
  - 当assert()的输入为假时，它会向stderr打印错误信息，并调用函数abort()来终止程序。当assert()的输入为真时，它不会起作用。
  - void _assert(const char *, const char *, int)会显示错误信息并调用abort()终止程序。
  - 在生产环境，可以宏定义NDEBUG，使assert()失效。（要保证该宏定义在头文件assert.h之前被编译）
- 例如，在以下语句中插入断言，
    int x = 0;
    while(1)
    {
        printf("%d", x++);
        assert(0 < x && x < 10);
    }
// 显示为：0123456789Assertion failed: 0 < x && x < 10, file d:\1\test_C\1.c, line 21
##
##
##
 
<math.h>
- math.h提供了一些数学函数。
- 三角函数。
- double sin(double);        // 参数为弧度值
- double cos(double);        // 参数为弧度值
- double tan(double);        // 参数为弧度值
- 反三角函数。
- double asin(double);
- double acos(double);
- double atan(double);
- 其它。
- double fabs(double);        // 返回x的绝对值
- double floor(double);        // 返回不大于x的最大整数
- double ceil(double);        // 返回不小于x的最小整数
##
##
##
 

##
##
##
##
##
##
 
访问文件
- 访问文件的原理。
- 数据的输入、输出都称为流(stream)，例如一个文件和一个输入流关联时，就可以从这个文件读取数据。
  - 程序运行时会自动打开标准输入流stdin、标准输出流stdout、标准错误流stderr，它们默认映射到终端的输入、输出。
- 读、写文件的内容之前，要先调用fopen()函数打开文件，这会创建一个文件缓冲区（大小由编译器决定）。
  - 当处理完文件之后，要调用fclose()函数关闭文件，这会销毁文件缓冲区。
  - 如果没有关闭文件，程序就会一直占用该文件，导致该文件不能被改名或删除。
- 程序从文件中读取数据时，会先将数据暂存到文件缓冲区中，再加载到一块内存空间中。最后返回一个文件指针，指向这个内存空间的地址。
  - 程序写入数据到文件时，会先将内存空间中的数据暂存到文件缓冲区中，等缓冲区满了之后再写入文件。
  - 读取文件时，每读取一个字符文件指针就会后移一位，直到移动到文件末尾，读取到文件结束符EOF（宏定义为-1）。
  - 写入文件时，每写入一个字符文件指针就会后移一位。
- 文件模式。
  - "r"    ：只读模式。文件指针指向文件开头，如果文件不存在就报错。
  - "w"    ：只写模式。文件指针指向文件开头（因此写入时会覆盖原数据），如果文件不存在就创建它。
  - "a"    ：追加（只写）模式。文件指针指向文件末尾，如果文件不存在就报错。
  - "r+"    ：读写模式。如果文件不存在就报错。
  - "w+"    ：读写模式。如果文件不存在就创建它。
  - "a+"    ：读写模式。如果文件不存在就报错。
  - 以上模式都是以文本形式打开文件（属于字符流），加上 b 就会以二进制形式打开文件（属于二进制流）：
"rb"、"wb"、"ab"、"rb+"、"wb+"、"ab+"
- 导入头文件<stdio.h>之后可使用一些访问文件的函数。
- 例：
FILE *f = fopen("D://test_C//1.c", "r");    // 打开文件
if(f == NULL){
    printf("Failed to open the file.");
    return -1;
}

int c;
while (c != EOF){            // 判断文件是否结束，相当于while(!feof(f))
    c = fgetc(pfile);        // 从文件中读取一个字符
    putchar(c);
}

fclose(pfile);        // 关闭文件

- 使用fprintf()和fscanf()的例子：
FILE *f = 0;
char *filename = "D://test_C//1.c";
f = fopen(filename, "w");
int x = 1, y = 2;
fprintf(f, "%d%d", x, y);
fclose(f);                //关闭文件再换成读取模式打开，直接切换模式可能导致缓存区的数据丢失
f = fopen(filename, "r");
fscanf(f, "%d%d", &x, &y);
fclose(f);
##
##
##
 
<stdlib.h>
- 打开、关闭文件。
- FILE *fopen(const char *filename, const char *mode);    // 以指定模式打开文件
  - 函数运行成功后会返回一个FILE*类型的指针（称为文件指针），否则返回NULL。
  - 文件名可以是相对路径或绝对路径。
- int fclose(FILE *stream);            // 关闭文件
  - 函数运行成功后会返回0，否则返回EOF。
- int feof(FILE *stream);            // 判断文件是否结束
  - 如果上一次fread()等函数读取到的是EOF，或读取出错，feof()就返回非零值，否则返回0。
- long ftell(FILE *stream);            // 返回文件指针相对于文件开头的偏移量（单位为字节）
  - 函数运行成功后会返回一个带符号的long型值，否则返回-1L。
  - 例：
fseek(f, 10L, 0);
long site = ftell(f);
if(site == -1L)
    return -1;
- void rewind(FILE *);                // 将文件指针移动到文件开头
- int fseek(FILE *, long, int);        // 将文件指针移动一定距离（单位为字节）
  - 第二个参数表示偏移量，为带符号的long型值。
  - 第三个参数表示偏移的起点，可为0（表示文件开头）、1（表示当前位置）、2（表示文件末尾）。
- int ferror (FILE *);        // 检查上一次调用文件读、写函数是否出错，如果没出错就返回0，否则返回非零值
  - 用fopen()打开文件时，编译器会将文件错误标志初始化为0。
  - 程序每次调用文件读、写函数时，会将文件错误标志复位为0。如果出错，就将它置一。
- void clearerr (FILE *);    // 将文件错误标志、文件结束标志复位为0
- 读、写字符流。
- int fgetc(FILE *)                                // 从stream读取一个字符
  - 函数运行成功后会返回该字符，否则返回EOF。
- int fputc(int, FILE *);                        // 输出一个字符到stream
  - 函数运行成功后会返回该字符，否则返回EOF。
- char *fgets(char *p, int n, FILE *);            // 从stream读取一行字符串，保存到指针p中
  - fgets()会读取一连串字符，直到遇到换行符（会将这个换行符也读取），或EOF，或读取了n-1个字符。
  - 函数运行成功后会返回指针p，否则返回NULL。
- int fputs(const char *, FILE *);                // 输出一个字符串到stream
  - 函数运行成功后会返回0，否则返回非零值。
- int fscanf(FILE *stream, const char *, ...);            // 从stream读取输入
- int fprintf(FILE *stream, const char *format, ...);        // 输出字符串到stream
- 读写二进制流。
- int fread(void *p, int size, int count, FILE *f);
  - 从f中读取二进制数据，每次读取size字节，读取count次，保存到p中。
  - 函数运行成功后会返回count。
- int fwrite(const void *p, int size, int count, FILE *f);
  - 从p中读取二进制数据，写入到f中，每次写入size字节，写入count次。
  - 函数运行成功后会返回count。
- 管理文件。
- int remove(const char *filename);
- int rename(const char *old_filename, const char *new_filename);
##
##
##
 
读写二进制文件
- 以下例子是以二进制形式读写文件，而且是直接读写结构体类型的数据。
#define COUNT 10
// 构造数据
struct Horse
{
    char name[10];
    int age;
} list[COUNT];

// 写入
FILE *f = fopen("1.txt", "wb");
if (f == NULL)
{
    printf("Failed to open the file.");
    return -1;
}
for (i = 0; i < COUNT; i++)
{
    if (fwrite(&list[i], sizeof(struct Horse), 1, f) != 1)
    {
        printf("Error writing the file.");
        return -1;
    }
}
fclose(f);

// 读取
f = fopen("1.txt", "rb");
if (f == NULL)
{
    printf("Failed to open the file.");
    return -1;
}
for (i = 0; i < COUNT; i++)
{
    if (fread(&list[i], sizeof(struct Horse), 1, f) != 1)
    {
        printf("Error reading the file.");
        return -1;
    }
    printf("Name: %s, Age: %d\n", list[i].name, list[i].age);
}
fclose(f);

 
读取JSON文件
- 以下例子是读取JSON文件并解析。
- 主要逻辑：
  - 先计算文件的大小，然后创建一个相应大小的内存空间，再读取文件内容。
static char* read_json_file(const char* file)
{
  FILE* fp;
  char* file_stream = NULL;
  size_t file_len = 0;
  if (!file) {
    return NULL;
  }
  fp = fopen(file, "r");
  if (fp == NULL) {
    TRACE_ERROR("Failed to open the file.");
    return NULL;
  }

  /*seek to end*/
  fseek(fp, 0, SEEK_END);

  /*Get file length*/
  file_len = ftell(fp);

  /*seek to head*/
  fseek(fp, 0, SEEK_SET);

  file_stream = (char*)malloc(sizeof(char)*(file_len + 1));
  if (file_stream != NULL) {
    memset(file_stream, 0, sizeof(char)*(file_len + 1));
    fread(file_stream, sizeof(char), file_len, fp);
  }
  fclose(fp);
  return file_stream;
}

int get_device_config(char* pid, char* did, char* secret, char* url)
{
  cJSON* config_json = NULL;
  char* json_string = NULL;

  json_string = read_json_file(DEVICE_CONFIG_FILE);
  if (NULL == json_string) {
    return -1;
  }
  config_json = cJSON_Parse(json_string);

  if (NULL != config_json) {
    if ((NULL
         != cJSON_GetObjectItem(config_json,
                                "pid"))
        && (NULL
            != cJSON_GetObjectItem(config_json,
                                   "did"))
        && (NULL
            != cJSON_GetObjectItem(config_json,
                                   "secret"))
        && (NULL != cJSON_GetObjectItem(config_json, "url"))) {
      strncpy(pid,
              cJSON_GetObjectItem(config_json, "pid")->valuestring,
              CONFIG_LEN);
      strncpy(did,
              cJSON_GetObjectItem(config_json, "did")->valuestring,
              CONFIG_LEN);
      strncpy(secret,
              cJSON_GetObjectItem(config_json, "secret")->valuestring,
              CONFIG_LEN);
      strncpy(url,
              cJSON_GetObjectItem(config_json, "url")->valuestring,
              CONFIG_LEN);
      cJSON_Delete(config_json);
      free(json_string);
      json_string = NULL;
      return 0;
    }
    cJSON_Delete(config_json);
    free(json_string);
    json_string = NULL;
  }

  return -1;
}

##
##
##
 
多线程
- C语言的线程库。
- 在Linux系统上，可使用pthread.h的API创建线程。比如pthread_create()。
  - pthread.h符合POSIX标准，适用于类Unix系统。也有兼容Windows的版本——pthreads-w32。
  - 编译时要链接pthread库，比如：gcc test.c -o test -l pthread
- 在Windows系统上，可使用windows.h的API创建线程。比如CreateProcess()。
- C11制定了一个标准的线程库threads.h，但部分编译器不支持它。
##
##
##
 
<pthread.h>
- pthread.h的常用函数。（API列表：https://www.sourceware.org/pthreads-win32/manual/index.html）
- pthread_t                // 一种数据类型，用于存储线程ID
- pthread_attr_t            // 一种数据类型，用于存储线程属性
- int pthread_create(pthread_t *id,                // 传入一个pthread_t类型的变量的地址
const pthread_attr_t * attr,    // 传入线程的属性（传入NULL则是默认属性）
void *(*) (void *),            // 传入要运行的函数名
void *arg);        // 传入要运行的函数的参数（没有参数则填NULL，有多个则封装成一个结构体）
  - 功能：创建一个线程来运行一个函数。
  - 线程创建成功后会将该线程的ID存储到变量id中，并返回0。线程创建失败时会返回非零值。
  - 要运行的函数应该定义成 void *fun(void *arg) 的格式。
- void pthread_exit(void *retval);
  - 功能：终止当前线程。retval用于存储当前线程的返回值，可在其它线程中查看该变量的值。
  - 当一个线程的代码运行结束时，该线程就会自动终止。也可以调用一些函数来主动结束线程。
- int pthread_cancel(pthread_t id);
  - 功能：向某个线程发送取消请求。
  - 目标线程可能立即终止，也可能稍后终止，也可能忽略取消请求。
- int pthread_join(pthread_t id, void **retval);
  - 功能：暂停当前线程的运行，等待id所指的线程终止。当它终止之后，其返回值会存储在retval变量中。
-
- 例：
#include <stdio.h>
#include <pthread.h>

void *fun1(){
    puts("fun1() end.");
    return 0;
}

typedef struct{
    int age;
    char name[10];
} Horse;

void *fun2(void *p){
    Horse h = *(Horse *)p;
    printf("age: %d, name: %s.\n", h.age, h.name);
    puts("fun2() end.");
    return 0;
}

int main(){
    int rc;
    pthread_t id;

    // 创建第一个线程
    rc = pthread_create(&id, NULL, fun1, NULL);
    if (rc)
        puts("Failed to create the thread fun1().");

    // 创建第二个线程
    Horse horse = {5, "Jack"};
    rc = pthread_create(&id, NULL, fun2, &horse);
    if (rc)
        puts("Failed to create the thread fun2().");

    // 阻塞主线程的运行，以免提前终止子线程
    pthread_join(id, NULL);
    puts("main() end.");
    return 0;
}
##
##
##
 
:::