::: v-pre



## stdlib.h

- 动态分配内存。
- void *malloc(size_t size);
  - 请求分配一块内存空间，大小为size字节。如果请求成功则返回一个指向该内存地址的void *指针，否则返回NULL。
  - 例如：
char *str1 = malloc(10*sizeof(char));
if(str1 == NULL)            // 动态分配内存之后应该先检查返回的指针是否有效
    return -1;            // windows存在虚拟内存机制，因此一般不会无内存可分配
printf("%s\n", str1);        // 显示为乱码，因为该内存空间存储着垃圾数据
strcpy(str1, "Hello");
printf("%s\n", str1);        // 显示为：Hello
free(str1);                // 使用完之后应该及时释放这块内存空间
  - malloc()返回的指针类型是void *，但是不必转换其数据类型，因为：
1. void *指针在赋值时会自动转换指针的数据类型。
2. C语言中，如果编译器调用一个函数时没有找到它的声明，则会自动进行隐式声明（implicit declaration），使其返回值为int型。因此如果忘了导入头文件stdlib.h，malloc()函数的返回值会是int型，不能给指针类型的变量赋值，编译时就会及时报错。
  - 如下，C++中使用malloc()函数时需要进行强制类型转换，否则会报错：无法从 void * 类型转换成 char *类型。
char *str1 = (char *)malloc(10*sizeof(char));
- void *calloc(size_t num, size_t size);
  - 请求分配一块内存空间，大小为num*size字节，并将其初始化为0。如果请求成功则返回一个指向该内存地址的void *指针，否则返回NULL。
  - 例如：
char *str1 = calloc(10, sizeof(char));        // 相当于malloc(10*sizeof(char))
if(str1 == NULL)
    return -1;
printf("%s\n", str1);        // 显示为空
strcpy(str1, "Hello");
printf("%s\n", str1);        // 显示为： Hello
free(str1);
- void *realloc(void *p, size_t size);
  - p指向一个用malloc()或calloc()分配的内存空间，请求改变其大小为size字节。如果请求成功则返回原指针p，否则返回NULL。
  - 如果p为空指针，则realloc()会创建一个size字节的内存空间。
  - 例如：
char *str1 = malloc(10*sizeof(char));
char *rc = realloc(str1, 20);
if(rc == NULL)
    return -1;
- void free(void *);            // 释放动态分配的内存空间
  - 应该及时释放不用的内存，以免程序占用越来越多的内存，导致内存泄露（memory leaks），使得系统变得卡顿甚至使程序奔溃。


C程序启动时，会向操作系统申请一定大小的内存空间。然后将该内存空间划分成几个区域：
- 堆区（heap）：动态存储区
  - 堆区内存由程序员主动分配、释放（通过执行malloc、free等函数），如果没有释放则会一直保留，当程序终止时会被系统自动释放。
  - 存储结构类似于数据结构中的链表，而不是堆。
- 栈区（stack）：局部变量区
  - 栈区的内存由系统在运行程序时自动按需分配、释放。
  - 存储结构类似于数据结构中的栈。
- 静态变量区（static）
  - 全局变量也是采用静态存储方式，存储在这里
- 常量区 ：存放常量字符串。
- 代码区 ：存放二进制代码。


- C语言编译器给程序分配内存时有两种方式：
- 静态的内存分配方式：在程序编译时就分配好内存空间，此后一直不变，直到程序终止才释放。
  - 比如函数、数组、全局变量、静态变量。
- 动态的内存分配方式：当程序需要用到时才分配分配、释放内存空间。
  - 比如局部变量、动态分配的内存。
- 常见的内存问题。

- 访问无效的内存地址：可能导致程序崩溃。比如访问已经被销毁的内存地址。
- 内存越界访问
  - ：访问一个对象时，使用了不合理的内存地址，超出该对象的内存地址范围。
  - 例如：程序用 malloc() 申请一块 2 bytes 的内存空间，得到一个指针。然后往该指针指向的内存地址，写入 3 bytes 的数据。此时第 3 个 byte ，就写到了当前内存的地址范围之外。
  - 为什么程序会发生内存越界访问？通常是因为编程时没有检查写入值的长度。例如：
    - 申请一块内存空间，准备写入一个字符串。但使用 strcpy、strcat、sprintf、gets() 等函数，没有限制字符串的长度，因此字符串可能超出预期长度，导致内存越界访问。建议换成 strncpy、strncat、snprintf 等函数。
  - 根据访问方式，分为两种情况：
    - 读越界：可能读取到错误的数据，导致程序出错，甚至崩溃。
    - 写越界：可能修改其它变量使用的内存空间，导致程序出错，甚至崩溃。
  - Linux 内核会为每个进程维护一个页表，记录该进程申请使用了哪些堆内存地址。当进程访问一个内存地址时，
    - 如果该内存地址包含于当前页表中，则说明已分配给该进程。因此内核会允许该进程访问，不管是否越界。这可能产生几种越界情况：
      - 该内存地址正在被当前进程的其它变量使用。
      - 该内存地址未被当前进程使用，但以后可能被使用。
    - 如果该内存地址不在当前页表中，则说明未分配给该进程。因此内核会拒绝该进程访问，发出 segment fault 信号，导致进程崩溃。
  - 除了堆内存，如果进程越界访问内核内存空间、只读存储区、代码段，Linux 内核也会拒绝该进程访问，发出 segment fault 信号，导致进程崩溃。

- 栈溢出（stack overflow）
  - ：在栈区发生的内存越界访问。
  - 程序运行时，会将所有函数参数、局部变量存储在内存的栈区。对这些变量的访问可能越界，例如：
    - 读写数组时下标越界。这可能会读写隔壁变量的内存空间。
      恶意用户可利用程序的栈溢出漏洞，修改程序中某些重要的变量。该操作称为栈溢出攻击。
    - 创建太大的数组，超出栈区的容量，导致程序崩溃。
    - 每次调用一个函数，都会在栈区分配一块内存来存储函数参数、局部变量，当函数执行完毕时才释放内存。如果一个函数调用另一个函数，如此嵌套，调用层数太深，则占用内存可能超出栈区的容量，导致程序崩溃。

- 缓冲区溢出攻击（Buffer Overflow Attack）
  - ：一种攻击方式。通常是程序的开发者，将程序交给其他人使用，但有人故意引发内存越界访问，从而控制该程序执行不合理的操作。
  - 原理：攻击者向程序的一个变量（通常用作缓冲区，允许用户修改）中，故意写入过长的数据，超出该变量的内存地址范围，写入到了该变量隔壁的内存地址，从而修改隔壁的数据（比如变量、函数返回地址）。
  - 栈溢出攻击：缓冲区溢出攻击的一种形式，在栈区发生。


- 内存泄漏（memory leak）：给程序分配了堆区的内存之后一直没有释放，还不断地继续分配内存，导致程序占用的堆区内存越来越多、系统的可用内存越来越少。
- 内存溢出（out of memory）：程序耗尽了系统的所有内存。此时程序可能被系统强制终止。
  - C程序在Windows上运行时，分配的是虚拟内存，理论上难以出现内存溢出的情况。
  - C++使用malloc或关键字new来分配堆中的内存，Java、C# 使用关键字new来分配堆中的内存。
  - Java的垃圾收集器会自动收走堆中不再使用的数据。

- 预防措施。
- 每次申请分配内存之后，检查是否分配成功，即检查返回的指针是否为NULL。
- 如果成功分配了内存，就用memset()初始化该内存。
  - 否则，如果之后读取这块内存，会读取到垃圾数据；如果往这块内存写入数据，只要没完全覆盖这块内存，就会留下一些垃圾数据。
- 使用指针时，检查指针是否正确。
  - 如果访问一个不存在的内存地址，程序可能会崩溃。
  - 如果访问一个存在的、意料之外的内存地址，会造成不可预知的后果。
- 访问一块内存时，检查是否会内存越界。

分配一块内存之后，在使用之后忘记释放。这会导致内存泄漏。
重复释放一块已经被释放的内存。这会导致内存访问越界，通常会使程序崩溃。

可以采用以下流程动态分配内存，提高代码的健壮性。
// 申请
char *p = malloc(10*sizeof(char));
if(str1)            // 动态分配内存之后应该先检查返回的指针是否有效
    return -1;
// 释放
if(p){
    free(p);
    p = NULL;
}
##
##
##
 
字符串
字符串的存储
- 存储单个字符串的方法：
- 创建char型一维数组，存储字符串。
char str[] = "Hello World!";
printf("%s\n", str);
// 显示：Hello World!
printf("len = %d\n",sizeof(str));
// 显示：len = 13
  - 存储字符串时，编译器会自动在字符串末尾加上一个空字符 \0 ，因此数组的实际存储长度 = 字符总数 + 1 。
  - 不能把一个字符串或一个字符数组，直接赋值给另一个字符数组：
char str2[10];
str2 = "Hello";        // 错误，因为不能批量修改数组的元素
str2 = str;            // 错误，因为不能修改数组名的地址
- 创建char *型指针，指向字符串的地址。
char *pstr = "Hi";            // 让char *型指针指向字符串常量的地址
pstr = str;                    // 让char *型指针指向char型数组的地址
printf("%s\n", pstr);
// 显示：Hello World!
printf("%c\n", *pstr);        // 取消对字符指针的引用时，只能得到字符串的第一项元素（相当于str[0]）
// 显示：H
printf("%s\n", pstr + 1);        // 从字符串的指定位置开始显示，直到遇到末尾的空字符 \0
// 显示：ello World!
printf("%c\n", pstr);            // 以%c格式显示一个字符串
// 显示：▊
  - 不能取消char *型指针的引用，否则只能得到一个字符。
- 存储多个字符串的方法：
- 创建char型二维数组，数组第一维的每项元素可以存储一个字符串。
char strs[][10] = {"Hello", "World!"};
printf("%s\n", strs[0]);
// 显示：Hello
- 创建char *型指针数组，数组第一维的每项元素可以指向一个字符串的地址。
char *pstrs[] = {"Hi", "World!"};
pstrs[0] = strs[0];
printf("%s\n", pstrs[0]);
// 显示：Hello
- 创建char **型二级指针，指向char *型指针数组。
char **ppstr = pstrs;
printf("%s\n", *ppstr);            // *ppstr指向一个字符串
//显示：Hello
  - 不能用 char **ppstr = {"Hi", "World!"}; 或 char **ppstr = strs; 赋值，否则程序运行时会报错。
  - 例：
int n = 4, i = 0;
char **ppstr = malloc(sizeof(char *) * n);        // 分配n个char *型指针的内存，地址连续
*ppstr = NULL;
*(ppstr + 1) = "Hello";
*(ppstr + 2) = "World!";
*(ppstr + 3) = malloc(sizeof(char)*10);

for (i = 0; i < n; i++){
    printf("%s\n", *(ppstr + i));
}
##
##
##
 
字符串的类型转换
- 将十六进制数字转换成字符串。
- 通过计算ASCII码值把数字逐个转换成字符。
int x = rand() % 15;
char c;
if (x >= 0 && x <= 9)    //数字、大写字母（'A'=65）、小写字母三段的ASCII码并不是连续的，所以要分段处理
    c = '0' + x;
else if (x >= 10 && x <= 15)
    c = 'A' + x % 10;
else
    return -1;
- 用sprintf()函数将数字输出到指定字符串（会覆盖原字符串的内容）。
int x = rand() % 15;
char str1[10];
while (1)
{
    sprintf(str1, "color 0%x", x);
    system(str1);
    y = rand() % (999 - 100) + 100;
    printf("%d", y);
}
- 将字符串转换成数字。
- stdlib.h定义了将字符串转换成数字的函数atoi()、atol()、atof()。
- int atoi(const char *);            //将字符串转换成int型（ascii to int），默认返回值为0
  - 例如：
int x = atoi("3.14");            //x的值为 3
- long atol(const char *);            //将字符串转换成long型（ascii to long），默认返回值为0
- double atof(const char *);        //将字符串转换成double型（ascii to float），默认返回值为0.000000
  - 例如：
double d = atof("3.14");        //d的值为3.140000
##
##
##
 
<string.h>
- string.h提供了一些处理字符串的函数。
- 获取字符串的信息。
- size_t strlen(const char *);
// 返回字符串的长度（不包括末尾的空字符）
  - 例：
char *pstr = "Hello World!";
int len = strlen (pstr);        // len为12
- int strcmp(const char *, const char *);
// 逐个字符地比较两个字符串，如果所有字符都相同则返回0，否则返回非零。
- int strncmp(const char *, const char *, size_t n);
// 最多比较n个字符
  - 例：
int a = strcmp(pstr, "Hello");            // a为非零值
int b = strncmp(pstr, "Hello", 5);        // b为0
- char *strchr(const char *, int);
// 在字符串中查找指定字符（根据ASCII码），返回第一次找到的地址。如果没有找到则返回NULL。
- char *strstr(const char *, const char *);
// 在字符串中查找指定字符串，返回第一次找到的地址。如果没有找到则返回NULL。
  - 例：
char *p1 = strchr(pstr, 'W');
char *p2 = strstr(pstr, "World");        // 此时p2 == p1
- 拷贝字符串。
- char *strcpy(char *, const char *);
// 拷贝第二个字符串（包括空字符），覆盖第一个字符串的原有字符。函数执行成功后会返回目的字符串的地址。
  - 例：
char *pstr = malloc(10*sizeof(char));
strcpy(pstr, "Hello");        // 直接拷贝字符串常量
char str[] = "Hello";
strcpy(pstr, str);            // 根据地址拷贝字符串
  - 其源码为：
char *strcpy(char *dst, const char *src){
    char *r = dst;
    assert((dst != NULL) && (src != NULL));
    while (*r++ = *src++);    // 逐个字符地赋值，当赋值到最后空字符（ASCII码为0）时，结束while循环
    return dst;
}
- int strncpy(const char *dst, const char *src, size_t n);
// 拷贝n个字符（包括空字符在内）。
  - 如果strlen(str) + 1 < n，则strncpy()会将不足的位用空字符补齐。
  - 如果strlen(str) + 1 > n，则strncpy()会拷贝不到源字符串末尾的空字符，导致目的字符串变得危险。
  - 因此，要谨慎设置目的字符串的长度。如下：
int len = (strlen(str) + 1);
char *pstr = malloc(sizeof(char) * len);
strncpy(pstr, str, len);
- char *strcat(char *, const char *);
// 拷贝第二个字符串，放到第一个字符串的原有字符之后
- char *strncat(char *, const char *, size_t n);
// 拷贝n个字符
- void *memcpy(void *dst, const void *src, size_t n);
// 从内存src拷贝n个字节到内存dst中
- void *memset(void *src, int x, size_t n);
// 将内存src的前n个字节赋值为x
  - 创建一个用于存储字符串的数组或内存空间之后，它存储的是垃圾值，应该用memset初始化后再使用。例如：
char str[10];
memset(str, NULL, sizeof(str));
  - 函数memcpy()、memset()不止可以处理字符串，还可以处理其它类型的内存空间。
用strcpy()拷贝时，遇到空字符就会停止。而用memcpy()拷贝时，即使数据中包含空字符，也会固定拷贝n个字节。
##
##
##
 
ASCII码
- C语言按照ASCII码表处理每个字符的编码，总共有128种字符。
- 非打印字符：不能显示（或者显示时会乱码），用于控制排版、传输。
十进制值    名称
0    NULL（空字符）
1    SOH(标题开始)
2    STX（正文开始）
3    ETX（正文结束）
4    EOT（传输结束）
5    ENQ（请求）
6    ACK（确认）
7    BEL（响铃）
8    Backspace（退格）
9    HT（水平制表符）
10    LF（换行符）
11    VT（垂直制表符）
12    换页符
13    CR（回车符）

127    DEL（删除）
- 可打印字符：可以在文本阅读器中显示出来，用于表示文本信息。
32    space（空格）
33    !

48    0
57    9

65    A
90    Z

97    a
122    z
- 转义字符：一些以反斜杠 \ 开头的特殊字符。
- \' 表示单引号、\" 表示双引号、\n 表示换行符、\b表示退格、\t 表示输出八个空格、\\ 表示反斜杠。
- 特别地，百分号的转义字符是 %% 。
注释和除号都是用正斜杠 /（它是45度角），而转义字符是用反斜杠 \ 。


预处理指令
- 预处理指令：在源代码的开头用井号 # 声明的命令，会在编译之前被执行。
- 它不是语句，末尾不需要加分号 ; 。
- 用`#include 头文件`的格式可以导入一个头文件（相当于拷贝其全部内容）。
- 如果头文件名用尖括号 < > 包住，则编译器会到系统默认目录（即环境变量PATH中包含的路径）下寻找该头文件。
#include <stdio.h>
- 如果头文件名用双引号 " " 包住，则编译器会先在当前目录下寻找该头文件，再到系统默认目录下寻找。
#include "myheader.h"
- 如果头文件名中包含了路径，则编译器只会到该路径下寻找头文件。
#include <C:\MinGW\include\windows.h>
- 当源文件数量较多时应该分类存放，比如将头文件、源文件分别放在include、src目录下，然后用makefile来编译。
- 用宏定义`#define 表达式1 表达式2`可以定义一个宏，会在编译之前进行文本替换。
- 例：
#define value(x,y) x*y       // 定义一个宏
result = value(m, n+1);      // 这行代码在编译之前会被替换成result = m*n + 1;
- 通常把宏名看作常量，全部大写。
##
##
##
 
宏定义
- 宏定义也可以使用类似if语句的条件编译。如下：
#if defined PI        // 如果PI已经被定义，则进行以下编译
#undef PI            // 取消PI的定义
#define PI 3
#endif

#if PI==3.14            // 两路选择结构
...
#else
...
#endif

#if !(defined PI && defined DEBUG)        // 多路选择结构
...
#elif
...
#else
...
#endif
- 宏定义可以在代码的任何位置出现，编译器会从上到下依次处理。即使宏定义放在一个不会被调用的函数中，也会被编译器处理。
- 使用宏替换可以进行一些简单的运算，比定义一个函数的开销小、更灵活，但是没有使用函数那么可靠。
- 使用宏替换时，要将输入参数和输出参数都用括号包住，以免因为遇到优先级混乱的运算符而出错。例如：
# define MAX(x, y) ((x) > (y) ? (x) : (y))
- 由于宏替换只进行简单的字符替换，可能因为输入参数的格式超出预料而出错。例如：
int x = 1, y = 2;
printf("max = %d\n", MAX(x++, y++));
//显示为：max = 3
- 在宏替换的输入参数前加上井号 # ，可以将该变量的标识符转换成字符串。例如：
# define SHOW(x) printf("This parameter is: "# x"\n")
    int i = 0;
    SHOW(i);
    //显示为：This parameter is: i
- 内置的宏。
- 编译器内置了一些宏，不需要包含头文件就能使用，如下。
    printf("in file %s, line %d\n", __FILE__, __LINE__);
    //显示为：in file d:\1\test_C\1.c, line 17
    printf("at %s, %s\n", __TIME__, __DATE__);
    //显示为：at 15:20:16, Jan 19 2019
  - __FILE__、__LINE__代表源文件的文件名（字符串型数据）、编译时所在行（int型数据）。
  - __TIME__、__DATE__代表编译时的时刻、日期。
##
##
##
 
头文件
- 头文件：扩展名为 .h ，用于保存一些预处理指令、变量或函数的声明语句。
- 头文件名不区分大小写，但通常都小写。
- 头文件中不能包含可执行语句，但是可以定义函数或变量。
- 头文件的最大作用是让一个源文件可以调用另一个源文件的函数或变量。
  - 例如，在源文件1.c中定义某个函数，把该函数的声明语句放到对应的头文件1.h中。然后在另一个源文件2.c中导入头文件1.h，就可以调用该函数。
- 一个头文件可能被某个源文件重复导入。例如，源文件A 导入了头文件B和头文件C，如果头文件B已经导入了头文件C，就会导致重复导入。因此，要用宏定义判断是否已经导入了该头文件，如下：
#ifndef _MYHEADER_H_
#define _MYHEADER_H_
...
#endif
- 宏名_MYHEADER_H_由头文件myheader.h转换而来。转换时将每个字母大写，将小数点转换成下划线，再在前、后加上一个下划线
##
##
##

##
##
##
 
<stdlib.h>
- stdlib.h是标准函数库（standard library）。
- 随机数。
- int rand(void);                    //按预定的序列生成伪随机数，每次重新运行程序时得到的随机数是相同的
  - <stdlib.h>里宏定义了rand()返回的最大值为0x7FFF、最小值为0。
  - 例如：
x = rand()%(B-A)+A;            //生成A与B之间的伪随机数
- void srand(unsigned int);            //用于设置随机数的种子，使得rand()函数产生不同的随机数序列
  - 例如：
srand(time(0));
x = rand();
- 调用系统的API
- int system(const char *string);    //给DOS窗口发出一个命令（采用字符串的形式）
  - 例如：
system("pause");            //暂停运行，按下任意键继续
system("cls");            //清屏
system("color 0A");        //设置DOS窗口的颜色，取值为0~F，前一位0表示背景色，后一位A表示前景色
system("del D:\\1.txt");    //删除文件D:\1.txt（在字符串中输入 \ 要转义，所以是 \\）
system("dir");            //列出当前目录下的所有文件和文件夹列表
system("dir D:\");        //列出指定目录下的所有文件和文件夹列表
system("D:");            //进入D盘
system("cd D:\1");        //进入指定目录（cd代表change directory），cd只能在同一个盘符内移动
system("exit");            //退出DOS窗口
- void abort(void);                //使进程非正常终止
- void exit(int status);        //使进程正常终止，并向父进程返回一个状态值
##
##
##
 

 
<time.h>
- time.h提供了获取时间、日期的函数。如下：
#include <time.h>

time_t timep;
struct tm *ptime;
time(&timep);
ptime = localtime(&timep);        // 获取当前时间（本地时区）
printf("Year:  %d\n", 1900 + ptime->tm_year);
printf("Month:  %d\n", 1 + ptime->tm_mon);
printf("Day:  %d\n", ptime->tm_mday);
printf("Hour:  %d\n", ptime->tm_hour);
printf("Minute:  %d\n", ptime->tm_min);
printf("Second:  %d\n", ptime->tm_sec);
printf("Weekday:  %d\n", ptime->tm_wday);
##
##
##
 
<assert.h>
- assert.h提供了断言函数assert()，适用于打印调试信息。
- assert()被宏定义如下：
# undef assert
# ifdef NDEBUG
# define assert(x)    ((void)0)
# else
# define assert(e)    ((e) ? (void)0 : _assert(# e, __FILE__, __LINE__))
# endif
  - 当assert()的输入为假时，它会向stderr打印错误信息，并调用函数abort()来终止程序。当assert()的输入为真时，它不会起作用。
  - void _assert(const char *, const char *, int)会显示错误信息并调用abort()终止程序。
  - 在生产环境，可以宏定义NDEBUG，使assert()失效。（要保证该宏定义在头文件assert.h之前被编译）
- 例如，在以下语句中插入断言，
    int x = 0;
    while(1)
    {
        printf("%d", x++);
        assert(0 < x && x < 10);
    }
// 显示为：0123456789Assertion failed: 0 < x && x < 10, file d:\1\test_C\1.c, line 21
##
##
##
 
<math.h>
- math.h提供了一些数学函数。
- 三角函数。
- double sin(double);        // 参数为弧度值
- double cos(double);        // 参数为弧度值
- double tan(double);        // 参数为弧度值
- 反三角函数。
- double asin(double);
- double acos(double);
- double atan(double);
- 其它。
- double fabs(double);        // 返回x的绝对值
- double floor(double);        // 返回不大于x的最大整数
- double ceil(double);        // 返回不小于x的最小整数
##
##
##
 

##
##
##
##
##
##
 
访问文件
- 访问文件的原理。
- 数据的输入、输出都称为流(stream)，例如一个文件和一个输入流关联时，就可以从这个文件读取数据。
  - 程序运行时会自动打开标准输入流stdin、标准输出流stdout、标准错误流stderr，它们默认映射到终端的输入、输出。
- 读、写文件的内容之前，要先调用fopen()函数打开文件，这会创建一个文件缓冲区（大小由编译器决定）。
  - 当处理完文件之后，要调用fclose()函数关闭文件，这会销毁文件缓冲区。
  - 如果没有关闭文件，程序就会一直占用该文件，导致该文件不能被改名或删除。
- 程序从文件中读取数据时，会先将数据暂存到文件缓冲区中，再加载到一块内存空间中。最后返回一个文件指针，指向这个内存空间的地址。
  - 程序写入数据到文件时，会先将内存空间中的数据暂存到文件缓冲区中，等缓冲区满了之后再写入文件。
  - 读取文件时，每读取一个字符文件指针就会后移一位，直到移动到文件末尾，读取到文件结束符EOF（宏定义为-1）。
  - 写入文件时，每写入一个字符文件指针就会后移一位。
- 文件模式。
  - "r"    ：只读模式。文件指针指向文件开头，如果文件不存在就报错。
  - "w"    ：只写模式。文件指针指向文件开头（因此写入时会覆盖原数据），如果文件不存在就创建它。
  - "a"    ：追加（只写）模式。文件指针指向文件末尾，如果文件不存在就报错。
  - "r+"    ：读写模式。如果文件不存在就报错。
  - "w+"    ：读写模式。如果文件不存在就创建它。
  - "a+"    ：读写模式。如果文件不存在就报错。
  - 以上模式都是以文本形式打开文件（属于字符流），加上 b 就会以二进制形式打开文件（属于二进制流）：
"rb"、"wb"、"ab"、"rb+"、"wb+"、"ab+"
- 导入头文件<stdio.h>之后可使用一些访问文件的函数。
- 例：
FILE *f = fopen("D://test_C//1.c", "r");    // 打开文件
if(f == NULL){
    printf("Failed to open the file.");
    return -1;
}

int c;
while (c != EOF){            // 判断文件是否结束，相当于while(!feof(f))
    c = fgetc(pfile);        // 从文件中读取一个字符
    putchar(c);
}

fclose(pfile);        // 关闭文件

- 使用fprintf()和fscanf()的例子：
FILE *f = 0;
char *filename = "D://test_C//1.c";
f = fopen(filename, "w");
int x = 1, y = 2;
fprintf(f, "%d%d", x, y);
fclose(f);                //关闭文件再换成读取模式打开，直接切换模式可能导致缓存区的数据丢失
f = fopen(filename, "r");
fscanf(f, "%d%d", &x, &y);
fclose(f);
##
##
##
 
<stdlib.h>
- 打开、关闭文件。
- FILE *fopen(const char *filename, const char *mode);    // 以指定模式打开文件
  - 函数运行成功后会返回一个FILE*类型的指针（称为文件指针），否则返回NULL。
  - 文件名可以是相对路径或绝对路径。
- int fclose(FILE *stream);            // 关闭文件
  - 函数运行成功后会返回0，否则返回EOF。
- int feof(FILE *stream);            // 判断文件是否结束
  - 如果上一次fread()等函数读取到的是EOF，或读取出错，feof()就返回非零值，否则返回0。
- long ftell(FILE *stream);            // 返回文件指针相对于文件开头的偏移量（单位为字节）
  - 函数运行成功后会返回一个带符号的long型值，否则返回-1L。
  - 例：
fseek(f, 10L, 0);
long site = ftell(f);
if(site == -1L)
    return -1;
- void rewind(FILE *);                // 将文件指针移动到文件开头
- int fseek(FILE *, long, int);        // 将文件指针移动一定距离（单位为字节）
  - 第二个参数表示偏移量，为带符号的long型值。
  - 第三个参数表示偏移的起点，可为0（表示文件开头）、1（表示当前位置）、2（表示文件末尾）。
- int ferror (FILE *);        // 检查上一次调用文件读、写函数是否出错，如果没出错就返回0，否则返回非零值
  - 用fopen()打开文件时，编译器会将文件错误标志初始化为0。
  - 程序每次调用文件读、写函数时，会将文件错误标志复位为0。如果出错，就将它置一。
- void clearerr (FILE *);    // 将文件错误标志、文件结束标志复位为0
- 读、写字符流。
- int fgetc(FILE *)                                // 从stream读取一个字符
  - 函数运行成功后会返回该字符，否则返回EOF。
- int fputc(int, FILE *);                        // 输出一个字符到stream
  - 函数运行成功后会返回该字符，否则返回EOF。
- char *fgets(char *p, int n, FILE *);            // 从stream读取一行字符串，保存到指针p中
  - fgets()会读取一连串字符，直到遇到换行符（会将这个换行符也读取），或EOF，或读取了n-1个字符。
  - 函数运行成功后会返回指针p，否则返回NULL。
- int fputs(const char *, FILE *);                // 输出一个字符串到stream
  - 函数运行成功后会返回0，否则返回非零值。
- int fscanf(FILE *stream, const char *, ...);            // 从stream读取输入
- int fprintf(FILE *stream, const char *format, ...);        // 输出字符串到stream
- 读写二进制流。
- int fread(void *p, int size, int count, FILE *f);
  - 从f中读取二进制数据，每次读取size字节，读取count次，保存到p中。
  - 函数运行成功后会返回count。
- int fwrite(const void *p, int size, int count, FILE *f);
  - 从p中读取二进制数据，写入到f中，每次写入size字节，写入count次。
  - 函数运行成功后会返回count。
- 管理文件。
- int remove(const char *filename);
- int rename(const char *old_filename, const char *new_filename);
##
##
##
 
读写二进制文件
- 以下例子是以二进制形式读写文件，而且是直接读写结构体类型的数据。
#define COUNT 10
// 构造数据
struct Horse
{
    char name[10];
    int age;
} list[COUNT];

// 写入
FILE *f = fopen("1.txt", "wb");
if (f == NULL)
{
    printf("Failed to open the file.");
    return -1;
}
for (i = 0; i < COUNT; i++)
{
    if (fwrite(&list[i], sizeof(struct Horse), 1, f) != 1)
    {
        printf("Error writing the file.");
        return -1;
    }
}
fclose(f);

// 读取
f = fopen("1.txt", "rb");
if (f == NULL)
{
    printf("Failed to open the file.");
    return -1;
}
for (i = 0; i < COUNT; i++)
{
    if (fread(&list[i], sizeof(struct Horse), 1, f) != 1)
    {
        printf("Error reading the file.");
        return -1;
    }
    printf("Name: %s, Age: %d\n", list[i].name, list[i].age);
}
fclose(f);

 
读取JSON文件
- 以下例子是读取JSON文件并解析。
- 主要逻辑：
  - 先计算文件的大小，然后创建一个相应大小的内存空间，再读取文件内容。
static char* read_json_file(const char* file)
{
  FILE* fp;
  char* file_stream = NULL;
  size_t file_len = 0;
  if (!file) {
    return NULL;
  }
  fp = fopen(file, "r");
  if (fp == NULL) {
    TRACE_ERROR("Failed to open the file.");
    return NULL;
  }

  /*seek to end*/
  fseek(fp, 0, SEEK_END);

  /*Get file length*/
  file_len = ftell(fp);

  /*seek to head*/
  fseek(fp, 0, SEEK_SET);

  file_stream = (char*)malloc(sizeof(char)*(file_len + 1));
  if (file_stream != NULL) {
    memset(file_stream, 0, sizeof(char)*(file_len + 1));
    fread(file_stream, sizeof(char), file_len, fp);
  }
  fclose(fp);
  return file_stream;
}

int get_device_config(char* pid, char* did, char* secret, char* url)
{
  cJSON* config_json = NULL;
  char* json_string = NULL;

  json_string = read_json_file(DEVICE_CONFIG_FILE);
  if (NULL == json_string) {
    return -1;
  }
  config_json = cJSON_Parse(json_string);

  if (NULL != config_json) {
    if ((NULL
         != cJSON_GetObjectItem(config_json,
                                "pid"))
        && (NULL
            != cJSON_GetObjectItem(config_json,
                                   "did"))
        && (NULL
            != cJSON_GetObjectItem(config_json,
                                   "secret"))
        && (NULL != cJSON_GetObjectItem(config_json, "url"))) {
      strncpy(pid,
              cJSON_GetObjectItem(config_json, "pid")->valuestring,
              CONFIG_LEN);
      strncpy(did,
              cJSON_GetObjectItem(config_json, "did")->valuestring,
              CONFIG_LEN);
      strncpy(secret,
              cJSON_GetObjectItem(config_json, "secret")->valuestring,
              CONFIG_LEN);
      strncpy(url,
              cJSON_GetObjectItem(config_json, "url")->valuestring,
              CONFIG_LEN);
      cJSON_Delete(config_json);
      free(json_string);
      json_string = NULL;
      return 0;
    }
    cJSON_Delete(config_json);
    free(json_string);
    json_string = NULL;
  }

  return -1;
}

##
##
##
 
多线程
- C语言的线程库。
- 在Linux系统上，可使用pthread.h的API创建线程。比如pthread_create()。
  - pthread.h符合POSIX标准，适用于类Unix系统。也有兼容Windows的版本——pthreads-w32。
  - 编译时要链接pthread库，比如：gcc test.c -o test -l pthread
- 在Windows系统上，可使用windows.h的API创建线程。比如CreateProcess()。
- C11制定了一个标准的线程库threads.h，但部分编译器不支持它。
##
##
##
 
<pthread.h>
- pthread.h的常用函数。（API列表：https://www.sourceware.org/pthreads-win32/manual/index.html）
- pthread_t                // 一种数据类型，用于存储线程ID
- pthread_attr_t            // 一种数据类型，用于存储线程属性
- int pthread_create(pthread_t *id,                // 传入一个pthread_t类型的变量的地址
const pthread_attr_t * attr,    // 传入线程的属性（传入NULL则是默认属性）
void *(*) (void *),            // 传入要运行的函数名
void *arg);        // 传入要运行的函数的参数（没有参数则填NULL，有多个则封装成一个结构体）
  - 功能：创建一个线程来运行一个函数。
  - 线程创建成功后会将该线程的ID存储到变量id中，并返回0。线程创建失败时会返回非零值。
  - 要运行的函数应该定义成 void *fun(void *arg) 的格式。
- void pthread_exit(void *retval);
  - 功能：终止当前线程。retval用于存储当前线程的返回值，可在其它线程中查看该变量的值。
  - 当一个线程的代码运行结束时，该线程就会自动终止。也可以调用一些函数来主动结束线程。
- int pthread_cancel(pthread_t id);
  - 功能：向某个线程发送取消请求。
  - 目标线程可能立即终止，也可能稍后终止，也可能忽略取消请求。
- int pthread_join(pthread_t id, void **retval);
  - 功能：暂停当前线程的运行，等待id所指的线程终止。当它终止之后，其返回值会存储在retval变量中。
-
- 例：
#include <stdio.h>
#include <pthread.h>

void *fun1(){
    puts("fun1() end.");
    return 0;
}

typedef struct{
    int age;
    char name[10];
} Horse;

void *fun2(void *p){
    Horse h = *(Horse *)p;
    printf("age: %d, name: %s.\n", h.age, h.name);
    puts("fun2() end.");
    return 0;
}

int main(){
    int rc;
    pthread_t id;

    // 创建第一个线程
    rc = pthread_create(&id, NULL, fun1, NULL);
    if (rc)
        puts("Failed to create the thread fun1().");

    // 创建第二个线程
    Horse horse = {5, "Jack"};
    rc = pthread_create(&id, NULL, fun2, &horse);
    if (rc)
        puts("Failed to create the thread fun2().");

    // 阻塞主线程的运行，以免提前终止子线程
    pthread_join(id, NULL);
    puts("main() end.");
    return 0;
}
##
##
##
 
:::