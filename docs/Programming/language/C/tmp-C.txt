::: v-pre



## stdlib.h

- 动态分配内存。
- void *malloc(size_t size);
  - 请求分配一块内存空间，大小为size字节。如果请求成功则返回一个指向该内存地址的void *指针，否则返回NULL。
  - 例如：
char *str1 = malloc(10*sizeof(char));
if(str1 == NULL)            // 动态分配内存之后应该先检查返回的指针是否有效
    return -1;            // windows存在虚拟内存机制，因此一般不会无内存可分配
printf("%s\n", str1);        // 显示为乱码，因为该内存空间存储着垃圾数据
strcpy(str1, "Hello");
printf("%s\n", str1);        // 显示为：Hello
free(str1);                // 使用完之后应该及时释放这块内存空间
  - malloc()返回的指针类型是void *，但是不必转换其数据类型，因为：
1. void *指针在赋值时会自动转换指针的数据类型。
2. C语言中，如果编译器调用一个函数时没有找到它的声明，则会自动进行隐式声明（implicit declaration），使其返回值为int型。因此如果忘了导入头文件stdlib.h，malloc()函数的返回值会是int型，不能给指针类型的变量赋值，编译时就会及时报错。
  - 如下，C++中使用malloc()函数时需要进行强制类型转换，否则会报错：无法从 void * 类型转换成 char *类型。
char *str1 = (char *)malloc(10*sizeof(char));
- void *calloc(size_t num, size_t size);
  - 请求分配一块内存空间，大小为num*size字节，并将其初始化为0。如果请求成功则返回一个指向该内存地址的void *指针，否则返回NULL。
  - 例如：
char *str1 = calloc(10, sizeof(char));        // 相当于malloc(10*sizeof(char))
if(str1 == NULL)
    return -1;
printf("%s\n", str1);        // 显示为空
strcpy(str1, "Hello");
printf("%s\n", str1);        // 显示为： Hello
free(str1);
- void *realloc(void *p, size_t size);
  - p指向一个用malloc()或calloc()分配的内存空间，请求改变其大小为size字节。如果请求成功则返回原指针p，否则返回NULL。
  - 如果p为空指针，则realloc()会创建一个size字节的内存空间。
  - 例如：
char *str1 = malloc(10*sizeof(char));
char *rc = realloc(str1, 20);
if(rc == NULL)
    return -1;
- void free(void *);            // 释放动态分配的内存空间
  - 应该及时释放不用的内存，以免程序占用越来越多的内存，导致内存泄露（memory leaks），使得系统变得卡顿甚至使程序奔溃。


C程序启动时，会向操作系统申请一定大小的内存空间。然后将该内存空间划分成几个区域：
- 堆区（heap）：动态存储区
  - 堆区内存由程序员主动分配、释放（通过执行malloc、free等函数），如果没有释放则会一直保留，当程序终止时会被系统自动释放。
  - 存储结构类似于数据结构中的链表，而不是堆。
- 栈区（stack）：局部变量区
  - 栈区的内存由系统在运行程序时自动按需分配、释放。
  - 存储结构类似于数据结构中的栈。
- 静态变量区（static）
  - 全局变量也是采用静态存储方式，存储在这里
- 常量区 ：存放常量字符串。
- 代码区 ：存放二进制代码。


- C语言编译器给程序分配内存时有两种方式：
- 静态的内存分配方式：在程序编译时就分配好内存空间，此后一直不变，直到程序终止才释放。
  - 比如函数、数组、全局变量、静态变量。
- 动态的内存分配方式：当程序需要用到时才分配分配、释放内存空间。
  - 比如局部变量、动态分配的内存。
- 常见的内存问题。

- 访问无效的内存地址：可能导致程序崩溃。比如访问已经被销毁的内存地址。
- 内存越界访问
  - ：访问一个对象时，使用了不合理的内存地址，超出该对象的内存地址范围。
  - 例如：程序用 malloc() 申请一块 2 bytes 的内存空间，得到一个指针。然后往该指针指向的内存地址，写入 3 bytes 的数据。此时第 3 个 byte ，就写到了当前内存的地址范围之外。
  - 为什么程序会发生内存越界访问？通常是因为编程时没有检查写入值的长度。例如：
    - 申请一块内存空间，准备写入一个字符串。但使用 strcpy、strcat、sprintf、gets() 等函数，没有限制字符串的长度，因此字符串可能超出预期长度，导致内存越界访问。建议换成 strncpy、strncat、snprintf 等函数。
  - 根据访问方式，分为两种情况：
    - 读越界：可能读取到错误的数据，导致程序出错，甚至崩溃。
    - 写越界：可能修改其它变量使用的内存空间，导致程序出错，甚至崩溃。
  - Linux 内核会为每个进程维护一个页表，记录该进程申请使用了哪些堆内存地址。当进程访问一个内存地址时，
    - 如果该内存地址包含于当前页表中，则说明已分配给该进程。因此内核会允许该进程访问，不管是否越界。这可能产生几种越界情况：
      - 该内存地址正在被当前进程的其它变量使用。
      - 该内存地址未被当前进程使用，但以后可能被使用。
    - 如果该内存地址不在当前页表中，则说明未分配给该进程。因此内核会拒绝该进程访问，发出 segment fault 信号，导致进程崩溃。
  - 除了堆内存，如果进程越界访问内核内存空间、只读存储区、代码段，Linux 内核也会拒绝该进程访问，发出 segment fault 信号，导致进程崩溃。

- 栈溢出（stack overflow）
  - ：在栈区发生的内存越界访问。
  - 程序运行时，会将所有函数参数、局部变量存储在内存的栈区。对这些变量的访问可能越界，例如：
    - 读写数组时下标越界。这可能会读写隔壁变量的内存空间。
      恶意用户可利用程序的栈溢出漏洞，修改程序中某些重要的变量。该操作称为栈溢出攻击。
    - 创建太大的数组，超出栈区的容量，导致程序崩溃。
    - 每次调用一个函数，都会在栈区分配一块内存来存储函数参数、局部变量，当函数执行完毕时才释放内存。如果一个函数调用另一个函数，如此嵌套，调用层数太深，则占用内存可能超出栈区的容量，导致程序崩溃。

- 缓冲区溢出攻击（Buffer Overflow Attack）
  - ：一种攻击方式。通常是程序的开发者，将程序交给其他人使用，但有人故意引发内存越界访问，从而控制该程序执行不合理的操作。
  - 原理：攻击者向程序的一个变量（通常用作缓冲区，允许用户修改）中，故意写入过长的数据，超出该变量的内存地址范围，写入到了该变量隔壁的内存地址，从而修改隔壁的数据（比如变量、函数返回地址）。
  - 栈溢出攻击：缓冲区溢出攻击的一种形式，在栈区发生。


- 内存泄漏（memory leak）：给程序分配了堆区的内存之后一直没有释放，还不断地继续分配内存，导致程序占用的堆区内存越来越多、系统的可用内存越来越少。
- 内存溢出（out of memory）：程序耗尽了系统的所有内存。此时程序可能被系统强制终止。
  - C程序在Windows上运行时，分配的是虚拟内存，理论上难以出现内存溢出的情况。
  - C++使用malloc或关键字new来分配堆中的内存，Java、C# 使用关键字new来分配堆中的内存。
  - Java的垃圾收集器会自动收走堆中不再使用的数据。

- 预防措施。
- 每次申请分配内存之后，检查是否分配成功，即检查返回的指针是否为NULL。
- 如果成功分配了内存，就用memset()初始化该内存。
  - 否则，如果之后读取这块内存，会读取到垃圾数据；如果往这块内存写入数据，只要没完全覆盖这块内存，就会留下一些垃圾数据。
- 使用指针时，检查指针是否正确。
  - 如果访问一个不存在的内存地址，程序可能会崩溃。
  - 如果访问一个存在的、意料之外的内存地址，会造成不可预知的后果。
- 访问一块内存时，检查是否会内存越界。

分配一块内存之后，在使用之后忘记释放。这会导致内存泄漏。
重复释放一块已经被释放的内存。这会导致内存访问越界，通常会使程序崩溃。

可以采用以下流程动态分配内存，提高代码的健壮性。
// 申请
char *p = malloc(10*sizeof(char));
if(str1)            // 动态分配内存之后应该先检查返回的指针是否有效
    return -1;
// 释放
if(p){
    free(p);
    p = NULL;
}
##
##
##
 



 
<time.h>
- time.h提供了获取时间、日期的函数。如下：
#include <time.h>

time_t timep;
struct tm *ptime;
time(&timep);
ptime = localtime(&timep);        // 获取当前时间（本地时区）
printf("Year:  %d\n", 1900 + ptime->tm_year);
printf("Month:  %d\n", 1 + ptime->tm_mon);
printf("Day:  %d\n", ptime->tm_mday);
printf("Hour:  %d\n", ptime->tm_hour);
printf("Minute:  %d\n", ptime->tm_min);
printf("Second:  %d\n", ptime->tm_sec);
printf("Weekday:  %d\n", ptime->tm_wday);
##
##
##
 
<assert.h>
- assert.h提供了断言函数assert()，适用于打印调试信息。
- assert()被宏定义如下：
# undef assert
# ifdef NDEBUG
# define assert(x)    ((void)0)
# else
# define assert(e)    ((e) ? (void)0 : _assert(# e, __FILE__, __LINE__))
# endif
  - 当assert()的输入为假时，它会向stderr打印错误信息，并调用函数abort()来终止程序。当assert()的输入为真时，它不会起作用。
  - void _assert(const char *, const char *, int)会显示错误信息并调用abort()终止程序。
  - 在生产环境，可以宏定义NDEBUG，使assert()失效。（要保证该宏定义在头文件assert.h之前被编译）
- 例如，在以下语句中插入断言，
    int x = 0;
    while(1)
    {
        printf("%d", x++);
        assert(0 < x && x < 10);
    }
// 显示为：0123456789Assertion failed: 0 < x && x < 10, file d:\1\test_C\1.c, line 21
##
##
##
 
<math.h>
- math.h提供了一些数学函数。
- 三角函数。
- double sin(double);        // 参数为弧度值
- double cos(double);        // 参数为弧度值
- double tan(double);        // 参数为弧度值
- 反三角函数。
- double asin(double);
- double acos(double);
- double atan(double);
- 其它。
- double fabs(double);        // 返回x的绝对值
- double floor(double);        // 返回不大于x的最大整数
- double ceil(double);        // 返回不小于x的最小整数
##
##
##
 

##
##
##
##
##
##
 
访问文件
- 访问文件的原理。
- 数据的输入、输出都称为流(stream)，例如一个文件和一个输入流关联时，就可以从这个文件读取数据。
  - 程序运行时会自动打开标准输入流stdin、标准输出流stdout、标准错误流stderr，它们默认映射到终端的输入、输出。
- 读、写文件的内容之前，要先调用fopen()函数打开文件，这会创建一个文件缓冲区（大小由编译器决定）。
  - 当处理完文件之后，要调用fclose()函数关闭文件，这会销毁文件缓冲区。
  - 如果没有关闭文件，程序就会一直占用该文件，导致该文件不能被改名或删除。
- 程序从文件中读取数据时，会先将数据暂存到文件缓冲区中，再加载到一块内存空间中。最后返回一个文件指针，指向这个内存空间的地址。
  - 程序写入数据到文件时，会先将内存空间中的数据暂存到文件缓冲区中，等缓冲区满了之后再写入文件。
  - 读取文件时，每读取一个字符文件指针就会后移一位，直到移动到文件末尾，读取到文件结束符EOF（宏定义为-1）。
  - 写入文件时，每写入一个字符文件指针就会后移一位。
- 文件模式。
  - "r"    ：只读模式。文件指针指向文件开头，如果文件不存在就报错。
  - "w"    ：只写模式。文件指针指向文件开头（因此写入时会覆盖原数据），如果文件不存在就创建它。
  - "a"    ：追加（只写）模式。文件指针指向文件末尾，如果文件不存在就报错。
  - "r+"    ：读写模式。如果文件不存在就报错。
  - "w+"    ：读写模式。如果文件不存在就创建它。
  - "a+"    ：读写模式。如果文件不存在就报错。
  - 以上模式都是以文本形式打开文件（属于字符流），加上 b 就会以二进制形式打开文件（属于二进制流）：
"rb"、"wb"、"ab"、"rb+"、"wb+"、"ab+"
- 导入头文件<stdio.h>之后可使用一些访问文件的函数。
- 例：
FILE *f = fopen("D://test_C//1.c", "r");    // 打开文件
if(f == NULL){
    printf("Failed to open the file.");
    return -1;
}

int c;
while (c != EOF){            // 判断文件是否结束，相当于while(!feof(f))
    c = fgetc(pfile);        // 从文件中读取一个字符
    putchar(c);
}

fclose(pfile);        // 关闭文件

- 使用fprintf()和fscanf()的例子：
FILE *f = 0;
char *filename = "D://test_C//1.c";
f = fopen(filename, "w");
int x = 1, y = 2;
fprintf(f, "%d%d", x, y);
fclose(f);                //关闭文件再换成读取模式打开，直接切换模式可能导致缓存区的数据丢失
f = fopen(filename, "r");
fscanf(f, "%d%d", &x, &y);
fclose(f);
##
##
##
 
<stdlib.h>
- 打开、关闭文件。
- FILE *fopen(const char *filename, const char *mode);    // 以指定模式打开文件
  - 函数运行成功后会返回一个FILE*类型的指针（称为文件指针），否则返回NULL。
  - 文件名可以是相对路径或绝对路径。
- int fclose(FILE *stream);            // 关闭文件
  - 函数运行成功后会返回0，否则返回EOF。
- int feof(FILE *stream);            // 判断文件是否结束
  - 如果上一次fread()等函数读取到的是EOF，或读取出错，feof()就返回非零值，否则返回0。
- long ftell(FILE *stream);            // 返回文件指针相对于文件开头的偏移量（单位为字节）
  - 函数运行成功后会返回一个带符号的long型值，否则返回-1L。
  - 例：
fseek(f, 10L, 0);
long site = ftell(f);
if(site == -1L)
    return -1;
- void rewind(FILE *);                // 将文件指针移动到文件开头
- int fseek(FILE *, long, int);        // 将文件指针移动一定距离（单位为字节）
  - 第二个参数表示偏移量，为带符号的long型值。
  - 第三个参数表示偏移的起点，可为0（表示文件开头）、1（表示当前位置）、2（表示文件末尾）。
- int ferror (FILE *);        // 检查上一次调用文件读、写函数是否出错，如果没出错就返回0，否则返回非零值
  - 用fopen()打开文件时，编译器会将文件错误标志初始化为0。
  - 程序每次调用文件读、写函数时，会将文件错误标志复位为0。如果出错，就将它置一。
- void clearerr (FILE *);    // 将文件错误标志、文件结束标志复位为0
- 读、写字符流。
- int fgetc(FILE *)                                // 从stream读取一个字符
  - 函数运行成功后会返回该字符，否则返回EOF。
- int fputc(int, FILE *);                        // 输出一个字符到stream
  - 函数运行成功后会返回该字符，否则返回EOF。
- char *fgets(char *p, int n, FILE *);            // 从stream读取一行字符串，保存到指针p中
  - fgets()会读取一连串字符，直到遇到换行符（会将这个换行符也读取），或EOF，或读取了n-1个字符。
  - 函数运行成功后会返回指针p，否则返回NULL。
- int fputs(const char *, FILE *);                // 输出一个字符串到stream
  - 函数运行成功后会返回0，否则返回非零值。
- int fscanf(FILE *stream, const char *, ...);            // 从stream读取输入
- int fprintf(FILE *stream, const char *format, ...);        // 输出字符串到stream
- 读写二进制流。
- int fread(void *p, int size, int count, FILE *f);
  - 从f中读取二进制数据，每次读取size字节，读取count次，保存到p中。
  - 函数运行成功后会返回count。
- int fwrite(const void *p, int size, int count, FILE *f);
  - 从p中读取二进制数据，写入到f中，每次写入size字节，写入count次。
  - 函数运行成功后会返回count。
- 管理文件。
- int remove(const char *filename);
- int rename(const char *old_filename, const char *new_filename);
##
##
##
 
读写二进制文件
- 以下例子是以二进制形式读写文件，而且是直接读写结构体类型的数据。
#define COUNT 10
// 构造数据
struct Horse
{
    char name[10];
    int age;
} list[COUNT];

// 写入
FILE *f = fopen("1.txt", "wb");
if (f == NULL)
{
    printf("Failed to open the file.");
    return -1;
}
for (i = 0; i < COUNT; i++)
{
    if (fwrite(&list[i], sizeof(struct Horse), 1, f) != 1)
    {
        printf("Error writing the file.");
        return -1;
    }
}
fclose(f);

// 读取
f = fopen("1.txt", "rb");
if (f == NULL)
{
    printf("Failed to open the file.");
    return -1;
}
for (i = 0; i < COUNT; i++)
{
    if (fread(&list[i], sizeof(struct Horse), 1, f) != 1)
    {
        printf("Error reading the file.");
        return -1;
    }
    printf("Name: %s, Age: %d\n", list[i].name, list[i].age);
}
fclose(f);

 
读取JSON文件
- 以下例子是读取JSON文件并解析。
- 主要逻辑：
  - 先计算文件的大小，然后创建一个相应大小的内存空间，再读取文件内容。
static char* read_json_file(const char* file)
{
  FILE* fp;
  char* file_stream = NULL;
  size_t file_len = 0;
  if (!file) {
    return NULL;
  }
  fp = fopen(file, "r");
  if (fp == NULL) {
    TRACE_ERROR("Failed to open the file.");
    return NULL;
  }

  /*seek to end*/
  fseek(fp, 0, SEEK_END);

  /*Get file length*/
  file_len = ftell(fp);

  /*seek to head*/
  fseek(fp, 0, SEEK_SET);

  file_stream = (char*)malloc(sizeof(char)*(file_len + 1));
  if (file_stream != NULL) {
    memset(file_stream, 0, sizeof(char)*(file_len + 1));
    fread(file_stream, sizeof(char), file_len, fp);
  }
  fclose(fp);
  return file_stream;
}

int get_device_config(char* pid, char* did, char* secret, char* url)
{
  cJSON* config_json = NULL;
  char* json_string = NULL;

  json_string = read_json_file(DEVICE_CONFIG_FILE);
  if (NULL == json_string) {
    return -1;
  }
  config_json = cJSON_Parse(json_string);

  if (NULL != config_json) {
    if ((NULL
         != cJSON_GetObjectItem(config_json,
                                "pid"))
        && (NULL
            != cJSON_GetObjectItem(config_json,
                                   "did"))
        && (NULL
            != cJSON_GetObjectItem(config_json,
                                   "secret"))
        && (NULL != cJSON_GetObjectItem(config_json, "url"))) {
      strncpy(pid,
              cJSON_GetObjectItem(config_json, "pid")->valuestring,
              CONFIG_LEN);
      strncpy(did,
              cJSON_GetObjectItem(config_json, "did")->valuestring,
              CONFIG_LEN);
      strncpy(secret,
              cJSON_GetObjectItem(config_json, "secret")->valuestring,
              CONFIG_LEN);
      strncpy(url,
              cJSON_GetObjectItem(config_json, "url")->valuestring,
              CONFIG_LEN);
      cJSON_Delete(config_json);
      free(json_string);
      json_string = NULL;
      return 0;
    }
    cJSON_Delete(config_json);
    free(json_string);
    json_string = NULL;
  }

  return -1;
}

##
##
##
 
多线程
- C语言的线程库。
- 在Linux系统上，可使用pthread.h的API创建线程。比如pthread_create()。
  - pthread.h符合POSIX标准，适用于类Unix系统。也有兼容Windows的版本——pthreads-w32。
  - 编译时要链接pthread库，比如：gcc test.c -o test -l pthread
- 在Windows系统上，可使用windows.h的API创建线程。比如CreateProcess()。
- C11制定了一个标准的线程库threads.h，但部分编译器不支持它。
##
##
##
 
<pthread.h>
- pthread.h的常用函数。（API列表：https://www.sourceware.org/pthreads-win32/manual/index.html）
- pthread_t                // 一种数据类型，用于存储线程ID
- pthread_attr_t            // 一种数据类型，用于存储线程属性
- int pthread_create(pthread_t *id,                // 传入一个pthread_t类型的变量的地址
const pthread_attr_t * attr,    // 传入线程的属性（传入NULL则是默认属性）
void *(*) (void *),            // 传入要运行的函数名
void *arg);        // 传入要运行的函数的参数（没有参数则填NULL，有多个则封装成一个结构体）
  - 功能：创建一个线程来运行一个函数。
  - 线程创建成功后会将该线程的ID存储到变量id中，并返回0。线程创建失败时会返回非零值。
  - 要运行的函数应该定义成 void *fun(void *arg) 的格式。
- void pthread_exit(void *retval);
  - 功能：终止当前线程。retval用于存储当前线程的返回值，可在其它线程中查看该变量的值。
  - 当一个线程的代码运行结束时，该线程就会自动终止。也可以调用一些函数来主动结束线程。
- int pthread_cancel(pthread_t id);
  - 功能：向某个线程发送取消请求。
  - 目标线程可能立即终止，也可能稍后终止，也可能忽略取消请求。
- int pthread_join(pthread_t id, void **retval);
  - 功能：暂停当前线程的运行，等待id所指的线程终止。当它终止之后，其返回值会存储在retval变量中。
-
- 例：
#include <stdio.h>
#include <pthread.h>

void *fun1(){
    puts("fun1() end.");
    return 0;
}

typedef struct{
    int age;
    char name[10];
} Horse;

void *fun2(void *p){
    Horse h = *(Horse *)p;
    printf("age: %d, name: %s.\n", h.age, h.name);
    puts("fun2() end.");
    return 0;
}

int main(){
    int rc;
    pthread_t id;

    // 创建第一个线程
    rc = pthread_create(&id, NULL, fun1, NULL);
    if (rc)
        puts("Failed to create the thread fun1().");

    // 创建第二个线程
    Horse horse = {5, "Jack"};
    rc = pthread_create(&id, NULL, fun2, &horse);
    if (rc)
        puts("Failed to create the thread fun2().");

    // 阻塞主线程的运行，以免提前终止子线程
    pthread_join(id, NULL);
    puts("main() end.");
    return 0;
}
##
##
##
 
:::