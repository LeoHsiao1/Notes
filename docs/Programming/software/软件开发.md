# 软件开发

- 20 世纪，计算机软件变得越来越复杂，因此人们总结了关于软件的各种技术、方法论，形成一门新的学科，软件工程（Software Engineering，SE）。
  - 研究软件工程的主要目的是：优化软件的开发过程，使得开发速度快、成本低、软件质量好。
  - 个人开发软件时，可能比较随意，不考虑软件工程。
  - 企业开发软件时，需要考虑多人协作、工程排期等问题，有必要考虑软件工程。
  - 在企业中，参与软件工程的工作人员，通常称为软件工程师（Software Engineer），俗称为程序员（Programmer）。
- 软件工程涉及到多种学科：
  - 管理学：人们将土木工程、车辆工程等传统的管理学经验，沿用到了软件工程。
  - 计算机科学（Computer Science，CS）：泛指对计算机的科学研究，比如计算机组成、计算机网络、操作系统、编程语言、数据结构、算法、人工智能。
  - 互联网技术（Internet Technology，IT）：泛指基于计算机互联网的技术，比如 Web 网站。

## 软件开发流程

- 假设一个企业，想售卖软件来营利，则总体流程如下：
  - 分析需求
  - 设计软件
  - 开发软件
  - 售卖软件
  - 售后（包括运维、技术支持）

- 企业开发软件时，标准流程如下：
  - 开发（develop）
    - 该环节，主要是修改软件的源代码。
  - 构建（build）
    - 很多软件是用 C、Java 等编译型语言开发的，源代码不能直接被人类使用，需要编译成二进制文件，才能被人类使用。
    - 很多软件比较复杂，除了编译，还需要进行一些加工操作，这些操作统称为构建。
  - 测试（test）
    - 每次修改软件之后，可能引入 bug 等问题，因此需要经过测试，检查没有问题之后，才能交给用户使用。
  - 发版（release）
    - 如果测试环节发现了软件的问题，就需要修改软件，重新开始流程：`开发 -> 构建 -> 测试`
    - 软件测试环节没发现问题，则需要将软件的当前状态记录下来，作为一个版本。
      - 例如记录：v1 版本的软件，源代码是什么内容，配置文件是什么内容。
      - 早期的软件工程师，需要手动记录每个版本的内容，很麻烦。后来发明了 Git 等版本管理工具，可以自动记录版本。
    - 开发一个软件时，可能先后发布多个版本，每个版本都应该记录下来。
      - 这样能看出软件的修改历史，每个版本改了哪些内容。
      - 客户默认会使用软件的最新版本，但有的客户希望使用旧版本，比如客户没时间升级新版本、不习惯新版本。
  - 部署（deploy）
    - 该环节，是将软件拷贝到一个计算机中，正式运行。
    - 在测试环节，为了节省成本，通常将软件放在一个性能较差的计算机中运行。等到正式部署时，才将软件放到正式的计算机中。
  - 交付（delivery）
    - 该环节，是通知客户，将软件交给客户使用。

### 加快流程

- 开发一个软件时，可能先后发布多个版本，因此需要多次执行 `分析需求 -> 设计软件 -> 开发软件` 的流程。
  - 但每次修改软件，都重新走一遍整个流程，耗时较久。
  - 为了加快流程，人们提出了以下几种方法。

- 瀑布开发（waterfall development）
  - ：遵守标准的软件开发流程，一步一步执行。完成一个环节之后，再专心执行下一环节。
  - 优点：
    - 对于管理者比较简单，同时只需要专心考虑一个环节。
  - 缺点：
    - 开发软件的速度慢。比如开发环节结束之后，工程师们才开会讨论测试方案。
    - 交付周期长。每次客户的需求变化时，需要重新走一遍整个流程，增加时间成本、人力成本。
  - 瀑布开发是一种传统的软件开发模式，被 20 世纪的企业广泛采用，但缺点明显。

- 迭代开发（iterative development）
  - ：每几周发布一个新版本（称为一次迭代），每次只开发软件 n% 的功能，并且让客户试用这部分功能，接收客户的反馈。等软件 100% 的功能开发完毕之后，才正式交付。
  - 优点：
    - 一边开发软件，一边根据客户的反馈来修正软件，这样能保证软件一直让客户差不多满意。
      - 否则，如果软件让客户很不满意，客户会要求对软件作出大幅修改，增加很多时间成本、人力成本。甚至，客户可能放弃购买该软件。

- 敏捷开发（agile development）
  - 2001 年，一些程序员开始宣扬敏捷开发的思想，提倡以下职业行为：
    - 同事之间及时沟通、快速协作。
      - 传统的工作模式是，同事之间通过企业行政流程进行协作，速度慢、效率低。
    - 在开发软件的初期，就与客户沟通、让客户试用，从而及时了解客户的需求，避免开发软件的方向走偏。
    - 与其给客户编写文档说明，不如直接展示可用的软件，即使只有部分功能可用。
    - 每次收到客户的新需求时，能快速迭代出一个新版本。
  - 缺点：
    - 敏捷开发需要企业有高效的管理能力，但很多传统企业只有能力实施瀑布开发。
  - 后来，敏捷开发衍生出几种方案：
    - Scrum
      - 要求同事们每天早上开一个几分钟的站会，交流昨天的工作进度、今天的工作安排。
      - 要求每两周完成一次迭代。
    - 极限编程
      - 它认为，如果一项措施的效果是好的，则将它做到极致。
      - 它提倡自动化测试、代码评审、快速迭代等措施。

- 测试驱动的开发
  - ：先按照需求，编写测试用例，然后开发能通过这些测试用例的代码。
  - 例如客户希望软件提供某一功能，则编写测试用例，检查软件能否实现该功能。然后开发代码，直到通过测试用例。
  - 优点：
    - 开发代码时，目标更明确，只要通过测试用例即可。
  - 缺点：
    - 客户的一个需求，可能需要用大量测试用例来描述，而且不一定能准确描述。

### 相关经验

- 分析需求时
  - 需要确定这个软件，希望实现什么功能、达到什么效果。
  - 评价一个软件好不好，需要衡量多个因素，做出取舍：
    - 成本
    - 功能（是否满足用户的需求）
    - 性能
    - 安全性（例如银行的软件系统最看重安全性）
  - 难点：程序员按照自己的想法开发软件，但不满足客户的需求，就赚不到钱
  - 难点：客户的需求不清晰
    - 客户通常不确定自己想要什么效果，只有个粗略想法。
    - 客户通常不了解计算机软件的原理，可能提出一些很难实现的需求，或者需要很大成本才能实现。
  - 难点：客户的需求会变化，导致软件开发成本增加
    - 例如客户突发奇想提了一个需求，过了一段时间却不想要这个需求了。
    - 例如客户方存在多人，提出不同的需求。

- 设计软件时
  - 实现常见的功能时，应该先到网上找找，有没有现成的方案。也许别人已经提出了良好的方案，可以供你借鉴，或者被你复用，避免重复造轮子。

- 编写代码时
  - 应该先规划，再行动。继续规划，继续行动。
    - 先想象出代码是什么样子，再把它编写出来，这样效率高。而不是先写一行代码，再构思下一行代码怎么写。
    - 为了避免努力的方向错误，埋头苦干几个小时之后，就暂停一下，检查工作效果。
  - 为了方便以后新增需求，编写的代码，应该具有良好的可扩展性。
  - 为了多年之后，这段代码还能被人看懂，应该将代码写得尽量容易理解，并加上注释。
  - 不要随便重构代码，这要花费很大代价，甚至代价可能超过重新开发整个软件。
  - 编写软件时，首先实现功能，然后才考虑性能。
    - 甚至，可以不考虑性能，只留下可扩展的代码，以后有需要时再花时间优化性能。
    - 在一个软件的开发初期，需求可能变化，代码架构可能大改，此时优化性能，可能做无用功。
  - 为了编写健壮的软件，
    - 将一个复合功能，分解成多个基础功能，便于单独修改、单元测试。
    - 一个软件被第三方调用时，应该不信任外部的输入值，总是加一段代码来检查输入值是否合理。毕竟第三方可能恶意攻击。
    - 一个软件调用第三方时，应该不信任第三方的输出值，总是加一段代码来检查输出值是否合理。
    - 严谨的情况下，假设每个环节都可能出现异常，然后编写一些代码来处理这些异常。例如调用一个函数的耗时太久怎么办？

- 测试时
  - 建议给软件编写很多自动化测试脚本。这样每次修改软件，都可以立即测试，检查软件能否正常工作，更放心。

## 软件版本

- 每次给软件发布一个版本时，版本名称应该采用什么格式？
  - 简单的软件，可以采用当前日期，作为版本名称。例如 `20220101`
    - 优点：容易看出这个版本是什么时候发布的。
  - 复杂的软件，建议采用语义化版本，让人大致看出这个版本的改动幅度有多大。格式如下：
    ```sh
    主版本号.子版本号[.修订版本号[.编译版本号]]
    ```
    - 如果新版本，不再兼容某些旧 API ，则将主版本号递增。（递增的同时，将右侧的各个版本号复位为 0 ）
    - 如果新版本，新增了功能、特性，但依然兼容所有旧 API ，则主版本号不变，子版本号递增。
    - 如果新版本，没有新增功能、特性，只是修改了一些代码（通常是为了修复一些 bug ），则将修订版本号递增。
    - 如果同一版本的代码，进行了多次编译（比如针对 Linux、Window 平台分别编译一次），则使用不同的编译版本号。

- 在软件的开发流程中，可以使用几种版本代号：
  ```sh
  α, alpha              # 表示该版本只是一个初步完成品，通常有很多 bug 。因此该版本只用于内部测试，不建议客户使用
  β, beta               # 消除了严重错误，可以提供给部分用户试用，即公开测试
  RC, Release Candidate # 候选发布版，公开测试一段时间，如果没有发现问题，就晋升为 release 版本
  release               # 正式发布的版本
  ```

- 企业在售卖软件时，可以提供多种版本，售价不同：
  ```sh
  standard              # 标准版，提供了软件的基本功能，满足普通用户的需求
  professional          # 专业版，在标准版的基础上增加了一些高级功能，满足专业用户的需求
  enterprise            # 企业版，提供该软件的所有功能。可能按该企业的用户数量收费
  ```

## 设计模式

- 开发一款软件时，需要设计软件的架构、基本原理。对此，人们总结了一些常用的架构，称为设计模式（design pattern）。
  - 一种设计模式，可能擅长处理某种问题，但不适合处理其它类型的问题。
  - 学习、借鉴前人的设计模式，可以帮助自己开发出更好的软件。也可以自己总结出新的设计模式。

### 模块化

- 模块化（modularity）
  - ：将软件的每个主要功能，用一块独立的代码实现。
  - 假设一个软件，将所有功能写在一个函数里。如果改为模块化，则编写多个函数，分别实现一个功能。
  - 在模块化的基础上，还应该追求以下效果：
    - 单一职责原则（Single Responsibility Principle，SRP）
      - ：每个模块只负责实现一个功能，不多管闲事，从而简化每个模块包含的代码。
      - 如果一个模块实现了多个功能，则建立拆分成多个模块。除非这个模块的代码量较少，容易被人看懂。
    - 高内聚（High Cohesion）
      - ：将实现一个功能的相关代码，都写到同一个模块中，从而集中到同一个命名空间，方便相互调用。
      - 假设实现功能 A 时，需要先后调用模块 1 、模块 2 ，并且两个模块只负责实现功能 A 。则这样属于单一职责、低内聚。
    - 低耦合（Low Coupling）
      - ：减少各个模块之间的联系，使得每个模块可以独立运行，互不干扰。
      - 假设一个模块函数，输入函数参数就可以让它独立运行，不管其它模块是什么状态，则耦合度低，甚至无耦合。
      - 假设一个模块函数，运行时必须依赖另一个模块函数，则耦合度高。如果不能减少两者的耦合度，可以考虑将两者合并为一个模块。
  - 优点：
    - 可以将一个复杂的软件，拆分成许多个简单模块，逐个开发，从而简化软件的开发过程。
    - 开发了软件的第一个版本之后，还可以多次修改、发布新版本，可扩展性好。
      - 想修改软件的某个功能时，只需修改实现该功能的那个模块，不需要改动大量模块。
      - 想给软件增加、减少一个功能时，只需增加、减少一个模块，不需要改动大量模块。
    - 模块之间可以隔离风险。一个模块故障时，其它模块可以继续正常工作，除非相互耦合。

### 面向对象

- 面向对象编程中，提倡 SOLID 五大原则：
  - 单一职责原则
    - ：每个类只有一个职责。或者说只有一个主要职责，附加一些次要职责（比如打印日志）。
    - 假设已经有一个类 File ，用于读写磁盘文件，专注于提供 read()、write() 方法，
      - 如果想处理文件的路径，提供 split()、exists() 等方法，则应该新建一个类 Path ，而不是直接修改类 File 。
      - 如果想解析 JSON 等格式的文件，提供 parse()、dump() 等方法，则应该新建一个类 Json ，而不是直接修改类 File 。
  - 开闭原则（Open–Closed Principle）
    - ：每个模块正式发布之后，允许扩展其功能（持开放态度），不允许修改其源代码（持封闭态度）。
    - 例如往软件中添加一个类 A ，被类 B 调用。
      - 如果想扩展类 A 的功能，则不应该直接修改类 A ，否则可能影响类 B 的正常工作。
      - 可以继承类 A ，定义一个子类，实现新功能。
    - 理想的情况下，每个模块正式发布之后，永远不会修改其源代码，除非需要修复 bug 。
  - 里氏替换原则
    - ：子类应该兼容父类的所有 API 。
    - 假设执行代码 `A.method1()` ，调用对象 A 的一个方法。则将对象 A 改为子类对象时，这行代码也应该正常工作。
    - 一般情况下，子类会继承父类的所有成员，因此符合该原则。如果子类重写了父类的某个方法，则可能违背该原则。
  - 接口隔离原则
    - ：如果一个 API 实现了多种功能，则应该拆分成多个 API ，分别实现一种功能，从而进一步模块化。
  - 依赖倒置原则
    - ：几个类之间相互调用时，尽量只调用抽象接口，而不是具体接口，从而方便未来进行扩展。
    - 假设一个类，提供的接口全是具体接口，则可以将它改造为抽象类，然后在子类中编写具体接口。调用时，不直接调用子类的具体接口，而是调用父类的抽象接口。

- 组合优于继承
  - ：组合使用多个类时，尽量减少它们之间的继承关系。
  - 组合、继承都能提高代码的复用性，但组合能避免类之间的耦合。
  - 继承会破坏子类和父类的封装（导致它们的成员混合在一起），导致父类与子类高度耦合。

### 生产/消费

- 用途：
  - 在几个程序之间，传输消息。
- 架构：
  - 运行一个代理（broker），负责暂存一定数量的消息。
    - broker 可以是程序里的一个数组变量，也可以是程序外的一个数据库，或者其它存在。
    - 人们开发了一些擅长担任 broker 的软件，比如 ActiveMQ、Kafka ，它们统称为 MQ（Message Queue ，消息队列）。
    - 从客户端/服务器模式来看，producer 与 consumer 都属于客户端，而 broker 属于服务器。
  - 运行一个程序，担任生产者（producer），将消息发送到 broker 。
  - 运行另一个程序，担任消费者（consumer），从 broker 获取消息。
- 优点：
  - 一对多通信。
    - producer 将消息发送到 broker 之后，这些消息可以被一个或多个 consumer 获取。
    - 如果 producer 与 consumer 直接通信，则通常只能一对一通信。
  - 解耦。
    - producer 与 consumer 之间没有直接调用，因此两者没有直接耦合，只是分别与 broker 耦合。
  - 隔离故障域。
    - producer 或 consumer 故障时，另一方依然可以正常访问 broker 。
  - producer 与 consumer 异步工作，不必等待对方的工作进度。
    - 如果 producer 与 consumer 直接通信，则 producer 每发送一条消息，需要等待 consumer 接收该消息，才能发送下一条消息。
  - 削峰。
    - 即使 producer 突然发送了很多消息，consumer 也依然是按照自己的速度从 broker 获取消息，不怕 consumer 的负载过大。
- 缺点：
  - 增加了系统的复杂度，需要多考虑一个 broker 中间件。
  - 处理消息的延迟可能很大。
    - 如果 broker 堆积的消息很多，则 consumer 需要获取多条消息，才能拿到最新的那条消息。换句话说，最新的那条消息，在 broker 中等了一段时间，才被 consumer 获取。
    - 有的软件追求实时性，希望一旦出现消息，就被立即处理。
