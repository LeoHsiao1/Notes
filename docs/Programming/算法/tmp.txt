
算法
## 算法是指解决问题的方法，是编程的核心。
- 数据结构和算法都是独立于编程语言的概念，选择好的数据结构和算法可以提高程序运行的效率。
- 算法可以用伪代码、流程图等方法描述。
- 一个算法应该具备以下特点：
  - 有输入和输出
  - 可行性：可以通过编程实现。
  - 确定性：每一步操作的含义都是确定的。对于一种输入，只会得到一种输出值。
  - 有穷性：执行的操作数是有限的，会在一段时间内完成。
## 评价算法性能的主要标准是时间复杂度和空间复杂度。
- 空间复杂度：算法运行时占用的内存大小。
- 时间复杂度：算法的运行时间。
  - 忽略计算机硬件性能的差异，因为算法的运行时间与算法中简单操作的次数成正比，一般设问题规模为n，用简单操作的次数f(n)来表示算法的时间复杂度。
  - 简单操作包括各种运算、流程转向、返回值、输入和输出等。
  - 如下，for语句中i<n循环了n+1次，i++、s+=b循环了n次。另外每次进行i>=n的比较后都要选择执行循环体还是结束循环，这个流程转向也是一个简单操作。综上，该for语句的简单操作次数为4n+2，整个函数的时间复杂度为f(n)=4n+4。
int sum(int b, int n){
  int i, s = 0;            // 定义语句int i不算简单操作
  for(i=0; i<n; i++)
    s += b;            // 复合赋值运算符也只算一次简单操作
  return s;
}
  - 一般只考虑算法时间复杂度的数量级（order），但不是以十进制作为一个数量级，而是当两个数相除的极限值不是无穷小0或无穷大∞时就属于同一级。例如上述算法的数量级可简记为O(n)，其它常见的数量级还有O(n^2)、O(n!)等。特别地，O(1)表示时间复杂度为常数，即与问题规模n无关。
-
##
## 基本算法。
- 递归：定义函数时，在函数体中调用该函数本身。
  - 递归通常是让函数一次只处理一个步骤或一个层级的事务，然后调用函数自己，传入本次的处理结果，去处理下一个事务。
  - 由于每次调用都会创建参数的副本，递归层次变多时占用内存就会过大。
  - 递归的算法复杂度可能较高。
  - 当递归层数太多时会导致栈溢出，因为编译器要多次将运行时的上下文入栈保存。因此问题有很多层时，不能用递归算法。
- 动态规划法：像递归一样处理一系列类似的事务，但还会存储每个事务的处理结果，以便于在遇到处理过的事务时直接复用。
  - 与递归算法相比，没有函数递归层数的限制，但问题层数过多时，存储中间结果也需要大量内存。可以退而求其次，不存储所有中间结果，只存储足以继续运算的少量计算结果，从而节省内存开销。
- 遍历（traversal）：按某个顺序，逐个访问一个集合中的所有元素。
- 迭代：反复执行某一段代码，以逐渐达到某个目的。
  - 编程时有两种方法可实现迭代：使用循环、使用递归。




## 待做的算法


### 判断质数

```py
# 通过循环，检查每一个小于 n 的数，能否对 n 整除
def is_prime(n:int=1):
    if not isinstance(n, int) or n <= 1:
        return ValueError('The number entered must be a integer and greater than 1')
    for i in range(2, n):
        if n % i == 0:
            print(f'{n} is divisible by {i}')
            return False
    return True

>>> is_prime(17)
True
>>> is_prime(18)
18 is divisible by 2
False
```

### 爬楼梯问题

问题：假设有n层的台阶，一開始你站在第0层，每次能够爬上一层或两层。请问爬完楼梯有多少种不同的方法？
解析：假如有一层楼梯，那就只有一种方案。两层楼梯2种。3层楼梯时，先走一步，剩下两层我们算过了就是2；先走2步，剩下一层我们也算过了就是1

这题可以采用动态规划的算法，先找出状态、状态转移方程：
状态：假设还剩 i 层，将走法数量记作 f[i]
状态转移方程为：f[i] = f[i-1] + f[i-2]
这就是斐波那契数列

```py
# 动态规划法：从第一位往后依次计算：f(0),f(1),f(2)...f(n) ，通过循环来迭代计算每一位，通过一个字典存储每一位的计算结果
def get_nums(n: int = 0):
    if not isinstance(n, int):
        return ValueError('The number entered must be a integer')
    cache = {}
    for i in range(n+1):
        if i <= 0:
            cache[0] = 1
        elif i == 1:
            cache[i] = 1
        else:
            cache[i] = cache[i-1] + cache[i-2]
    return cache[n]

# 动态规划法：只暂存最少数量的计算结果，节省内存开销
def get_nums(n: int = 0):
    for i in range(n+1):
        if i <= 0:
            result = 1
            pre_2  = 0
            pre_1  = result
        else:
            result = pre_1 + pre_2
            pre_2 = pre_1
            pre_1 = result
    return result

# 递归法：从最后一位往前倒推：f(n),f(n-1),f(n-2)...f(0) ，通过递归函数来迭代计算每一位
def get_nums(n: int = 0):
    if n <= 0:
        return 1
    elif n == 1:
        return 1
    else:
        return get_nums(n-1) + get_nums(n-2)


>>> get_nums(20)
10946

```





 
## 查找算法


## 顺序查找是从线性表的第一个元素开始逐个与特定元素比较，若相等则查找成功。采用链式存储结构的线性表或无序的线性表都只能使用顺序查找。
## 二分法查找是先将线性表的中间元素与特定元素比较，若相等则查找成功，若中间元素较小则在线性表的后半部分重复该操作，若中间元素较大则在线性表的前半部分重复该操作。二分法仅适用于采用顺序存储结构的、非递减排列的有序线性表。设线性表长度为n，最坏的情况下要比较log2n次。
##
##
##
##
##
##
##
##
##
##
##
 
排序算法
##
##
##
## 冒泡排序法是从表头开始，逐个比较相邻元素的大小，若前者大于后者，则互换位置，最终使得最大项在线性表的末尾，循环该操作，每次循环都使当前的最大项移到表末，而下一次循环就少比较一次。最坏的情况下要比较n(n-1)/2次。"冒泡"一词是形容最大的元素会像水泡一样慢慢浮到线性表的顶端。
## 快速排序法一般取线性表的第一个元素与其它元素比较排序，使得左边的元素都小于等于它，右边的元素都大于它，然后对两边元素不停重复该操作。
## 冒泡排序法和快速排序法都属于交换类排序法。



计算机可通过软件、硬件来生成随机数，统称为随机数生成器（Random Number Generator，RNG），分为两类：
- 伪随机数（pseudorandom number generator，PRNG）
  - ：数值可能被预测。
  - 比如计算机可以根据某种算法生成随机数，但结果可能被预测。
- 真随机数（true random number generator）
  - ：数值不能被预测。
  - 计算机可以根据某些人类无法预测的物理现象，生成随机数。比如电流噪声、量子力学。
    - 从物理现象提取随机数的过程通常耗时较久，可以提取少量数值作为随机种子（seed），再根据伪随机算法生成大量随机数。这样的随机性很高，接近真随机数。
