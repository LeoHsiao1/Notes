::: v-pre



##
##
##

元类
- Python3中，所有类都隐式地继承object类。
## 一般的类实际上是type类的实例。当Python解释器执行到class定义语句时，实际上是调用type()创建该类。
- 在代码中可用type()动态创建类，使程序更加灵活。
## class type(name: str, bases: Tuple[type, ...], dict: Dict[str, Any]) -> a new type
- 功能：创建一个类。（实际上是type类的实例）
- name参数是类名，bases参数是一个包含所有父类的元组，dict参数是一个包含所有方法名及其绑定的函数的字典。
- 例：
>>> Test = type("Test", (int,), {"fun1": fun1})
>>> Test
<class '__main__.Test'>
>>> Test().fun1()
hello
  - 相当于以下定义：
class Test(int):
    def fun1(self):
        print("hello")
## 元类：继承自type类，可用于创建其它类。
- 使用元类可以方便地初始化其它类，设置成员，比setattr()更方便。
  - 创建一个类时，Python解释器会优先用它或它父类的元类来创建它，如果没有元类则用type()来创建它。
- 例：
>>> class Mymeta(type):
...     def  __new__(cls, name, bases, attrs):
...         attrs["fun1"] = lambda self: print("hello")
...         return super().__new__(cls, name, bases, attrs)
...
>>> class Test(metaclass=Mymeta):
...     pass
...
>>> Test().fun1()
hello
##
##
##

迭代器
## 迭代：遍历某个对象中的所有元素。
- 不同的容器实现了迭代器接口之后，就可以使用相同的API进行遍历。
## 可迭代对象（iterable）：具有__iter__()方法。可以被for语句遍历，不能被next()遍历。
- __iter__()：返回一个迭代器。
  - for语句在遍历可迭代对象时，就是先调用对象的__iter__()方法，获得迭代器。
  - 例：
>>> list1 = [1, 2, 3]
>>> list1.__iter__()
<list_iterator object at 0x7fa01109d048>
>>> next(list1.__iter__())
1
## 迭代器（iterator）：具有__iter__()、__next__()方法。可以被for语句、next()遍历。
- Python中的迭代器属于单向只读迭代器：只能向前遍历，不能后退。
  - 大部分迭代器遍历完所有元素之后就停止迭代，也可以创建无限循环的迭代器。
  - 迭代器只能通过迭代获取其中的元素，不能进行索引。
- __next__()：返回迭代器中的下一个元素，如果没有下一个元素则抛出异常StopIteration。
  - 例：
>> class Number:
...     def __init__(self):
...         self.a = 0
...     def __iter__(self):
...         return self
...     def __next__(self):
...         if self.a < 10:             # 最多迭代10次
...             self.a += 1
...             return self.a
...         else:
...             raise StopIteration
...
>>> n = Number()
>>> next(n)
1
>>> next(n)
2






## 相关函数。
- def iter(iterable) -> iterator
  - 功能：将一个可迭代对象转换成迭代器。实际上是调用对象的__iter__()方法。
  - 例：
>>> iter("Hello")
<iterator object at 0x7f19cd6e6810>
>>> list(iter("Hello"))
['H', 'e', 'l', 'l', 'o']
- def next(iterator, default=...) -> object
  - 功能：获取迭代器中的下一个元素。如果不存在则报错，或者返回default参数。
  - 实际上是调用对象的__next__()方法。
  - 例：
>>> i = iter("Hello")
>>> next(i)
'H'
>>> next(i)
'e'
##
##
##

生成器
## 生成器（generator）：Python特有的一种迭代器。
- 使用yield关键字给出函数的返回值时，函数会返回一个生成器。
  - yield的用法与return类似。函数执行到yield语句时会中断函数并返回一个生成器，当迭代生成器的下一个元素时，会让函数从中断处继续执行。
  - 优点：可以中断函数，让函数在需要时才继续执行，有利于节省CPU和内存、控制函数运行。
  - 例：
>>> def fun1():
...     print("step 1")
...     yield 1
...     print("step 2")
...     yield 1, 2
...     print("step 3")
...
>>> g = fun1()
>>> g
<generator object fun1 at 0x7fa011114678>
>>> next(g)
step 1
1
>>> next(g)
step 2
(1, 2)
>>> next(g)
step 3
StopIteration
- 使用推导式的语法也可以创建生成器。
>>> g = (i for i in range(100000))        # 不会一次创建所有元素，而是每次迭代后才创建下一个元素
>>> g
<generator object <genexpr> at 0x7fa011114678>
>>> next(g)
0
>>> next(g)
1


为什么使用推导式？通常是为了减少开销，提高 Python 程序的性能。
- 假设存在一个 iterable 对象，占用 100MB 内存空间。现在想将 iterable 中每个元素转换成 str 类型。
  - 如果使用列表推导式 `result = [str(i) for i in iterable]` ，此时 result 也会占用 100MB 内存，加上 iterable 就占用 200MB 内存。
  - 如果使用生成器推导式 `result = (str(i) for i in iterable)` ，此时 result 同时只获取一个元素，几乎不占用内存。

- 除了内存开销，还需要考虑时间开销。
  - 假设遍历 iterable 对象的全部元素，耗时较久（比如几分钟）。等遍历完成之后，才开始处理这些元素，导致用户需要等一段时间才能看到处理结果。
    ```py
    result = [str(i) for i in iterable] # 这一步可能耗时较久
    for i in result:
        print(i)
    ```
  - 而使用生成器，可以每获取一个元素，就立即处理。从而更早地让用户看到处理结果，虽然并不能减少整体耗时。
    ```py
    result = (str(i) for i in iterable) # 这一步几乎没有耗时
    for i in result:
        print(i)
    ```



异常处理
## Python程序的错误分为两种。
- SyntaxError：语法错误，在编译时报出错误。
- exception：异常，在运行时被抛出。
  - 除了语法错误，其它的都算异常。
  - 变量未定义、数据类型不符合要求等问题在运行时才能发现，不属于语法错误。
## 使用try-except语句可以捕捉异常。
- 其语法为：首先执行try语句块，如果有异常抛出，则立即执行异常名与其匹配的except语句块。如果没有与其匹配的except，该异常就会被抛出。
- 例：
try:
x = int(input("Please enter a number: "))
except Exception as e:                # 捕捉一个Exception类的异常并实例化成对象e
print(str(e))                    # 显示用str()提取的简要异常信息
except (RuntimeError, TypeError):        # 一个except可以捕捉多种异常
print("RuntimeError / TypeError")
except :                                # 最后一个except可以不设异常名，从而匹配所有类型的异常
print("Unexpected error:", sys.exc_info()[0])
raise        # 将异常抛出
else:            # 可以在try-except语句后加上一个else语句，没有发生异常时就执行该语句块
pass
finally:            # 可以在try-except语句后加上一个finally语句，不管是否发生异常都会执行该语句块
pass            # 即使有return语句，也会在return之前先执行finally语句块
## 用关键字with可以实现try-finally的作用，保证在执行语句块时一定会执行某种操作。
- 如下，定义一个支持with操作的类，使用with时会调用类的__enter__()方法，当语句块执行结束或出现异常时会调用类的__exit__()方法。
- 例：
>>> class Test():
...     def __enter__(self):
...         return self
...     def __exit__(self, type, value, trace):
...         print("exit")
...
>>> with Test() as t:
...     print("inside")
...
inside
exit

- 例：
class Test:
    def __init__(self, filename, mode='r'):
        self.filename = filename
        self.mode = mode
    def __enter__(self):
        self.f = open(self.filename, self.mode)
        return self.f
    def __exit__(self, *args):   # 抛出异常时会传入异常名、异常内容、traceback对象
        self.f.close()

with Test("1.txt") as t:
    t.read()
  - 执行with Test("1.txt")时，Python解释器会先创建对象f=Test("1.txt")，然后调用f.__enter__()。当执行完with语句块或者抛出异常时，就调用f.__exit__()。


## 抛出异常。
- 使用“raise X”的格式可以主动抛出一个异常。X可以是一个异常类或者异常的实例。
- 在 except 语句块中，单独使用关键字raise ，会抛出已捕捉的异常。
>>> raise NameError
NameError
>>> raise NameError('test...')
NameError: test...
- 使用关键字assert可以写一个断言，当表达式结果为假时则抛出AssertionError异常。
>>> assert 1 == 0
AssertionError
>>> assert 1 == 0, "not equal"        # 可以给该异常加上描述信息
AssertionError: not equal
## BaseException：所有异常类的基类。
- SystemExit
- KeyboardInterrupt
- GeneratorExit
- Exception：Common base class for all non-exit exceptions.
  - EOFError        ：Read beyond end of file
  - ImportError    ：Import can't find module, or can't find name in module.
  - NameError    ：Name not found globally.
  - OSError        ：Base class for I/O related errors.
  - KeyError        ：字典中没有该key。
  - AttributeError：对象没有该属性。
  - RuntimeError    ：Unspecified run-time error.
  - SystemError    ：Python解释器的内部错误。
  - TypeError    ：参数的数据类型错误。
  - ValueError    ：参数的值错误（数据类型正确）。
  - Warning        ：Base class for warning categories.
## 下例是自定义一个异常类：

class MyException(Exception):
    def __init__(self, msg=''):
        self.msg = msg

    def __repr__(self):
        return 'MyException({})'.format(repr(self.msg))

    def __str__(self):
        return self.__repr__()

>>> raise MyExcept
__main__.MyExcept
>>> raise MyExcept('test...')
__main__.MyExcept: test...
##
##
##

其它知识
pass 和 ...
## pass在Python中是一个关键字，可用于填补语句块的空缺。
- 例：
>>> def fun1():
...     pass
...
## 省略号...在Python中是一个属于ellipsis类的单例对象Ellipsis，其布尔值为True。
>>> ...
Ellipsis
>>> type(...)
<class 'ellipsis'>
>>> bool(...)
True
- ...可以替代pass填补语句块的空缺。
>>> def fun1():
...     ...
...
- ...可以用于赋值。
>>> x = ...
>>> x
Ellipsis
  - 而pass是一个关键字，不能用于赋值。
>>> x = pass
SyntaxError: invalid syntax
- 当对象中的某个元素是对自身的循环引用时，会被解释器替代为...。
>>> list1 = [1, 2, 3]
>>> list1.append(list1)
>>> list1
[1, 2, 3, [...]]
>>> list1[3]
[1, 2, 3, [...]]
>>> list1[3][3]
[1, 2, 3, [...]]
  - 但直接用list1赋值时，不会造成循环引用。
>>> list1 = [1, 2, 3]
>>> list1 = [1, 2, 3, list1]
>>> list1
[1, 2, 3, [1, 2, 3]]
##
##
##

内置函数
## Python解释器启动时会自动导入builtins模块，它提供了一些内置函数。
##
##
##

关于底层
## def id(object) -> int
- 功能：返回对象的唯一ID。
  - 在CPython中是把对象的内存地址转换成十进制，作为ID。
- 例：
>>> id(1)
140706485723792
>>> x = 1; id(x)
140706485723792
## def help(object)
- 功能：返回对象的帮助文档（包括Python的帮助文档、源代码的说明文档）
- 例：
>>> help(id)
Help on built-in function id in module builtins:...
>>> x=1; help(x)
Help on int object:...
## def callable(object) -> bool
- 功能：判断一个对象是否可以调用（是否为函数名或类名）。
- 例：
>>> callable(10)
False
>>> callable(int)
True
## def globals() -> dict
- 功能：返回一个字典，包含所有全局变量。
- 例：
>>> globals()
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>}
## def locals() -> dict
- 功能：返回一个字典，包含当前作用域的所有局部变量。
- 例：
>>> def fun1():
...     x = 1
...     print(locals())
...
>>> fun1()
{'x': 1}
##
## def repr(obj) -> str
- 功能：返回对象的__repr__()方法的返回值。
- 当对象A在终端被打印时，显示的值就是 print(A.__repr__())
- 例：
>>> repr(3.14)
'3.14'
>>> repr(int)
"<class 'int'>"
>>> repr('Hello')        # 如果对象本来就是字符串类型，则会加上引号
"'Hello'"
>>> repr(b'Hello')
"b'Hello'"
##
##

关于执行代码
## def exec(src, globals=..., locals=...) -> None
- 功能：执行一段代码。
- 例：
>>> exec("1+2")
>>> exec("a=0")
>>> a
0
- 执行时可以访问外部变量：
>>> a = 1
>>> exec("print(a)")                        # 默认使用当前作用域的可用变量
1
>>> exec("print(a)", {"a":2})                # 可以给定变量
2
>>> exec("print(a)", globals(), locals())    # 传入当前的全局变量、局部变量
1
## def eval(src, globals=..., locals=...) -> object
- 功能：执行一段代码，返回其结果。
- 例：
>>> eval("1+2")
3
>>> eval("int")                    # 返回值是某个对象的引用，不是单纯的字符串
<class 'int'>
>>> eval("print('hello')")        # 返回值可以来自stdout
hello
>>> eval("a = 1")                    # 不能执行赋值语句
    a = 1
      ^
SyntaxError: invalid syntax
>>> eval("print(1);print(2)")        # 只能执行一条语句，返回一个结果
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1
    print(1);print(2)
            ^
SyntaxError: invalid syntax
## def compile(src, filename, mode) -> code
- 功能：将字符串编译成code对象，可以被exec()或eval()执行。
- 例：
>>> code = compile("print(1+2)", '<string>', "eval")
>>> eval(code)
3
##
##
##

关于类
## class type(object) -> className
- 功能：返回对象的类型（即类名）。
- 例：
>>> type(1)
<class 'int'>
>>> type(int)        # 一般的类实际上是type类的实例
<class 'type'>
>>> type(object)
<class 'type'>
## def isinstance(object, type) -> bool
- 功能：判断一个对象是否是某个类的实例。
- type参数可以是一个类名，或者一个包含多个类名的元组。
- 例：
>>> isinstance(1.0, int)
False
>>> isinstance(1.0, (int, float))
True
## def issubclass(cls, another_cls) -> bool
- 功能：判断一个类是否是某个类的子类或同一个类。
- another_cls参数可以是一个类名，或者一个包含多个类名的元组。
- 例：
>>> class Test(int):
...     pass
...
>>> issubclass(Test, int)
True
>>> issubclass(Test, Test)
True
>>> issubclass(Test, (float, str))
False
## class super(type, object) -> superclass
- 功能：获取一个对象的父类。
- type是一个类名，object是该类或其子类的一个实例。例如，
- 例：
>>> super(int, 1)            # 获取int类在实例1的MRO列表中的下一个父类
<super: <class 'int'>, <int object>>
- 下例是调用父类的构造方法：
>>> class Test(int):
...     def __init__(self):
...         super(Test, self).__init__()    # 在Python3中可将super(Test, self)简写为super()
...
>>> Test()
0
##
##
##

关于类的成员
## 反射：根据类的成员的名称字符串，获得它的引用。
- 使用反射可以让Python程序在运行时更加动态。
## def dir(object=...) -> list of strings
- 功能：查看对象的所有成员，返回一个字符串列表。
- 不输入object参数时，返回当前作用域的所有可用标识符。
- 例：
>>> dir(1)
['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', ...]
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']
## def getattr(object, name:str, default=...) -> attribute
- 功能：获取对象的某个成员。如果不存在则报错，或者返回default参数。
- 例：
>>> getattr(str(), "encode")
<built-in method encode of str object at 0x000002ACBA2F7CE0>
>>> getattr(str(), "len")
AttributeError: 'str' object has no attribute 'len'
## def hasattr(object, name:str) -> bool
- 功能：判断对象是否拥有某个成员。
- 实际上是调用getattr()并捕捉异常。
- 例：
>>> hasattr(str(), "encode")
True
>>> hasattr(str(), "len")
False
## def setattr(object, name:str, value) -> None
- 功能：设置对象的某个成员，实际上是更改它的引用。
- 例：
>>> class Test:
...     def fun1(self):
...         print("this is fun1")
...
>>> def fun2():
...     print("this is fun2")
...
>>> t = Test()
>>> setattr(t, "fun1", fun2)        # 相当于t.fun1 = fun2
>>> t.fun1()
this is fun2
## def delattr(object, name:str) -> None
- 功能：删除对象的某个成员。
- 例：
>>> delattr(str(), "encode")
AttributeError: 'str' object attribute 'encode' is read-only
##
##
##

关于迭代
## class range(stop: int) -> iterable
class range(start: int, stop: int, step: int=...) -> iterable
- 功能：生成一个等差数列。从start开始、到stop结束（不包含stop所在位），步进值为step。这些参数可以是负数。
- 例：
>>> range(5)                    # range()的返回值不是列表，要像迭代器一样遍历
range(0, 5)
>>> list(range(5))            # 生成一个在 [0, 5) 区间的等差数列
[0, 1, 2, 3, 4]
>>> list(range(1, 5))            # 生成一个在 [1, 5) 区间的等差数列
[1, 2, 3, 4]
>>> list(range(-1, -10, -2))    # 生成一个在 [-1, -10) 区间、步进值为-2的等差数列
[-1, -3, -5, -7, -9]
- 以下情况中，range()生成的等差数列为空。
>>> list(range(0))
[]
>>> list(range(-1))
[]
>>> list(range(5, 1))
[]
>>> list(range(1, 10, -2))
[]
## class enumerate(iterable, start=0) -> iterator
- 功能：枚举一个可迭代对象，返回一个迭代器。每次迭代返回一个元组 (n, iterable[n]) ，包含序号 n 和第 n 个元素。
- 常用于生成带序号的序列。
- 例：
>>> list(enumerate("Hello"))
[(0, 'H'), (1, 'e'), (2, 'l'), (3, 'l'), (4, 'o')]
## def sorted(iterable, key: callable=None, reverse=False) -> list
- 功能：将一个可迭代对象中的所有元素进行排序，放在一个list中返回。
- 默认直接比较各个元素的大小，可以通过key参数生成一个值再比较大小。
- 默认reverse=False，按升序排序，即后一项比前一项大。
- 例：
>>> list1 = [3, 2, 4, 5]
>>> sorted(list1)
[2, 3, 4, 5]
>>> sorted(list1, key=lambda x:-x)
[5, 4, 3, 2]
>>> sorted(list1, reverse=True)
[5, 4, 3, 2]
- 对字典进行排序：
>>> dict1 = {1:'c', 2:'b', 3:'a'}
>>> sorted(dict1)                                        # 对key进行排序
[1, 2, 3]
>>> sorted(dict1.items(), key=lambda x: x[1])            # 按value进行排序
[(3, 'a'), (2, 'b'), (1, 'c')]
>>> dict(sorted(dict1.items(), key=lambda x: x[1]))        # 排序后再转换成dict
{3: 'a', 2: 'b', 1: 'c'}

- 默认是用 < 比较各个元素的大小，而数字与 str 之间，不允许比较运算。
>>> ['A', 'a'].sort()
>>> [1, 'A', 'a'].sort()
TypeError: '<' not supported between instances of 'str' and 'int'


## def zip(*iterable) -> iterable[tuple]
- 功能：返回一个生成器，每次迭代取出各个iterable的第n项元素，组成一个元组返回。
- 例：
>>> zip(range(5))
<zip object at 0x7fa35d9d7fc8>
>>> list(zip(range(5)))
[(0,), (1,), (2,), (3,), (4,)]            # 每次迭代的返回值是一个元组
>>> list(zip(range(5), "Hellooo"))        # zip()可以迭代n次，n等于最短的那个可迭代对象的可迭代次数
[(0, 'H'), (1, 'e'), (2, 'l'), (3, 'l'), (4, 'o')]
>>> list(zip(*zip(range(5), "Hellooo")))        # zip(* )是zip的逆过程，可实现二维矩阵的转置
[(0, 1, 2, 3, 4), ('H', 'e', 'l', 'l', 'o')]
## def map(func, *iterable) -> iterable
- 功能：返回一个生成器，每次迭代会取出各个iterable的第n个元素，传给func函数执行，然后返回函数的返回值。
- 例：
>>> map(print, range(5))
<map object at 0x7fa35e250dd8>
>>> list(map(print, range(5), 'hello'))
0 h
1 e
2 l
3 l
4 o
[None, None, None, None, None]
- map()比zip()更灵活、功能更强。例如用它们实现二维矩阵的转置：
>>> list(zip([1, 2, 3, 4], [5, 6, 7]))
[(1, 5), (2, 6), (3, 7)]
>>> list(map(lambda x, y: (x, y), [1, 2, 3, 4], [5, 6, 7]))
[(1, 5), (2, 6), (3, 7)]
##
##
##

关于计算

幂运算
def pow(base, exp)    # 近似于 base**exp
>>> pow(2, 3)
8
>>> pow(2, -3)
0.125

## def len(object) -> int
- 功能：返回对象包含的元素个数，由对象的内置方法__len__()决定。
- 例：
>>> len("Hello")
5
>>> len([1, 2, 3])
3
>>> len({1:None, 2:None, 3:None})
3
## def abs(n)
- 功能：返回n的绝对值。
- 例：
>>> abs(-1)
1
>>> abs(-1.0)
1.0
## def round(number, digits=0) -> number
- 功能：将一个数字的小数部分四舍五入，只保留指定位数。
- 例：
>>> round(123.456)
123
>>> round(123.456, 2)
123.46
>>> round(123.456, 5)        # 保留的位数比实际位数多时，不会有影响
123.456
>>> round(123.456, -2)    # 保留-2位小数
100.0

def max(iterable, *_args, key: Callable) -> value
def max(arg1, arg2, *_args, key: Callable) -> value
- 功能：找出多个arg中最大的那个。
- 基于比较运算符 > 比较大小。
例：
>>> max()                                    # 必须传入参数
TypeError: max expected 1 arguments, got 0
>>> max(1)                                    # 只传入一个参数时，它必须是可迭代对象
TypeError: 'int' object is not iterable
>>> max([1, 2, 3])
3
>>> max(1, 2)
2
>>> max('a', 1)
TypeError: '>' not supported between instances of 'int' and 'str'
>>> max('a', 'b')
'b'‘
- 如果传入了key参数，max()不会直接比较arg1>arg2，而是比较key(arg1)>key(arg2)。
例：找出列表中出现频率最高的数字
>>> _list = [1, 2, 3, 2]
>>> max(set(_list), key=_list.count)
2

例：找出字典中value最大的key
>>> d = {'a': 1, 'b': 2, 'c': 3}
>>> max(d, key=d.get)
'c'

- 用 max() 可以找出最大的一个元素。那么如何找出最大的 n 个元素？可以用 `sorted(iterable)[:n]` ，先排序，再提取元素。


- min()函数的原理与max()类似，不过是找出最小值。

## def sum(iterable, start=0) -> value
- 功能：将可迭代对象中的各个元素相加求和。
- 例：
>>> sum(1)
TypeError: 'int' object is not iterable
>>> sum([1, 2, 3])
6
## def all(iterable) -> bool
- 功能：如果iterable中各个元素的bool值都是True，则返回True。
- 例：
>>> all([0])
False
>>> all([1, 2, False])
False
- 例外：如果iterable为空，则也返回True。
>>> all([])
True
## def any(iterable) -> bool
- 功能：如果iterable中有任意一个元素的bool值为True，则返回True。
- 例：
>>> any([])
False
>>> any([0])
False
>>> any([0, 1, 2])
True
##
##
##

常用模块

[Python 的内置模块列表](https://docs.python.org/3.8/py-modindex.html)

关于系统
♢ os
## os：Python的标准库，用于调用系统的API。
>>> import os
>>> os.name                    # 返回当前系统的接口类型，取值为'posix'或'nt'
'nt'
>>> os.abort()                # 终止Python解释器，且没有返回值
## 关于环境变量。
>>> os.environ.get("PATH")    # os.environ返回一个字典，包含当前的环境变量，可直接读写
'C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;...
>>> os.environ["DEBUG"] = "true"
## 关于进程。
>>> os.getpid()            # 获得当前进程的pid
18516
>>> os.getppid()            # 获得当前进程的父进程的pid
6484
>>> os.getlogin()            # 获得当前登录的用户名
'Will'


向进程发送终止信号：
>>> import signal
>>> os.kill(1106, signal.SIGKILL)

在 Windows 系统上不支持 signal.SIGKILL ，要使用 signal.SIGTERM 。





## 关于执行命令。
- os.system(cmd)：创建一个shell（属于当前进程的子进程），执行一条命令，并返回命令的返回码(int类型）。
  - 例如：
>>> os.system("echo hello")
hello            # 命令的stdout会输出到当前进程中
0                # 命令正常结束时的返回码为0
  - 可根据返回值是否为0来判断进程是否正常结束：
if not os.system("..."):
    print("done")
- os.popen(cmd, mode="r", buffering=-1)：在系统shell中执行一条命令，并以文件流的形式返回其stdout。
  - 读取模式可以是'r'或'w'。
  - buffering=-1表示采用系统默认的缓冲方式。
  - os.system()会阻塞当前进程，一直等到命令执行结束。而os.popen()是异步执行命令，如果用p.read()等方法进行交互，也会阻塞当前进程。
  - 例如：
with os.popen("ipconfig") as p:
    result = p.read()




## 关于文件路径。
>>> os.path.split('D:/1/2.py')        # 将一个文件路径分割成目录名和文件名
('D:/1', '2.py')
>>> os.path.split("D:/1/2.py/")        # 最后一个路径分隔符的右侧内容会被视作文件名
('D:/1/2.py', '')
>>> os.path.split("/")                # 处理根目录时，不会分割
('/', '')
>>> os.path.split("")
('', '')

>>> os.path.dirname("D:/1/2.py")        # 返回path的目录名
'D:/1'
>>> os.path.basename("D:/1/2.py")        # 返回path的文件名
'2.py'
>>> os.path.sep                        # 获得当前系统的路径分隔符
'\\'
>>> os.path.join('D:/1', '2.py')        # 用当前系统的路径分隔符，把目录名和文件名合成一个路径
'D:/1\\2.py'
>>> os.path.join('D:/1', 'test', '2.py')    # 可以输入多项参数，一起合并
'D:/1\\test\\2.py'
>>> os.path.abspath(".")                # 返回path的绝对路径
'D:\\1'
>>> os.path.relpath("D:/1", "D:/")        # 返回"D:/1"对于"D:/"的相对路径
'1'
>>> os.path.normpath("D:/1/")            # 将一个path正常化（并不会判断它是否有效），
'D:\\1'                                # 它会自动转换成当前系统的路径分隔符，并去掉path末尾的路径分隔符
>>> os.path.normpath("D://\\1////")    # 即使有多余的路径分隔符，也会自动处理
'D:\\1'
>>> os.path.normpath("")                # 如果输入的path是空字符串，则返回'.'
'.'


例：基于路径分隔符分割path
>>> path = 'D:/1/2.py'
>>> os.path.normpath(path).split(os.path.sep)
['D:', '1', '2.py']

## 获取目录信息。
>>> os.getcwd()                        # 获得当前的工作目录
'D:\\1\\'
>>> os.chdir("D:\\")                    # 切换到指定工作目录
- >>> os.listdir("D:\\")                # 列出指定目录下的所有文件和文件夹
['.vscode', '1.py', '__pycache__']        # 包括隐藏文件，但不包括 . 和 .. 两个特殊文件
  - os.listdir()不能列出子目录下的文件，而且遇到异常时（比如无权限访问某个目录）会立即中断。
- >>> os.walk(".", onerror=print)        # 列出指定目录下，各个目录中的文件和文件夹，返回一个生成器
<generator object walk at 0x000001CC520EBA98>
>>> for i in os.walk(".", onerror=print):
>>>     print(i)
>>>
('.', ['res', 'utils', '__pycache__'], [1.py', '__init__.py'])
('.\\res', ['img'], [])
('.\\res\\img', [], ['9.jpg', 'logo.ico'])
  - 生成器的每行元素为：目录、该目录下的文件夹列表、文件列表。
  - os.walk()默认会忽略遇到的异常，应该传入onerror参数，记录遇到的异常。
## 获取文件信息。
>>> os.path.exists("D:\\1")        # 判断文件是否存在
True
>>> os.path.isfile("D:\\1")        # 判断是否为普通文件
False
>>> os.path.isdir("D:\\1")        # 判断是否为目录
True
>>> os.path.getsize("D:\\1")        # 返回文件的大小（占多少字节）
4096
>>> os.path.getctime("D:\\1")        # 返回文件的创建时间
1546567973.6038435
>>> os.path.getatime("D:\\1")        # 返回文件的最后访问时间
1562806458.460649
>>> os.path.getmtime("D:\\1")        # 返回文件的最后修改时间
1562806458.460649
## 管理文件和目录。
>>> os.link(src, dst)                    # 创建硬链接，如果该文件已存在就会报错
>>> os.symlink(src, dst)                # 创建符号链接（不能在Windows上使用），如果该文件已存在就会报错
>>> os.rename(src, dst)                # rename a file or directory
>>> os.remove("D:\\1\\1.py")            # 删除文件
>>> os.mkdir("D:\\1")                    # 创建目录，若该目录已存在则抛出FileExistsError异常
>>> os.rmdir("D:\\1")                    # 删除目录（当目录不为空时会报错）
>>> os.makedirs("1/2/3")                    # 递归创建多层目录，若该目录已存在则报错
>>> os.makedirs("1/2/3", exist_ok=True)    # 若该目录已存在则不报错
- 给上述函数输入的path既可以是绝对路径，也可以是相对路径。
##
##
##

♢ sys
## sys：Python的标准库，提供了一些与Python解释器进行交互的方法。
- 例：
>>> import sys
>>> sys.path                # 查看搜索模块时采用的所有路径，第一个''的作用是指向当前目录
['','C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\Python37.zip', 'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\DLLs', 'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\lib', 'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32', 'C:\\Users\\Will\\AppData\\Roaming\\Python\\Python37\\site-packages', 'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\lib\\site-packages', 'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\lib\\site-packages\\win32', 'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\lib\\site-packages\\win32\\lib','C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\lib\\site-packages\\Pythonwin']
>>> sys.exit(1)            # 退出程序，并返回一个值
>>> sys.exit(1)
- >>> sys.getsizeof('a')    # 返回对象占用的内存大小
50
>>> sys.getsizeof('ab')
51
## 可以对stdin、stdout、stderr进行操作。
>>> sys.stdout
<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>
>>> sys.stdout.write("hello")
hello5
>>> sys.stdout.flush()
- 下例是重定向stout、stderr：
>>> f = open("stdout.txt", "w")
>>> sys.stdout = f
>>> sys.stderr = f
>>> print("hello")
>>> raise RuntimeError("testing...")
  - 如果想恢复原本的stdout、stderr，需要先备份：
>>> __stdout__, __stderr__ = sys.stdout, sys.stderr
##
##
##

♢ shutil
## shutil：Python的标准库，提供了一些拷贝文件的方法。
- 例：
>>> import shutil
>>> shutil.copy("D:/1.txt", "D:/1")            # 拷贝源文件，保存到目标目录下
'D:/1\\1.txt'                                # 执行成功之后会返回目标路径
>>> shutil.copy("D:/1.txt", "./1/2.txt")        # 拷贝源文件，保存为目标文件（目标文件已存在时会自动覆盖）
'./2.txt'

拷贝时的目标目录需要已经存在，否则容易出错。
如果目标目录"D:/1"已存在，则源文件会被保存为"D:/1/1.txt"；
如果"D:/1"不存在，或者为文件，则源文件会被保存为"D:/1"，即自动重命名为文件1；
如果目标路径为"./1/2.txt"，且上一级目录'./1/'不存在，则会直接报错，无法拷贝。


>>> shutil.copytree("D:/1", "D:/2")            # 拷贝源目录，保存为目标目录（目标目录已存在时会报错）
'D:/2'
>>> shutil.move("D:/1", "D:/2")                # 移动文件或目录
'D:/2'
##
##
##

♢ psutil
## psutil：Python的第三方库，用于查看系统的硬件信息、运行状态。
- 安装：pip install psutil
- 查看进程的信息。
>>> psutil.pids()                    # 返回所有进程的pid
[0, 4, 88, 120, 140, 344, 412, 532, 612, 628, 728, 800, 808, ……]
>>> psutil.pid_exists(0)            # 查看某个pid的进程是否还在运行
True
>>> psutil.Process(0)                # 得到某个进程的引用，从而可以访问该进程的各种方法
psutil.Process(pid=0, name='System Idle Process', started='2019-06-21 18:25:21')
>>> p = psutil.Process(4500)        # 使用psutil.Process(os.getpid())可获得当前进程的引用
>>> p.status()                    # 返回进程的状态
'running'
>>> p.terminate()                    # 终止进程
>>> p.name()                        # 返回进程的名字
'BaiduNetdisk.exe'
>>> p.exe()                        # 返回进程的可执行文件的路径
'C:\\Users\\Leo\\AppData\\Roaming\\baidu\\BaiduNetdisk\\BaiduNetdisk.exe'
>>> p.cwd()                        # 返回进程当前的工作目录
'C:\\Windows\\System32'
>>> p.cmdline()                    # 返回进程的启动命令
['C:\\Users\\Leo\\AppData\\Roaming\\baidu\\BaiduNetdisk\\BaiduNetdisk.exe']
>>> p.create_time()                # 返回进程的创建时间（为UTC时间戳）
1561193118.0
>>> p.username()                    # 返回启动该进程的用户名
'LEO\\Leo'
>>> p.terminal()                    # 返回启动该进程的终端
AttributeError: 'Process' object has no attribute 'terminal'
>>> p.cpu_percent(1)                # 阻塞1秒，然后返回这段时间内该进程的CPU使用率
15.6
>>> p.memory_info()                # 返回进程的内存使用信息
pmem(rss=63967232, vms=60678144, num_page_faults=554783977, peak_wset=107614208, wset=63967232, peak_paged_pool=809056, paged_pool=751528, peak_nonpaged_pool=109032, nonpaged_pool=66736, pagefile=60678144, peak_pagefile=62353408, private=60678144)
>>> p.connections()                # 查看进程使用的所有网络连接
[pconn(fd=-1, family=<AddressFamily.AF_INET: 2>, type=1, laddr=addr(ip='10.135.149.134', port=56855), raddr=addr(ip='153.37.235.47', port=5287), status='ESTABLISHED'), pconn(……]
>> p.open_files()                    # 查看进程打开的所有文件
[popenfile(path='C:\\Users\\Leo\\AppData\\Local\\Temp\\baidu\\BaiduYunGuanjia\\at_monhavior-shm', fd=-1), popenfile(……]
>>> p.num_threads()                # 查看进程启动的线程数
42
>>> p.threads()                    # 列出该进程启动的所有线程
[pthread(id=17336, user_time=2161.453125, system_time=12109.109375), pthread(……]
>>> p.parent()                    # 返回父进程的引用
psutil.Process(pid=4940, name='explorer.exe', started='2019-06-22 16:18:53')
>>> p.children()                    # 列出所有子进程
[psutil.Process(pid=1524, name='BaiduNetdiskHost.exe', started='2019-06-22 16:45:19'), psutil.Process(pid=9536, name='BaiduNetdiskHost.exe', started='2019-06-22 16:45:20')]
- 查看CPU的信息。
>>> psutil.cpu_count()                            # 查看CPU的核数（默认为逻辑核数）
8
>>> psutil.cpu_count(logical=False)                # 查看CPU的物理核数
4
>>> psutil.cpu_percent()                            # 查看所有CPU的平均使用率（从上一次调用到目前为止）
7.2
>>> psutil.cpu_percent(interval=1, percpu=True)    # 阻塞1秒，然后返回这段时间的各个CPU使用率
[20.6, 7.7, 10.8, 20.0, 12.3, 4.6, 10.8, 4.6]
>>> psutil.cpu_times_percent()                    # 查看CPU各方面的使用率（像Linux的uptime命令）
scputimes(user=3.2, system=4.0, idle=92.5, interrupt=0.2, dpc=0.2)
>>> psutil.cpu_stats()
scpustats(ctx_switches=3346114770, interrupts=2451502960, soft_interrupts=0, syscalls=2114761291)
- 查看内存的信息。
>>> psutil.virtual_memory()                        # 虚拟内存（像Linux的free命令，单位为bytes）
svmem(total=8424906752, available=2264326144, percent=73.1, used=6160580608, free=2264326144)
>>> psutil.swap_memory()                            # swap
sswap(total=15404228608, used=9708523520, free=5695705088, percent=63.0, sin=0, sout=0)
- 查看磁盘的信息。
>>> psutil.disk_partitions()                        # 查看各个磁盘分区的信息
[sdiskpart(device='C:\\', mountpoint='C:\\', fstype='NTFS', opts='rw,fixed'), sdiskpart(device='D:\\', mountpoint='D:\\', fstype='NTFS', opts='rw,fixed')]
>>> for x in psutil.disk_partitions():                # 提取磁盘分区的device名字
...     print(x[0])
...
C:\
D:\
>>> psutil.disk_usage("D:")                        # 查看指定磁盘分区的使用率
sdiskusage(total=295923871744, used=237350260736, free=58573611008, percent=80.2)
>>> psutil.disk_io_counters()                        # 查看磁盘IO的总量
sdiskio(read_count=1898598, write_count=1444576, read_bytes=131522050560, write_bytes=137437140480, read_time=1106, write_time=980)
- 查看网络的信息。
>>> psutil.net_if_addrs()                            # 查看所有网卡的地址
{'以太网': [snicaddr(family=<AddressFamily.AF_LINK: -1>, address='34-64-A9-15-EF-A9', netmask=None, broadcast=None, ptp=None), snicaddr(family=<AddressFamily.AF_INET: 2>, address='192.168.10.172', netmask='255.255.255.0', broadcast=None, ptp=None), snicaddr(family=<AddressFamily.AF_INET6: 23>, address='fe80::7c60:86c4:a3e2:c668', netmask=None, broadcast=None, ptp=None)], ……}
>>> for k, v in psutil.net_if_addrs().items():        # 提取网卡的mac地址
...     for item in v:
...         address = item[1]
...         if '-' in address and len(address) == 17:
...             print(address)
...
34-64-A9-15-EF-A9
>>> psutil.net_if_stats()                        # 查看所有网卡的信息（像Windows的ipconfig -all命令）
{'以太网': snicstats(isup=False, duplex=<NicDuplex.NIC_DUPLEX_FULL: 2>, speed=0, mtu=1500), 'Loopback Pseudo-Interface 1': snicstats(isup=True, duplex=<NicDuplex.NIC_DUPLEX_FULL: 2>, speed=1073, mtu=1500), 'WLAN': ……}
psutil.net_connections(kind="tcp")
>>> psutil.net_connections()                    # 查看所有网络连接的信息（像Linux的ss命令）
[sconn(fd=-1, family=<AddressFamily.AF_INET: 2>, type=2, laddr=addr(ip='0.0.0.0', port=49665), raddr=(), status='NONE', pid=3800), sconn(……]
>>> psutil.net_connections(kind="tcp")            # 只查看TCP类型的网络连接的信息
[sconn(fd=-1, family=<AddressFamily.AF_INET: 2>, type=1, laddr=addr(ip='10.135.149.134', port=57878), raddr=addr(ip='211.97.82.37', port=443), status='CLOSE_WAIT', pid=1524), sconn(……]

##
##
##
##

♢ platform
## platform：Python的标准库，用于获取当前运行平台的信息。
- 关于Python解释器。
>>> import platform
>>> platform.architecture()[0]    # 返回Python解释器的位数
'64bit'
>>> platform.python_version()        # 返回Python解释器的版本
'3.7.3'
- 关于操作系统。
>>> platform.system()                # 返回操作系统的名字（在Linux系统上是返回'Linux')
'Windows'
>>> platform.platform()            # 返回操作系统的具体名字
'Windows-10-10.0.17763-SP0'
>>> platform.machine()            # 返回CPU的架构类型
'AMD64'
>>> platform.processor()            # 返回CPU的具体名字
'Intel64 Family 6 Model 158 Stepping 10, GenuineIntel'
>>> platform.node()                # 返回该主机在网络中的名字
'Leo'
- 以上函数的返回值大多为str类型。如果没有确定的答案，则返回空字符串。
##
##
##

关于时间

常见概念：
- 格林威治时间（Greenwich Mean Time，GMT）
  - 英国伦敦格林威治位于零度经线处，因此常用于代表 0 时区。
- 协调世界时间（Coordinated Universal Time，UTC）
  - UTC 时区是指 0 时区。UTC 时间是指 0 时区的当前时间。
  - UTC 时间比 GMT 更精确，常用于供世界各地校准时间。
  - 考虑到地球自转周期会变化，当 UTC 时间与原子时钟的误差达到 ±0.9 秒时，国际计量局就会将 UTC 时间调快或调慢一秒。这一操作称为闰秒，一般发生在6月或12月的最后一秒。
- 夏令时（Daylight Saving Time，DST）
  - 富兰克林提出了夏令时制度：夏天的太阳比较早升起，所以在夏天开始时将时钟拨快一小时，从而早睡早起，提高日光的利用率，减少晚上的照明耗能。在夏天结束时再将时钟调慢一小时。
- CST ：可能是以下时区的缩写：
  - 美国中部时间：Central Standard Time (USA) UTC-6:00
  - 澳大利亚中部时间：Central Standard Time (Australia) UTC+9:30
  - 中国标准时间：China Standard Time UTC+8:00
  - 古巴标准时间：Cuba Standard Time UTC-4:00

- Unix 时间戳（Unix timestamp）
  - 又称为 Unix time、POSIX time 。
  - 是按 UTC 时区计算从 `1970-1-1 00:00:00` 开始到现在经过的秒数，不考虑闰秒。
    - 如果在东八区，则是计算从 `1970-1-1 08:00:00` 开始的秒数。因此，不同时区计算得到的 Unix 时间戳相同，可以通用。
    - 例如：UTC 时区的 `2020-01-01 08:00:00` 时刻对应的 Unix 时间戳是 `1577808000` 。
  - 一些计算机系统将 Unix 时间戳用 32 位的空间存储，导致最大只能记录到 2038 年。

- ISO8601 ：一种表示日期、时刻的字符串格式。如下：
  ```sh
  1970-01-01T00:00:00Z          # 末尾的字母 Z 表示 UTC 时区
  1970-01-01T00:08:00+08:00     # 末尾的 +8 表示东八区
  ```
  - 采用 24 小时制。
  - 用字母 T 分隔日期与时间。
  - 各个时间字段的位数固定，缺位则用 0 补齐。
  - 各个时间字段按范围大小降序排列，依次是：年、月、日、时、分、秒。




♢ time
## time：Python的标准库，用于获取时间。
- 获取 Unix 时间戳：
>>> import time
>>> time.time()
1544593113.593077
  - 运行time.time()的延迟很小，不足1ms。

> Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。

- 获取UTC时间的struct_time元组：
>>> time.gmtime(time.time())            # 将时间戳转换成struct_time元组
time.struct_time(tm_year=2019, tm_mon=5, tm_mday=31, tm_hour=4, tm_min=40, tm_sec=52, tm_wday=4, tm_yday=151, tm_isdst=0)
>>> time.gmtime().tm_year                # 不输入参数时，默认使用time.time()
2019
  - 可以访问struct_time元组中的任意属性。其中，tm_isdst表示是否是夏令时（DST）。
- 获取本地时间的struct_time元组：
>>> time.localtime(time.time())        # 将UTC时间的时间戳转换成本地时间的struct_time元组
time.struct_time(tm_year=2019, tm_mon=5, tm_mday=31, tm_hour=12, tm_min=46, tm_sec=15, tm_wday=4, tm_yday=151, tm_isdst=0)
>>> time.localtime().tm_year            # 不输入参数时，默认使用time.time()
2019
## struct_time元组。
- 将struct_time元组转换成时间戳（会自动从本地时区转换成UTC时区）：
>>> time.mktime((2019,2,21,14,10,45,3,52,0))
1545878778.0                # 得到的时间戳没有小数部分
  - 如果给time.mktime()输入的年份早于1970年就会报错。
  - time.mktime()在转换时会自动计算本地时区与UTC时区的差值，如下：
>>> time.mktime(time.localtime()) - int(time.time())
0.0
>>> time.mktime(time.gmtime()) - int(time.time())
-28800.0

- 将struct_time元组转换成指定格式的字符串：
  - struct_time元组不包含毫秒，因此生成的字符串中不包含毫秒。
>>> time.strftime("%Y/%m/%d %H:%M:%S", time.localtime())
'2018/12/12 13:52:43'
- 将指定格式的字符串转换成struct_time元组：
>>> time.strptime("2018/12/12 13:52:43", "%Y/%m/%d %H:%M:%S")
time.struct_time(tm_year=2018, tm_mon=12, tm_mday=12, tm_hour=13, tm_min=52, tm_sec=43, tm_wday=2, tm_yday=346, tm_isdst=-1)

## time模块还可暂停当前线程、获取程序的运行时间。
- 暂停当前线程：
>>> time.sleep(3)
  - 让线程保持等待时，调用sleep()函数比空语句pass更好。
while 1:
    pass                # 在这个死循环中，线程会不停地跳转while循环，占用CPU
while 1:
    time.sleep(1)        # 在这个死循环中，线程会被被挂起，不会占用CPU
- 获取程序的运行时间：
>>> time.perf_counter()            # 返回程序的运行时间，在终端里则是打开Python编辑器后的时间
16.795266047
# 运行程序时可以用time.perf_counter()截取多个时间节点，计算它们的差值就可以知道程序的运行时间
>>> time.process_time()
0.078125
>>> time.thread_time()
0.078125
##
##
##

♢ datetime
## datetime：Python的标准库，基于time模块封装了一些API，适合处理日期、切换时区、计算两个日期的差或和。
- 时区要用pytz模块选择：
>>> import pytz
>>> pytz.all_timezones_set        # 返回所有可用时区名的集合
LazySet({'Europe/Tirane', 'Asia/Shanghai', 'America/New_York',...
>>> pytz.timezone("UTC")            # 返回某个时区名对应的时区对象
<UTC>
- 获取当前时间的datetime对象：
>>> from datetime import datetime                # 从datetime模块导入datetime类
>>> datetime.utcnow()                            # 获取UTC时区的当前时间，返回一个datetime对象
datetime.datetime(2019, 5, 30, 10, 0, 0, 505080)
>>> datetime.now()                               # 获取当前时间，时区默认为本地
datetime.datetime(2019, 5, 30, 18, 0, 0, 505080)

- 转换时区：
>>> import pytz
>>> datetime.now(tz=pytz.timezone("UTC"))                # 获取指定时区的当前时间
datetime.datetime(2019, 5, 30, 10, 0, 0, 505080, tzinfo=<UTC>)
>>> datetime.now().astimezone(pytz.timezone("UTC"))      # 将datetime对象从当前时区转换到指定时区
datetime.datetime(2019, 5, 30, 10, 0, 0, 505080, tzinfo=<UTC>)
>>> datetime.now().astimezone(pytz.timezone("Asia/Shanghai"))
datetime.datetime(2019, 5, 30, 18, 0, 0, 505080, tzinfo=<DstTzInfo 'Asia/Shanghai' CST+8:00:00 STD>)


>>> from datetime import date
>>> date(2019, 5, 1)
datetime.date(2019, 5, 1)

## datetime对象。
定义：
class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *)
创建 datetime 对象时，至少要传入 year、month、day 三个参数。
并且会检查传入的所有参数是否在如下合理范围内，否则抛出 ValueError 异常。
```
MINYEAR <= year <= MAXYEAR
1 <= month <= 12
1 <= day <= 指定年月的天数
0 <= hour < 24
0 <= minute < 60
0 <= second < 60
0 <= microsecond < 1000000
```

- datetime对象包含了年、月、日、时、分、秒以及时区信息。
>>> d = datetime.now()
>>> print(d.year, d.month, d.day)
2019 5 30
>>> print(d.hour, d.minute, d.second, d.microsecond)
18 0 0 505080
>>> d.replace(hour=12)            # 修改datetime对象的值
datetime.datetime(2019, 5, 30, 12, 0, 0, 505080)

- datetime 对象的 tzinfo 属性默认为 None ，即不确定时区。在涉及到时区的操作时，可能会被当作UTC时区处理，也可能会被当作本地时区处理，容易出错。所有应该主动标明时区，如下：
>>> d.tzinfo == None
True
>>> d.replace(tzinfo=pytz.timezone("Asia/Shanghai"))
datetime.datetime(2019, 5, 30, 18, 0, 0, 505080, tzinfo=<DstTzInfo 'Asia/Shanghai' LMT+8:06:00 STD>)

time 模块不支持修改时间的时区，而 datetime 模块支持：
- 可以通过 datetime.astimezone() 方法转换时区。此时显示的时间字符串会按时差变化，但底层的Unix时间戳不变。
- 可以通过 datetime.replace() 方法强行改变时区。此时显示的时间字符串不变，但底层的Unix时间戳会按时差变化。

例：将时间字符串从 UTC 时区转换到指定时区
```py
>>> utc_time_str = '2019/05/30 10:00:00'
>>> utc_time = datetime.strptime(utc_time_str, "%Y/%m/%d %H:%M:%S").replace(tzinfo=pytz.timezone("UTC"))
>>> utc_time.astimezone(pytz.timezone("Asia/Shanghai")).strftime("%Y/%m/%d %H:%M:%S")
'2019/05/30 18:00:00'
```

- 与 timetuple 的转换：
>>> d.timetuple()      # 直接转换成 timetuple
time.struct_time(tm_year=2019, tm_mon=5, tm_mday=30, tm_hour=18, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=150, tm_isdst=-1)
>>> d.utctimetuple()   # 先转成成 UTC 时区，再转换成 timetuple ，不过 d.tzinfo 为 None ，得到的 timetuple 并不是正确的 UTC 时间
time.struct_time(tm_year=2019, tm_mon=5, tm_mday=30, tm_hour=18, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=150, tm_isdst=0)
>>> d.replace(tzinfo=pytz.timezone("Asia/Shanghai")).timetuple()
time.struct_time(tm_year=2019, tm_mon=5, tm_mday=30, tm_hour=18, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=150, tm_isdst=0)
>>> d.replace(tzinfo=pytz.timezone("Asia/Shanghai")).utctimetuple()     # 结果为正确的 UTC 时间
time.struct_time(tm_year=2019, tm_mon=5, tm_mday=30, tm_hour=9, tm_min=54, tm_sec=0, tm_wday=3, tm_yday=150, tm_isdst=0)


- 与时间戳的转换：
>>> d.timestamp()                    # 将datetime对象转换成时间戳（不会自动转换成UTC时区）
1559210400.50508
>>> datetime.fromtimestamp(1559210400.50508, tz=pytz.timezone("UTC")) # 将时间戳转换成datetime对象
datetime.datetime(2019, 5, 30, 10, 0, 0, 505080, tzinfo=<UTC>)

- 与字符串的转换：
  - 与time.strftime()相比，datetime能用 %f 输出微妙。
>>> d.strftime("%Y/%m/%d %H:%M:%S.%f")            # 将datetime对象转换成指定格式的字符串
'2019/05/30 18:00:00.505080'
>>> datetime.strptime('2019/05/30 18:0:0.505080', "%Y/%m/%d %H:%M:%S.%f")
datetime.datetime(2019, 5, 30, 18, 0, 0, 505080)    # 将指定格式的字符串转换成datetime对象


- datetime对象支持加减法运算：
>>> from datetime import timedelta                # 从datetime模块导入timedelta类
>>> datetime.now() - datetime.utcnow()            # 两个datetime对象相加减，会生成timedelta对象
datetime.timedelta(seconds=28800)
>>> datetime.now() + timedelta(hours=10)        # 一个datetime对象可以与timedelta对象相加减
datetime.datetime(2019, 5, 31, 4, 0, 0, 505080)
>>> timedelta(milliseconds=100).total_seconds()    # 获取timedelta对象的秒值
0.1
##
##
##

♢ apscheduler
## apscheduler：Python的第三方库，用于执行定时任务。
- 安装：pip install apscheduler
- 原理：当一个任务到达触发时刻时，就创建一个子线程来运行它。
- 例：
from apscheduler.schedulers.blocking import BlockingScheduler
from datetime import datetime, timedelta

schedule = BlockingScheduler()        # 创建一个任务表，它在运行时会阻塞当前线程

# 添加一个定时任务，只会执行一次
schedule.add_job(func=print, args=('hello',), kwargs=None, trigger='date', next_run_time=datetime(2012, 10, 1, 0, 0, 0))

# 添加一个周期性任务，每隔一段时间就执行一次
schedule.add_job(func=print, args=('hello',), trigger='interval', seconds=3)

# 添加一个日常循环任务，在每天的12:30执行一次
schedule.add_job(func=print, args=('hello',), trigger='cron', hour=12, minute=30)

schedule.start()            # 启动任务表
schedule.get_jobs()        # 返回一个列表，包含所有待执行的任务（不包含已经失效的任务）
schedule.shutdown()        # 终止任务表

- 关于add_job()方法。
  - trigger参数表示任务的触发方式。
  - 可传入max_instances参数，控制任务的运行实例数量。默认为1。
  - 对于'interval'类型的任务，可使用以下参数控制任务的间隔时间：
weeks(int)    间隔几周
days(int)    间隔几天
hours(int)    间隔几小时
minutes(int)    间隔几分钟
seconds(int)    间隔多少秒
start_date(datetime or str)    开始日期
end_date(datetime or str)    结束日期
  - 对于'cron'类型的任务，可使用以下参数控制任务的启动时刻：
year、month、week、day_of_week（取值为0~6）、hour、minute、second、start_date、end_date
- 删除任务：
job = scheduler.add_job(func=print, args=('hello',), trigger='interval', seconds=3)
job.remove()
##
##
##

♢ celery
## celery：Python的第三方库，是一个分布式的任务队列，常用于执行大量的异步任务、定时任务。
- 安装：pip install celery
- 原理：用户将任务保存到broker服务器。而worker会从broker服务器提取任务并执行，然后将执行结果保存到backend服务器。
  - broker、backend服务器可以采用RabbitMQ，也可以采用Redis。
  - celery采用分布式架构，可以有多个worker。
- 任务有以下几种状态：
  - PENDING    ：等待被执行。
  - STARTED    ：已被启动，正在执行。
  - RETRY    ：发生异常，正在重新执行。
  - SUCCESS    ：执行成功。
  - FAILURE    ：执行失败。
## 例：
- 创建异步任务：
>>> import celery
>>> cel = celery.Celery(backend='redis://127.0.0.1:6379/1', broker='redis://127.0.0.1:6379/2')
    # 可以加上密码，例如'redis://:123456@127.0.0.1:6379/1'
    # 此时只是创建客户端，等执行实际操作时才会连接到broker
>>> @cel.task            # 使用装饰器添加任务
... def fun1(*args):        # 函数在第一次添加到celery时就固定了，不能再重新定义
...     print(b)
...
>>> fun1('hello')                    # 正常调用该函数
hello
>>> task = fun1.delay('hello')    # 异步执行该函数（这会将任务发送到broker），用delay()方法传入参数
>>> task
[2019-10-28 16:00:35,998: WARNING/MainProcess] <AsyncResult: c399d950-c16e-4912-8d19-624393abf1ef>
>>> result = celery.result.AsyncResult(id=task.id, app=cel)        # 获取任务的result
>>> result.status                    # 查看任务状态
[2019-10-28 16:01:01,766: WARNING/MainProcess] 'PENDING'
- 运行worker有两种方法。
  - 在终端执行以下命令：
celery worker
--app task1            # 指定任务所在的.py文件
--loglevel info
--logfile <file>        # 指定日志文件的保存路径（默认输出到stdout）
  - 或者在python中执行主函数：
cel.worker_main()
- 创建定时任务：
>>> result = fun1.apply_async(args=('hello',), kwargs=None, countdown=10)
>>> result.status
'PENDING'
- 设置周期性任务：
cel.conf.beat_schedule = {
    'schedule1': {
        'task': 'task1.fun1',                # 把task1.py文件中的fun1()函数添加成任务
        'args': ('hello',)                    # 输入参数
        'schedule': timedelta(seconds=2),    # 间隔时间
    },
    'schedule2': {
        ...
    },
}
##
##
##

关于数据

##
##
##

♢ string
## string：Python的标准库，提供了一些常用的字符集合。
- 关于数字。
>>> import string
>>> string.digits                # 全部数字
'0123456789'
>>> string.hexdigits            # 全部十六进制数字
'0123456789abcdefABCDEF'
>>> string.octdigits            # 全部八进制数字
'01234567'
- 关于字母。
>>> string.ascii_letters        # 全部字母
'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
>>> string.ascii_lowercase    # 全部小写字母
'abcdefghijklmnopqrstuvwxyz'
>>> string.ascii_uppercase    # 全部大写字母
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
- 其它。
>>> string.whitespace            # 所有空白字符。
' \t\n\r\x0b\x0c'

# \x0b 表示让光标垂直换行，等价于 \v 。\x0c 表示让打印机换到下一张纸，等价于 '\f' 。
# \b 表示让光标回退一格， \x20 表示一个空格。

>>> string.punctuation        # 所有标点符号
'!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
>>> string.printable            # 所有可打印字符（等于digits + letters + whitespace + punctuation）
'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c'
##
##
##



关于调试
♢ traceback
## traceback：Python的标准库，用于获取stack的信息。
- 例：
import traceback
try:
    ...
except :                                # 使用时不需要实例化异常类
    traceback.print_exc()                # 打印出完整的异常信息
    list1 = traceback.format_exc()        # 保存异常信息
##
##
##
##
##
##
##

♢ inspect
## inspect：Python的标准库，提供了一些查询对象属性、查看堆栈的方法，常用于调试。
## 判断对象的类型。
- def ismodule(object) -> bool
  - 功能：判断对象是否为模块名。
  - 例：
>>> from inspect import ismodule
>>> ismodule(inspect)
True
- def isclass(object) -> bool
  - 功能：判断对象是否为类名。
  - 例：
>>> a = int
>>> isclass(a)
True
- def ismethod(object) -> bool
  - 功能：判断对象是否为某个实例的普通方法或类方法名。（根据该对象是否具有__func__属性）
  - 例：
>>> class Test(int):
...     def fun1(self):
...         pass
...
>>> ismethod(Test().fun1)
True
>>> ismethod(Test.fun1)        # 必须是实例的方法
False
>>> ismethod("".encode)        # 不能为built-in类的实例的方法
False
- def isfunction(object) -> bool
  - 功能：判断对象是否为用户定义的函数名（非built-in）。
  - 例：
>>> isfunction(isfunction)
True
>>> isfunction(lambda : ...)        # 可以是匿名函数
True
>>> isfunction(len)                # 不可以是内置函数
False
>>> isfunction("".encode)        # 不可以是方法
False
- def isbuiltin(object) -> bool
  - 功能：判断对象是否为built-in的函数或方法名。
  - 例：
>>> inspect.isbuiltin(len)
True
>>> inspect.isbuiltin("".encode)
True
- def isroutine(object) -> bool
  - 功能：判断对象是否为函数名或方法名。
  - 例：
>>> inspect.isroutine(len)
True
>>> inspect.isroutine("".encode)
True
- def isgenerator(object) -> bool
  - 功能：判断对象是否为生成器。
  - 例：
>>> isgenerator((x for x in range(5)))
True
## 查看对象的定义。
- def getfile(object: object) -> str
  - 功能：返回定义该对象的.py文件的绝对路径。
  - 例：
>>> getfile(getfile)
'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37\\lib\\inspect.py'
>>> getfile(int)
TypeError: <module 'builtins' (built-in)> is a built-in class
- def getsourcelines(object) -> (List[str], int)
  - 功能：获取一个对象的源代码，返回一个list（包含每行代码字符串）、行号。
  - 例：
>>> getsourcelines(getfile)
(['def getfile(object):\n', '    """Work out which source or compiled file an object was defined in."""\n', '    if ismodule(object):\n',...'], 642)
- def signature(callable, *, follow_wrapped=True) -> Signature
  - 功能：查看函数的一些属性，返回一个Signature对象。
  - 例：
>>> def fun1(a, b: str, c: int = 0):
...     pass
...
>>> sign = signature(fun1)
>>> sign
<Signature (a, b: str, c: int = 0)>
>>> sign.parameters                # 获取函数的形参列表（与定义处一致），返回一个dict类对象
mappingproxy(OrderedDict([('a', <Parameter "a">), ('b', <Parameter "b: str">), ('c', <Parameter "c: int = 0">)]))
  - 可以模拟给函数形参赋值：
>>> arguments = sign.bind(1, b=2)                # 正常传参，要传入所有必需参数
>>> arguments.arguments                        # 显示被赋值的那些参数
OrderedDict([('a', 1), ('b', 2)])
>>> arguments.args
(1, 2)
>>> arguments.kwargs
{}
>>> sign.bind(1).arguments
TypeError: missing a required argument: 'b'
>>> sign.bind_partial(1).arguments            # 只传入部分参数
OrderedDict([('a', 1)])
##
##
##


♢ pytest
## pytest：Python的第三方库，是一个开源的Python单元测试框架。
- pytest 比 unittest 的功能更多，并且可以兼容地执行 unittest 的测试用例。

- 安装：pip install pytest
- pytest的基本用法如下：
  - 将单元测试的脚本命名为 test_*.py 或 *_test.py 。
  - 将单元测试的函数命名为 test_* 。
  - 将单元测试的类命名为 Test* ，且该类不能定义__init__()方法。
  - 如下：
def fun1(x):
    return x**2

class TestClass:
    def test_fun1_1(self):
        assert fun1(1)

    def test_fun1_2(self):
        for i in range(100):
            assert fun1(i) > 0
- 命令：
pytest [file_or_dir]...    # 让pytest执行指定的测试脚本
-q        # 用一行显示所有测试脚本的测试结果
-v        # 详细地显示每个测试函数的测试结果
    -s        # 显示测试用例的stdout
  - 不指定测试脚本的话，pytest会自动在当前目录及其子目录中搜集单元测试的脚本来执行（搜集过程是import这些脚本）。
- 执行pytest之后的显示内容如下：
D:\1\test_Python>pytest
======================== test session starts ========================
platform win32 -- python 3.7.2, pytest-4.3.1, py-1.8.0, pluggy-0.9.0
rootdir: D:\1\test_Python, inifile:
collected 2 items

test_.py .F                                                          [100%]

  - 测试脚本后，绿色的 . 表示一个测试函数pass了，红色的 F 表示一个测试函数fail了，蓝色的 [100%] 表示pytest的测试进度。
  - 红色的 E代表一个抛出的异常，即源代码没有捕捉到的异常。
## pytest支持传统的单元测试风格：定义setup()、teardown()函数，pytest运行测试函数前会自动调用setup()进行测试前的准备工作，运行测试函数后会自动调用teardown()进行测试后的清理工作。
- 按作用区域分级：
  - setup_module()、teardown_module()        ：执行每个测试模块的前后被调用。
  - setup_function()、teardown_function()    ：执行每个测试函数的前后被调用。
  - setup_class()、teardown_class()        ：执行每个测试类的前后被调用。
  - setup_method()、teardown_method()        ：执行每个测试类中的测试方法的前后被调用。
  - setup()、teardown()                    ：执行每个测试类中的测试函数的前后被调用。
- 例如：
  - 定义如下测试类：
import pytest

class TestClass:
    def setup_class(self):
        self.result = []
        self.result.append("setup_class")

    def teardown_class(self):
        self.result.append("teardown_class")
        with open("1.txt", 'w') as f:
            f.writelines('\n'.join(self.result))    # 记录测试方法的运行结果

    def setup_method(self):
        self.result.append("setup_method")

    def teardown_method(self):
        self.result.append("teardown_method")

    def test_1(self):
        self.result.append("test_1")

    def test_2(self):
        self.result.append("test_2")
- 输入命令pytest进行测试，在1.txt中可看到测试结果如下：
setup_class
setup_method
test_1
teardown_method
setup_method
test_2
teardown_method
teardown_class
## 用with pytest.raises()可以判断源代码是否抛出了某个异常。如果抛出了，则pass；如果没抛出，则fail。
import pytest

def fun1():
    raise KeyboardInterrupt

def test_fun1():
    with pytest.raises(KeyboardInterrupt):
        fun1()
## pytest还提供了装饰器 @pytest.fixture，用于标记一个fixture函数，只要把它的函数名作为形参传入测试函数，pytest就会在进行测试时自动调用它。
- 直接使用该装饰器的例子：
@pytest.fixture(scope="function")        # 相当于@pytest.fixture
def fun1(request):
    print("fun1")

def test_1(fun1):                        # 传入fixture函数的函数名
    assert 0
  - scope = 'function' 表示在运行某个测试函数时调用fixture函数。scope可取值为"function"（默认该值）、
- 给fixture函数传入参数的例子：
@pytest.fixture(params=[1, 2, 3], ids=['a', 'b','c'])
def fun1(request):            # fixture函数通过request参数获取装饰器的一些信息
    print(request.param)
    assert request.param == 0

def test_1(fun1):
    pass
  - 这里执行test_1()时会调用三次fun1()——即测试三次。每次传入一个参数，并给test_1()记上一个id，即test_1[a]、test_1[b]、test_1[c]。
  - 如果没有给装饰器设置参数ids，pytest会自动生成数字编号，即test_1[1]、test_1[2]、test_1[3]。
## pytest的可用插件。
- pytest-cov：用于统计测试覆盖率，即每个py文件中的源代码被测试用例执行到的百分比。
- pytest-django：用于执行Django项目目录下的测试用例。
##


也可通过调用 pytest.main() 来执行 pytest ，支持传入命令参数。
```py
import pytest

if __name__ =="__main__":
    exit(pytest.main(['-v']))
```





关于运行
♢ argparse
## argparse：Python的标准库，用于处理启动脚本时输入的命令行参数。
- 输入命令行参数时通常有两种形式：
D:\1\test_Python>python test.py --test            # 只输入选项名
D:\1\test_Python>python test.py --test     1        # 输入选项名，并输入该选项的参数
  - 选项名通常还可使用简写（如果程序支持这种操作的话），比如--test/-t。
- 例如，在test.py中保存以下内容：
import argparse
parser = argparse.ArgumentParser(description="This script is use to test.")
# description是该脚本的说明信息，使用选项--help/-h时会显示出来
parser.add_argument("--test", "-t", help="just for test", action="store_true")
    # help是该选项的说明信息，使用选项--help/-h时会显示出来
    # action="store_true"表示当输入选项--test/-t时（不需要输入其值）会将args.test的值置为true
parser.add_argument("--level", "-l", type=int, default=0)
    # default=0表示该选项的默认值是0，而且限制输入值为int型

, required=True)
非必须参数才设置默认值

args = parser.parse_args()        # 将启动脚本时输入的命令行参数解析并保存到args中
print(args.test)                    # 获取选项test的值
print(args.level)                # 获取选项level的值
- 然后，在终端测试启动该脚本：
  - argparse会自动生成选项--help/-h的相应内容，可直接使用：
D:\1\test_Python>python test.py –h
usage: test.py [-h] [--test] [--level LEVEL]
This script is use to test.
optional arguments:
  -h, --help            show this help message and exit
  --test, -t            just for test
  --level LEVEL, -l LEVEL
  - 这里使用选项--test/-t时不需要输入其值。
D:\1\test_Python>python test.py --test
True
0
  - 这里使用选项--level/-l时需要输入该选项的值，除非不使用该选项（会用默认值）。
D:\1\test_Python>python test.py
False
0

D:\1\test_Python>python test.py --level
usage: test.py [-h] [--test] [--level LEVEL]
test.py: error: argument --level/-l: expected one argument

D:\1\test_Python>python test.py --level 1
False
1


还可以直接获取命令行参数列表：
import sys
print(sys.argv)

注意argv[0]是执行的文件名


♢ pyinstaller
## pyinstaller：Python的第三方库，用于将Python脚本打包成可执行文件。
- 安装：pip install pyinstaller
- 例：
pyinstaller  D:\1\1.py     # 打包成一个文件夹，包含一堆运行库
-F                # 打包成一个可执行文件，体积较大
-w                # 启动程序时只显示GUI窗口，不打开一个终端窗口（针对Windows、MacOS的选项）
-p ./utils        # 指明寻找模块的路径（如果找不到该模块的话）
--icon 1.ico        # 设置程序的图标
  - 基于64位的Python解释器打包的可执行文件不能在32位的电脑上使用，但反之可以兼容。
  - 使用-w选项的话，如果启动程序失败，就看不到报错信息了。
  - build目录下的warn-*.txt文件中记录了找不到的模块，但那些模块可能不需要导入。
- 打包之后，会在当前目录下生成两个文件夹。
  - build：保存打包过程中的一些信息。
  - dist：保存打包结果。
-
##
##
##

其它模块
♢ functools
## functools：Python的标准库，提供了一些功能函数、装饰器。
##
## class partial(func, *args, **keywords)
- 功能：给函数传入一些参数，装饰成一个新函数。又称为偏函数。
- 例：
>>> import functools
>>> def fun1(a, b, c=0, d=0):
...     print(a, b, c, d)
...
>>> fun1_new = functools.partial(fun1, 1, 2, c=3)
>>> fun1_new
functools.partial(<function fun1 at 0x7f58aa51aa60>, 1, 2, c=3)
>>> fun1_new()
1 2 3 0
>>> fun1_new('c')            # 此时传入的位置参数会被赋值给参数c
TypeError: fun1() got multiple values for argument 'c'
>>> fun1_new(c='c')        # 以关键字的形式传入参数，就不会报错重复赋值
1 2 c 0
##
##
##





## 创建子进程、子线程时，可以把它们设置成daemon，即后台运行。（此daemon不是指守护进程）
- Python创建的子进程、子线程默认是非daemon。
- 创建一个daemon之后，就不必考虑如何让它结束。
  - 当一个进程组中的所有非daemon进程结束时，系统会自动终止所有daemon线程，然后结束该进程组。
  - 当一个进程中的所有非daemon线程结束时，系统会自动终止所有daemon线程，然后结束该进程。

## 结束子线程的方法。（对子进程同理）
- 由主线程控制何时停止子线程。
  - 尽量不要强制杀死子进程，应该让它自己自愿结束，清理自己占用的资源。因为子线程可能正在执行一些不宜中断的操作，比如拿到了某个资源的锁、打开了某个文件还没有关闭、创建了孙线程还没有关闭。
  - 当主进程异常终止时（比如被kill -9），子进程就会变成没人管的孤儿进程。
- 把子线程设置成daemon，当主进程退出时它们就会被系统自动终止。
- 等子线程处理完所有业务，自然结束。
  - 这需要事先确定子线程不会无限运行。
- 让子线程自己定期判断，是否要结束运行。


## CPython早先引入了GIL（Global Interpreter Lock，全局解释锁）机制。
- 为了保证多线程之间不冲突，同一时间只有一个线程拿到GIL运行，当该线程暂时不用执行字节码时（比如等待IO响应时）就会把GIL传递给其它线程，或者隔一小段时间后解释器会抢走这个GIL给其它线程（这可能中断正在执行的某个任务，所以以防万一，还是要加锁来保证线程安全）。
- 由于GIL机制，CPython程序同时只能使用CPU的一个核。因此，处理IO密集型任务时，用多线程能提高效率；处理CPU密集型任务时，用多进程或协程才能提高效率。


♢ threading
## threading：Python的标准库，用于创建多线程。
## 第一种创建线程的方法：直接调用类Thread()。
- class Thread(group=None, target=None, name=None, args=(), kwargs=None, daemon:bool)
  - 功能：定义一个线程。
  - group是线程组（目前尚未实现），target是要在线程中运行的函数，name是线程名，args是传递给线程函数的参数（必须是tuple型）。
  - 调用Thread.run()方法时，会在系统中创建该进程，分配资源，并调用Thread.start()方法开始运行。
  - 例：
>>> import threading
>>> def fun1(string):
...     print(string)
...
>>> t1 = threading.Thread(target=fun1, args=("Hello",))
>>> t1.start()        # 启动线程
Hello
  - Thread.start()方法会在系统中创建一个进程，分配资源，并调用Thread.run()方法。
  - Thread.run()方法定义了该线程的运行内容（即运行target函数）。
  - 每个线程只能调用一次start()方法，否则会报错。
- 查看线程的信息。
>>> t1.getName()        # 获得线程的名字
'Thread-1'
>>> t1.setName("t1")    # 设置线程的名字
>>> t1.isAlive()        # 判断线程是否正在运行
False
- 关于daemon线程。
>>> t1.isDaemon()                # 判断t1是否为daemon线程
>>> False
>>> t1.setDaemon(True)        # 将t1设置成daemon线程（必须在线程启动之前设置daemon属性）
RuntimeError: cannot set daemon status of active thread
- 阻塞线程。
>>> t1.join()            # 使CPU只运行该线程，阻塞其它线程的运行
>>> t1.join(3)            # 使CPU只运行该线程，最多持续3秒（t1可能提前运行结束）
- 关于多线程。
>>> threading.current_thread()        # 返回当前所在的线程对象
<_MainThread(MainThread, started 140176114464576)>
>>> threading.current_thread().getName()
'MainThread'
>>> threading.active_count()            # 返回当前运行的线程总数
2
>>> threading.enumerate()                # 列出当前运行的所有线程对象
[<_MainThread(MainThread, started 140176114464576)>, <Thread(Thread-1, started 140175977273088)>]
  - 调试运行时，会创建几个额外的线程。
  - 用 t.ident 可以获得线程的 ID 。

Python 的 threading 库没有提供杀死线程的方法，只能等线程自行退出。因此设计线程时必须让它能够自行退出。
如果不能自行退出，则只能使用 multiprocessing 库创建子进程，可以用 p.terminate() 杀死。



## 第二种创建线程的方法：继承threading.Thread类，重载其run()方法。
- 例：
>>> class myThread(threading.Thread):
...     def __init__(self, *args, **kwargs):
...         super().__init__(*args, **kwargs)    # 先调用super().__init__()进行初始化，再进行修改
...         self.name = kwargs.get("name")
...     def run(self):
...         print("Hello!")
...
>>> t1 = myThread(name="t1")
>>> t1.start()
Hello!
## 线程的锁。
- threading.Lock()：互斥锁。获得后使系统只运行当前线程，阻塞其它线程的运行。
>>> lock = threading.Lock()
>>> lock.acquire()        # 请求获得锁，这会阻塞当前线程，直到请求成功
True
>>> flag1 = True
>>> lock.release()        # 释放锁
  - 互斥锁同一时间只能被一个线程获得。
  - 死锁：线程请求获得锁时，锁一直没有释放，导致线程一直在等待。
例如：如果一个线程在获得锁之后没有释放就再调用acquire()方法，就会一直等待获得锁，陷入死锁。
- threading.RLock()：可重入锁。
  - 可重入锁可以重复获得，只不过调用了多少次acquire()就得调用多少次release()才能完全释放该锁。
>>> rlock = threading.RLock()
>>> rlock.acquire()
True
>>> rlock.acquire()
True
>>> rlock.release()
>>> rlock.release()
>>> rlock.release()
RuntimeError: cannot release un-acquired lock
## 定时任务。
- class Timer(interval, function, args=None, kwargs=None)
  - 功能：定义一个线程，在interval秒之后执行function函数。
  - 只不过是延迟启动一个线程，不适合处理大量的、频繁的定时任务。
  - 例：
>>> t = threading.Timer(3.0, print, ('hello',))
>>> t.start()        # 启动线程
>>> hello

>>> t.cancel()        # 取消该进程
##
##
##

♢ queue
## queue：Python的标准库，用于创建线程间通信的队列。
- queue模块提供了三种队列，都是基于生产者-消费者模式，自身实现了线程锁，是线程安全的。
## class Queue(maxsize: int)
- 功能：创建一个先进先出队列（FIFO）。
  - maxsize表示该队列的最大容量，当maxsize<=0时容量为无限大。
- 例：
>>> from queue import Queue
>>> q = Queue(10)
>>> q.qsize()            # 返回队列此时的大小（不可靠，队列的大小可能转瞬就变）
0
>>> q.empty()            # 判断队列是否为空
True
>>> q.full()                # 判断队列是否满了
False
- Queue.put(item, block=True, timeout=None)
  - 功能：往队列中写入一个元素（可以是任意类型）。
  - 当队列满了时，写入操作会一直阻塞，直到队列中有元素被消费掉。
如果block=False，则不阻塞，直接抛出queue.Full异常。
如果输入了timeout参数，则最多阻塞timeout秒，然后抛出异常。
  - 例：
>>> q.put(0)
>>> q.put("Hello", block=False)
>>> q.put([1, 2, 3], timeout=1)
- Queue.get(block=True, timeout=None)
  - 功能：从队列中取出一个元素。
  - 当队列为空时，读取操作会一直阻塞，直到队列中写入了新元素。
如果block=False，则不阻塞，直接抛出queue.Empty异常。
如果输入了timeout参数，则最多阻塞timeout秒，然后抛出异常。
  - 例：
>>> q.get()
0
>>> q.get(block=False)
'Hello'
>>> q.get(timeout=1)
[1, 2, 3]
## class LifoQueue(maxsize=0)
- 功能：创建一个后进先出队列（LIFO）。
- LifoQueue继承自Queue类，因此可使用同样的方法进行操作。
## class PriorityQueue(maxsize: int)
- 功能：创建一个优先级队列（Priority）。
  - 基于heapq模块的heappush()和heappop()实现，只不过加上了线程锁。
- PriorityQueue也继承自Queue类，因此可使用同样的方法进行操作。
  - 不同之处在于，写入的元素需要实现__lt__()方法，从而可以被sorted()排序。
- 例：
class Item:
    def __init__(self, priority, data):
        self.priority = priority
        self.data = data

    def __lt__(self, other):
        return self.priority < other.priority

>>> from queue import PriorityQueue
>>> q = PriorityQueue()
>>> q.put(Item(1, "one"))
>>> q.put(Item(3, "three"))
>>> q.put(Item(2, "two"))
>>> q.get().data
'one'
>>> q.get().data
'two'
>>> q.get().data
'three'
##
##
##

♢ multiprocessing
## multiprocessing：Python的标准库，用于创建多进程。
- class Process(group=None, target=None, name=None, args:Iterable, kwargs:Mapping[Any, Any], daemon:bool)
  - 功能：定义一个进程。
  - 例：
>>> import multiprocessing
>>> p = multiprocessing.Process(target=print, args=('hello',))
>>> p
<Process(Process-1, initial)>
>>> p.start()
>>> hello
  - 进程的方法。
>>> p.is_alive()
False
>>> p.join(1)
>>> p.terminate()        # 强制终止进程
>>> p.terminate()        # 重复终止不会报错
  - 进程的属性。
>>> p.daemon
False
>>> p.exitcode
0
>>> p.name
'Process-1'
>>> p.pid
2798
## 进程池：用于限制进程的最大运行数量。当进程池满了时，新增的进程会被挂起，直到进程池有空位时才开始运行。
- 例：
>>> pool = multiprocessing.Pool(2)          # 创建一个大小为2的进程池（默认等于CPU核数）
>>> for i in range(5):
...     pool.apply_async(fun1, (i,))        # 往进程池中添加进程
...
0
1
2
3
4
>>> pool.close()        # 关闭进程池，不能再加入进程了
>>> pool.join()        # 阻塞当前进程，等pool里的进程运行结束（需要先调用close()方法）
- def apply_async(func, args=(), kwds={}, callback=None, error_callback=None)
  - 功能：异步地创建进程。
  - 调用apply_async()函数会立即完成，不会等子进程运行结束，不会阻塞当前进程。
## 进程之间的通信方式（Inter-Process Communication，IPC）。
- multiprocessing模块提供了进程之间通信的队列类Queue，用法与类queue相似。
>>> q = multiprocessing.Queue()
>>> q.put("hello")
>>> q.get()
'hello'
##
##
##

♢ asyncio
## 协程：即协同程序，又称为异步函数。是指系统在执行某个函数时中断，转去运行另一个函数。
- 协程可以达到多线程并行工作的效果，但它依然是在一个线程内运行。
- 优点：用户可以控制多个协程切换执行的顺序，不用担心线程安全，而且比切换线程的开销小很多。
- 协程常用于实现异步IO。



## Python中可以用关键字async创建协程，用关键字await实现异步工作。
- Python的协程是通过生成器实现的。
- await只能在async函数中使用。
  - await只能调用实现了__await__()方法的对象。
## asyncio：Python的标准库，提供了异步IO的方法。
>>> import asyncio
>>> async def fun1(n):
...     for i in range(n):
...         await asyncio.sleep(1)        # 表示这里要等待1秒的IO，让解释器去执行event_loop中的其它协程
...         print(i)
...
>>> loop = asyncio.get_event_loop()    # 创建事件循环
>>> loop.run_until_complete(fun1(5))    # 开始事件循环
0
1
2
3
4
- async函数不能直接使用，直接调用会返回一个coroutine对象。
>>> fun1(5)
<coroutine object fun1 at 0x7f79d8348a40>
- 可以在event_loop中加入多个任务。
>>> tasks = [asyncio.ensure_future(fun1(i)) for i in [2, 3, 3]]
>>> loop.run_until_complete(asyncio.wait(tasks))
0
0
0
1
1
1
2
2
({<Task finished coro=<fun1() done, defined at <stdin>:1> result=None>, <Task finished coro=<fun1() done, defined at <stdin>:1> result=None>, <Task finished coro=<fun1() done, defined at <stdin>:1> result=None>}, set())
##
##
##




##
##
##


##
##


##
##
##

##
##
##

表格
♢ csv
## 将数据保存成表格时，可保存为CSV类型或Excel类型。
- CSV（Comma Separated Values，逗号分隔值）文件以纯文本的形式存储表格数据。
  - csv文件并没有明确的格式规定，不同来源的csv文件不一定能互通。
  - Python访问csv文件时可以像文本文件一样直接读写，例如f.write("path,content,total pings\n")，也可以导入内置的csv模块。
- xlsx文件是专有格式，只能用Excel软件打开，修改不自由。
  - 用Excel软件也可以直接打开 csv文件，还可以把 .xlsx文件保存成 csv文件。
  - 可使用第三方的xlrd和xlwt模块读写xlsx文件，其中xlrd用于读取（只读，不能修改），xlwt用于写入。
  - 还可使用读写功能都具备的openpyxl模块。
- 当csv文件的风格符合以下要求时，在Excel中显示的内容才会与xlsx文件一致。
  - 每行数据以换行符 '\r\n' 分隔，每行的各个字段以英文逗号 , 分隔。
  - 单个字段中如果出现了英文逗号、英文双引号，要用英文双引号把这个字符串包住，还要在其中的每个双引号前加上一个双引号进行转义。
  - 例如，用Excel编辑xlsx文件，写入如下三个单元格（每格之间用Tab分隔）：
1    A,B    A,"B"
用Excel将它保存为csv文件，用notepad++打开后的显示内容为：
1,"A,B","A,""B"""
用Python读取该csv文本，实际上每行末尾还有换行符（除非是最后一行）：
>>> with open("test.csv", newline="") as f:
...     f.read()
...
'1,"A,B","A,""B"""\r\n'
## csv：Python的标准库，用于读写csv文件。
- 写入的方法如下。
>>> import csv
>>> data = [["Hello world!"], [1, 2, 3, 4, 5], {'a': 1, 'b': 2, 'c': 3}]
>>> with open("test.csv", 'w', newline='') as f:# 设置newline=''，避免写入文件时自动转换换行符
...     csv_writer = csv.writer(f)                # 在文件流f上创建一个csv写入器
...     csv_writer.writerow("Hello")            # 写入一行，输入必须是可迭代对象
...     csv_writer.writerows(data)                # 写入多行，输入必须是可迭代对象
...
  - 检查保存结果：
>>> with open("test.csv") as f:
...     f.read()
...
'H,e,l,l,o\nHello world!\n1,2,3,4,5\na,b,c\n'
  - 用notepad++打开该文件，显示为：
H,e,l,l,o        # 直接拿一个字符串作为一行，转换成csv格式时就会被拆散成单个字符
Hello world!
1,2,3,4,5
a,b,c            # 这种情况下，字典只被保存了键名
- 读取的方法如下。
>>> with open("test.csv", 'r') as f:
...     csv_reader = csv.reader(f)        # 在一个可迭代对象（比如文件流、list）上创建csv阅读器
...     for line in csv_reader:        # 迭代csv_reader的内容
...             print(line)
...
['H', 'e', 'l', 'l', 'o']
['Hello world!']
['1', '2', '3', '4', '5']
['a', 'b', 'c']
  - 也可用csv.reader()直接解析csv格式的字符串：
>>> [i for i in csv.reader(["a,b,c\n"])]
[['a', 'b', 'c']]
## 用csv.writer()写入csv文件时，还可以选择csv风格，如下。
- csv.writer()的定义为csv.writer(fileobj [, dialect='excel']），其中dialect='excel'表示默认转换成excel的风格。
- 查看现有的所有dialect：
>>> csv.list_dialects()
['excel', 'excel-tab', 'unix']
  - 'excel'的定义为：
class excel(Dialect):
    delimiter = ','                # 一行中每个字段的分隔符
    quotechar = '"'                # 引用号，用于引用一个字段（避免被当作多个字段处理）
    doublequote = True            # 使用引用号时是否在字段的前后都加上引用号，还是只在前面加上引用号
    skipinitialspace = False        # 忽略分隔符delimiter之后的空格
    lineterminator = '\r\n'        # 分行符
    quoting = QUOTE_MINIMAL        # 控制何时使用引用号quotechar
# quoting 的取值：QUOTE_ALL表示引用所有字段，QUOTE_MINIMAL表示只引用包含特殊字符的字段
register_dialect("excel", excel)
  - 'excel-tab'与'excel'的区别在于：delimiter = '\t'
  - 'unix'与'excel'的区别在于：lineterminator = '\n'，quoting = QUOTE_ALL
- 自定义dialect的方法如下：
>>> class myDialect(csv.excel):
...     delimiter='|'
...
>>> csv.register_dialect("myDialect", myDialect)            # 登记自定义的dialect
>>> with open("test.csv", 'w', newline='') as f:
...     csv_writer = csv.writer(f, dialect='myDialect')        # 选择使用自定义的dialect进行写入
...     csv_writer.writerows(data)
...
>>> csv.unregister_dialect("myDialect")                    # 删除自定义的dialect
## csv模块还可专门读写字典格式的数据。
##
##
##

♢ openpyxl
## openpyxl：Python的第三方库，用于读写xlsx/xlsm文件。
- 安装：pip install openpyxl
- 一般操作流程为：先打开Workbook（即工作簿），再定位Worksheet（即工作表），然后操作Cell（即单元格）。
- 如果要在Excel中插入图片，需要用到pillow库。
## 创建一个Excel表格。
>>> from openpyxl import Workbook        # 从openpyxl模块导入Workbook类，用于创建和写入表格
>>> wb=Workbook()                        # 创建一个工作簿对象
>>> wb.sheetnames                        # 列出所有工作表的名字，新创建的工作簿只有一个默认工作表
['Sheet']
>>> ws=wb.create_sheet("sheet1", 0)    # 在第一个位置插入新工作表。如果不指定位置就默认在最后插入
>>> #ws.title="Sheet1"                # 设置工作表的名字
>>> wb.save("1.xlsx")                    # 把工作簿保存为一个xlsx文件
>>> wb.close()                        # 关闭对该文件的占用，但该文件的内容仍然保留在内存中可以读取
- 保存工作簿时，如果存在同名文件，会直接覆盖而不会提醒。如果其它程序正在使用该文件就无法保存。
## 打开一个现有的Excel表格。例如，在工作表"Sheet1"中有如下数据。

>>> from openpyxl import load_workbook        # 从openpyxl模块导入load_workbook类
>>> wb=load_workbook("1.xlsx")
>>> wb.sheetnames
['Sheet1', 'Sheet2', 'Sheet3']
>>> ws1=wb[wb.sheetnames[0]]                # 用工作表的名字作为工作簿的键值，可得到该工作表对象的引用
>>> ws1
<Worksheet "Sheet1">
>>> ws1.max_row                            # 获得工作表的最大行数
4
>>> ws1.max_column                        # 获得工作表的最大列数
3
- def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA, data_only=False, guess_types=False, keep_links=True)用于打开一个由filename指定的工作簿。
  - keep_vba=KEEP_VBA    表示保留所有Visual Basic元素。
  - data_only=False        表示当单元格中存在公式时，获得原本的公式，不会只读取公式的计算结果。（每次用Excel打开工作簿时会自动计算公式）
  - guess_types=False    表示读取单元格时，不猜测其数据类型。
  - keep_links=True        表示保留与外部工作簿的链接。
## 读写工作表的值。
- 遍历工作表：
>>> for row in ws1:                        # 遍历工作表的每行，ws1相当于ws1.rows
...     print(row)
...
(<Cell 'Sheet1'.A1>, <Cell 'Sheet1'.B1>, <Cell 'Sheet1'.C1>)
(<Cell 'Sheet1'.A2>, <Cell 'Sheet1'.B2>, <Cell 'Sheet1'.C2>)
(<Cell 'Sheet1'.A3>, <Cell 'Sheet1'.B3>, <Cell 'Sheet1'.C3>)
(<Cell 'Sheet1'.A4>, <Cell 'Sheet1'.B4>, <Cell 'Sheet1'.C4>)
>>> for row in ws1:                        # 遍历每行
...     for cell in row:                    # 遍历每行的单元格
...         print(cell.value, end="\t")        # 取得每个单元格的值
...     print('\n')
...
1       2       3

4       5       6

None    None    None                        # 单元格为空时，返回的值为None

10      11      12

>>> for row in ws1.values:                # 使用工作表的values属性遍历所有单元格的值
...     print(row)
...
(1, 2, 3)
(4, 5, 6)
(None, None, None)
(10, 11, 12)
>>> for x in range(1,11):                    # 通过cell方法遍历一个10行10列的区域，range从1开始
...     for y in range(1,11):
...             ws1.cell(x, y).value
...
（显示略）
- 工作表对象支持索引，用行名、列名或单元格的名字作为工作表的键值，从而访问指定的单元格。
>>> ws1['A']                    # 获得A列所有不为空的单元格的引用
(<Cell 'Sheet1'.A1>, <Cell 'Sheet1'.A2>, <Cell 'Sheet1'.A3>, <Cell 'Sheet1'.A4>)
>>> ws1['1']                    # 获得第1行所有不为空的单元格的引用
(<Cell 'Sheet1'.A1>, <Cell 'Sheet1'.B1>, <Cell 'Sheet1'.C1>)
>>> ws1['A1']                # 获得A1单元格的引用
<Cell 'Sheet1'.A1>
>>> ws1['A1'].value            # 通过单元格的 value 属性获得其值
1
>>> ws1['A1']=2                # 给单元格赋值时不需要指定 value 属性
- 工作表对象支持切片，可以访问某个范围的单元格。
>>> ws1['A1':'B2']
((<Cell 'Sheet1'.A1>, <Cell 'Sheet1'.B1>), (<Cell 'Sheet1'.A2>, <Cell 'Sheet1'.B2>))
- 使用工作表对象的 cell() 方法可以操作一个指定单元格，其原型为def cell(row, column, value=None)。
>>> ws1.cell(2,3)
<Cell 'Sheet1'.C2>
>>> ws1.cell(2,3,12)            # 通过 cell() 方法给单元格赋值
<Cell 'Sheet1'.C2>
>>> ws1.cell(2,3).value        # 使用cell()方法时，即使没有赋值，也会在内存中创建一个单元格，其值为None
12
>>> ws1.cell(2,3).coordinate    # 获得该单元格的坐标
'C2'
## 使用只读或只写模式可以节省占用的内存。
- 用wb = Workbook(write_only=True)可以创建一个只写的工作簿，它的内存开销很小。
  - 它不会创建一个默认的工作表，必须要主动创建。
  - 它只能通过 append() 写入数据。例如：
>>> from openpyxl.worksheet.write_only import WriteOnlyCell
>>> from openpyxl.styles import Font
>>> cell = WriteOnlyCell(ws, value="hello world")
>>> cell.font = Font(name='Courier', size=36)
>>> ws.append([cell, 3.14, None])
  - 这个被创建的只写工作簿只能被保存一次，否则会报错。（可以再创建一个新的）
## 其它笔记。
- 用工作表的append()方法可以在工作表后附加一个可迭代的对象，比如tuple、list、dict、range、generator，也可附加某个或某些单元格。例如：
>>> column1=ws1['A']
>>> ws1.append(column1)
>>> for i in ws1.values:
...     print(i)
...
(1, 2, 3, None)
(4, 5, 12, None)
(None, None, None, None)
(10, 11, 12, None)
(1, 4, None, 10)        # 附加一列会变成一行加在工作表的末尾，这里多出来一列，空白的单元格也会被创建
- 给单元格赋值时，可以输入Excel的公式，例如：ws1["D4"] = "=SUM(A1:C4)"
- 设置行高和列宽的方法：
ws1.column_dimensions['A'].width = 90        # 只写的表格要在写入内容之前设置列宽
ws1.row_dimensions[1].height = 20
- openpyxls提供了多种设置单元格样式的类。例如，下方是使用Font类。
from openpyxl.styles import Font
font1 = Font(name='Calibri',        # 字体
            size=11,                # 字号
            bold=False,            # 加粗
            italic=False,            # 斜体
            underline='None',        # 下划线
            color='FF000000'        # 字体颜色
            ...)
ws1['A1'].Font=font1
ws1['A2'].Font=font1
- 调用以下函数可以转换列的数字序号和字母序号。
>>> from openpyxl.utils import get_column_letter, column_index_from_string
>>> get_column_letter(2)
'B'
>>> column_index_from_string('AA')
27




##
##
##


GUI软件
♢ tkinter
## tkinter（全名为Tk Interface）是Python的标准GUI包，可以兼容类Unix系统、Windows系统，显示经典桌面风格的GUI界面。
- tkinter通过回调函数来响应事件。
- 编写了基于tkinter的脚本之后，可用pyinstaller打包成可执行文件。
## 显示窗口。
- 创建一个窗口的代码如下：
import tkinter

w1 = tkinter.Tk()                      # 创建一个窗口类（在终端执行该命令时会立即显示窗口）
w1.title("mainWindow")                # 设置窗口的标题

w1.geometry("500x300+0+0")            # 设置窗口的尺寸和坐标，格式为widthxheight+x+y
w1.resizable(width=True, height=True)    # 设置宽度、高度是否可变
w1.minsize(500, 300)                    # 设置窗口的最小尺寸

w1.mainloop()                          # 进入主循环
  - 运行mainloop()时会阻塞当前线程，保持窗口的显示，检测到用户的操作就执行相应的动作。
  - mainloop()必须在创建它的线程中运行，在其它线程中调用会使程序崩溃。
  - 运行mainloop()时，tkinter会抓住一些不重要的异常，即使它们发生了也不会使GUI关闭，只会将报错信息显示在终端上。
- 窗口类有一个attributes()方法，功能很强大，如下：
w1.attributes("-topmost", True,     # 使该窗口置顶
                   # "-fullscreen", True,  # 使该窗口为全屏
                   # "-disabled", True,    # 使该窗口无法操作（用户对它的点击、输入统统无效）
                   # "-toolwindow", True,  # 使该窗口为toolwindow
                   # "-alpha", 0.9,        # 设置该窗口的透明度，0代表完全透明，1代表完全不透明
                   )
  - 设置窗口全屏时不会显示窗口的边框，因此不能点击标题栏上的关闭按钮来关闭它。
  - 设置窗口disable之后，按alt+F4也关闭不了它。
  - 尝试了同时设置窗口topmost、fullscreen、disable，结果发现关闭不了它，连任务管理器都不能调出来。最后，新建了一个win10桌面，打开DOS窗口，用taskkill命令才关闭了该窗口。
##
##
##

控件
## 显示控件（widget）。
- 在tkinter中，每个控件都有三种布局方法：pack()、grid()、place()。例如：
  - pack()方法。
L1.pack()                # 将该控件直接放到窗口上，让它自己调整位置
L1.pack(side="top")        # 设置该控件在窗口的位置，可选top、bottom、left、right
L1.pack(fill='y')        # 设置该控件在某一方向填满窗口，可选none、x、y、both
  - grid()方法。
略
  - place()方法。
L1.place(width=10, height=20, x=10, y=20)        # 设置该控件在父容器中的宽度、高度、坐标
L1.place(relwidth=0.5, relheight=0.5, relx=0.2, rely=0.2)    # 设置相对宽度、高度、坐标
  - 可随时调用三种方法来修改控件的位置，但是调用另一种布局方法时可能会毁掉之前的设置。
  - 每个控件在创建时要指定父容器（master），创建后要调用一个布局方法放到窗口中才能显示。例如：
tkinter.Label(w1, text="one", bg="pink").pack()    # 可以在创建该控件的同时打包
- 窗口、控件都可用destroy()方法销毁，这会同时销毁掉以它为父容器的其它控件。例如：
w1.destroy()
## tkinter提供了多种控件，常用的如下。
- Label：标签。可显示文本或图片。
L1 = tkinter.Label(master=w1, text="label1", fg="#FFF",
                     bg="#000", bd=10, font=("Arial", 12), width=10, height=5)
L1.pack()
L1["text"] = "Hello"    # 修改label的显示内容
  - 输入的参数中，text是要显示的文本（默认居中对齐），fg是前景色（即文本的颜色），bg是后景色（用三个十六进制数或已有的颜色名设定一种颜色，不设置的话就没有颜色，是透明的），bd是边框的宽度。
  - tkinter只支持PNG、GIF、PGM、PPM格式的图片，用以下函数导入：
img = tkinter.PhotoImage(file=r"C:\Users\Will\Desktop\1.png", width=200, height=100)
tkinter.Label(w1, image=img).pack(side="left")

- Frame：框架。用于包装一堆控件，作为它们的master。
F1 = tkinter.Frame(w1)
F2 = tkinter.Frame(F1)
tkinter.Label(F2, text="one").pack()
tkinter.Label(F2, text="two").pack()
F2.pack()
F1.pack()
- Button：按钮。
B1 = tkinter.Button(master=w1, text="close", command=B1.destroy)
B1.pack()
B1.flash()        # 让按钮在未激活与激活的外观之间闪烁几次
  - button控件可以将一个函数名赋值给command，当button被触发（即鼠标左键按下再松开）时就会执行该函数。
  - 可以用lambda函数作为command参数，如下：
B1 = tkinter.Button(w1, text="close", command=lambda: print("closing..."))
- Checkbutton：复选按钮。
Check1_var = tkinter.IntVar()        # 创建一个可及时刷新的变量，用于保存复选按钮的状态（1或0）
Check1 = tkinter.Checkbutton(w1, text = "run", variable = Check1_var)
Check1.pack()

Check1.select()        # 设置为选中状态
Check1.deselect()    # 设置为不选中状态
Check1.toggle()        # 在选中与不选中状态之间切换
Check1.invoke()        # 调用此方法相当于模拟用户点击一次复选按钮

Check1_var.get()        # 通过变量Check1_var获得复选按钮的状态
- Entry：输入框。只能让用户输入一行文本。
E1_var = tkinter.Variable()        # 创建一个可及时刷新的变量，用于保存输入框的文本内容
E1 = tkinter.Entry(w1, textvariable=E1_var)
E1.pack()

def get_entry():
    line=E1_var.get()+'\n'        # 获取输入框的文本内容
    T1.insert("end",line)

B1 = tkinter.Button(w1, text="Entry", command=get_entry)
B1.pack()
- Text：文本框。可以让用户输入多行文本，可以插入文本、图片、按钮，甚至当做网页浏览器使用。
T1=tkinter.Text(w1)
T1.pack()
T1.insert("1.0", "Hello\n")    # 在指定位置插入一个字符串，这个位置可以是第几行或已命名的特殊位置
T1.delete("1.2","end")        # 删除从第一行第2个字符到文本末尾之间的内容

T1.config(state="disabled")    # 使文本框不可编辑（用户和程序都不可以对它编辑）
T1.config(state="normal")        # 使文本框可编辑

B1 = tkinter.Button(w1, text="UP")
T1.window_create("end", window=B1)        # 插入按钮

img = tkinter.PhotoImage(file=r"C:\Users\Will\Desktop\scene.png")
T1.image_create("end", image=img)        # 插入图片

## messagebox：消息框，不需要设定master，可以直接显示，但是同时只能显示一个消息框，关闭之后才会显示下一个。
from tkinter import messagebox        # 从tkinter包中导入messagebox模块

# 显示一个信息框，只有一个“确定”按钮
messagebox.showinfo(title="OK", message="operation completed!")
messagebox.showwarning("warning")
messagebox.showerror("error")

# 显示一个询问框，有“确定”、“取消”两个按钮，被用户点击后分别返回True、False
if messagebox.askokcancel("ask", "即将开始更新，确定or取消"):
    messagebox.showerror("更新失败！")

# 显示一个询问框，有“是”、“否”、“取消”三个按钮，被用户点击后分别返回True、False、None
messagebox.askyesnocancel("ask","是or否or取消")

# 显示一个询问框，有“是”、“否”两个按钮
messagebox.askyesno("ask","是or否")
##
##
##

绑定事件
## 每个控件都可以用方法bind()在某个事件上绑定一个函数，一旦该事件发生就调用该函数，并将一个event对象传给函数。例如：
# 在L1的<ButtonPress-1>事件上绑定一个函数print()
L1.bind("<ButtonPress-1>", print)

# 在L1的<Enter>事件上绑定一个用lambda定义的简单命令
L1.bind("<Enter>", lambda event: print(L1["text"]))

- event对象描述了一个事件的多种信息，使用时自行提取event的属性即可。例如：
E1 = tkinter.Entry(w1, text='')
E1.pack()

def check_status(event):
    print(event)
    print(event.keysym)

E1.bind("<Key>", check_status)

# 运行该程序，按下Esc键，终端的显示如下：
<KeyPress event state=Mod1 keysym=Escape keycode=27 char='\x1b' x=289 y=53>
Escape

- 常用的event如下：
<ButtonPress-1>        鼠标左键按下
<ButtonRelease-1>    鼠标左键释放
<Double-Button-1>    鼠标左键双击
# 把上面三个事件名中的1改成2、3，就变成了鼠标滚轮、鼠标右键

<Enter>                鼠标移入该控件
<Leave>                鼠标离开该控件
<Motion>                鼠标在该控件上方移动
<B1-Motion>            在该控件上方按住鼠标左键的前提下，移动鼠标
<FocusIn>            该控件得到焦点（比如用户按Tab切换到它）
<FocusOut>            该控件失去焦点

<Key>                按住任意按键（注意是“按住”，如果用户一直按着，就会反复触发）
# 可以按下任意按键，用.bind("<Key>", print)查看该event的内容，其中就包括键名和键值
# 如果按下字母按键时被中文输入法挡住，程序可能会读取到异常的键值，导致程序出错
<Key-Return>            按住回车键
<Key-y>                输入小写的y
<Key-Y>                输入大写的Y（比如按Shift+Y输入，后切换大小写）
<Shift-Y>            在按住Shift的前提下，按住Y

<Configure>            窗口的大小改变

  - 可以自定义event，需要在前后各加两个尖括号，例如：
E1.bind("<<myEvent>>", print)
- 每个控件都可以用event_generate()方法主动生成一个事件，例如：
E1.bind("<Key-Return>", print)
E1.event_generate("<Key-Return>", when="tail")        # when="tail"是为了让该事件按顺序排队
  - 如果事件是<Key>类型，当焦点不在该控件上时，生成一个事件该控件也不会有反应。
  - 可以使用方法after(self, ms, func=None, *args)让tkinter在指定毫秒后执行某函数（这是tkinter内置的方法，如果使用time.sleep实现该功能就会阻塞线程）。
- bind()方法不输入参数则返回绑定的事件元组，可以用unbind()解绑一个事件。例如：
>>> E1.bind("<<myEvent>>", print)
'15615600print'
>>> print(E1.bind())
('<<myEvent>>',)
>>> E1.unbind("<<myEvent>>")
>>> print(E1.bind())
()
  - 对窗口进行绑定，例如w1.bind()，会绑定其中的所有子控件。
##
##
##

♢ PyQt5
## PyQt5：Python的第三方库，使得Python可以调用Qt5的大部分API。
- 安装：pip install PyQt5==5.10 PyQt5-sip==12.7.0
  - PyQt5-sip库用于让PyQt调用Qt的C++ API。
- 例：
from PyQt5.QtWidgets import QApplication, QWidget
import sys

app = QApplication(sys.argv)    # 每个Qt程序在启动时首先要创建一个QApplication对象，可以输入参数
w = QWidget()                # 创建主窗口
w.show()                        # 显示窗口

sys.exit(app.exec())            # 进入app的主循环，一旦app结束就终止程序

- Qt是一个GUI软件开发框架，基于C++，兼容Windows、Linux、MacOS、iOS、Android。
  - Qt5重构了底层模块，不兼容Qt4。
- 控件：指UI上显示的各种对象，比如窗口、按钮。
  - 通常先创建一个顶级窗口，再以它为父控件，创建其它控件。
  - 当父控件被销毁时，它的所有子控件都会被自动销毁。
  - 多个控件可以叠加显示在同一位置，后显示的控件会显示在上层。
##
##
##
##
##

Qtcore模块
##
##
##
## QTimer类：定时器。
- QTimer(parent: QObject = None)
- 例：
>>> timer = QTimer(w)                            # 创建一个定时器
>>> timer.timeout.connect(lambda:print(1))        # 绑定timeout信号
<PyQt5.QtCore.QMetaObject.Connection object at 0x000001EA668E9668>
>>> timer.setInterval(1000)                    # 设置触发timeout信号的间隔时间（单位为毫秒）
>>> timer.start()                                # 启动定时器（定时器会一直运行，循环触发timeout信号）
1                                            # 可以用timer.start(1000)，在启动时设置间隔时间
1
1
>>> timer.stop()                                # 停止定时器）
>>> timer.start()                                # 可以再次启动
1
1
1
- 下例是设置定时任务，定时器触发一次timeout信号之后就自动停止。
>>> QTimer.singleShot(1000, lambda:print(1))
1
##
##
## QThread类：多线程。
- 用法：自定义一个类，继承QThread类，并重载run()方法。
- 与Python自带的Threading模块相比，QThread创建的线程可以方便地使用信号进行通信。但依然受到GIL的限制。
##
##
##

处理事件
## 为了让Qt程序处理用户触发的事件，可以设置信号与槽函数，也可以重载控件的某种事件的处理函数。
## 信号与槽函数：将控件的某个信号绑定到一个槽函数。
- 例：
w = QWidget()
b = QPushButton("Close", w)
b.clicked.connect(w.close)        # 将一个信号对象与一个槽函数绑定
b.clicked.disconnect(w.close)        # 解绑（如果不存在该绑定关系则报错）

  - 当用户单击按钮时，按钮控件会发送click信号给所有与之绑定的槽函数，从而对该事件做出响应。
  - 一个信号对象可以绑定多个槽函数。
  - 可以将一个信号对象与另一个信号对象绑定，即前一个信号发生时会触发后一个信号。
b2 = QPushButton("Button2", w)
b2.clicked.connect(b.clicked)
- 例：
from PyQt5.QtWidgets import QApplication, QWidget
from PyQt5.QtCore import pyqtSignal

class MyWindow(QWidget):
    _signal = pyqtSignal(str)        # 自定义一个信号，它的形参列表要与其槽函数一致

    def __init__(self):
        super().__init__()
        self._signal.connect(self._slot)
        self._signal.emit("testing...")    # 可以用emit()方法主动发送某种信号

    def _slot(self, string):
        print(string)
        print(self.sender())        # 在槽函数中，可以用self.sender()方法返回信号的发送者的引用

## 常见的信号对象。
- clicked
-
-
-
-
-
## 重载控件的某种事件的处理函数。
- 例：
class Example(QWidget):
    def __init__(self):
        super().__init__()
    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Escape:        # 如果用户按下Esc键，则关闭窗口
            self.close()
-
## 常见的事件处理函数。
- def keyPressEvent(self, event):
    print(event.key())        # 获取用户按下的按键键值，比如按键A的键值是65（不受大小写的影响）
- def mouseMoveEvent(self, event):
    print(event.pos())        # 获取鼠标在窗口内的相对坐标
    print(event.globalPos())    # 获取鼠标在窗口内的全局坐标
  - 默认当用户按住鼠标并移动时才会触发mouseMoveEvent事件。如果设置self.setMouseTracking(True)，则只要用户在窗口范围内移动鼠标，就会触发mouseMoveEvent事件。
-
##
##


QTime类
## QTime类。
- 例：
>>> time = QTime.currentTime()        # 获取当前时间
>>> time
PyQt5.QtCore.QTime(22, 8, 3, 113)        # 一个QTime对象包含时、分、秒、毫秒四项参数
>>> time.hour()
22
>>> time.minute()
8
>>> time.second()
3
>>> time.msec()
113
>>> time.toPyTime()                    # 转换成datetime对象
datetime.time(22, 8, 3, 113000)
>>> time.toString()                    # 转换成字符串
'22:08:03'
## QDate类。
- 例：
>>> date = QDate.currentDate()
>>> date.year()
2019
>>> date.month()
10
>>> date.day()
9
>>> date.dayOfWeek()                    # 获取周几
3
>>> date.toPyDate()
datetime.date(2019, 10, 9)
## QDateTime类。
- 例：
>>> datetime = QDateTime.currentDateTime()
>>> datetime
PyQt5.QtCore.QDateTime(2019, 10, 9, 22, 19, 14, 330)
>>> datetime.toTime_t()            # 转换成时间戳
1570630754
>>> datetime.toPyDateTime()        # 转换成datetime对象
datetime.datetime(2019, 10, 9, 22, 19, 14, 330000)
- PyQt获取的时间默认为本地时间。
>>> datetime_UTC = QDateTime.currentDateTimeUtc()        # 获取UTC时区的时间
>>> datetime.timeZone().id()                            # 查看时区
PyQt5.QtCore.QByteArray(b'Asia/Shanghai')
>>> datetime.toUTC()                                    # 转换成UTC时间
PyQt5.QtCore.QDateTime(2019, 10, 9, 14, 19, 14, 330, PyQt5.QtCore.Qt.TimeSpec(1))
>>> datetime_UTC.toLocalTime()                        # 转换成本地时间
PyQt5.QtCore.QDateTime(2019, 10, 9, 22, 19, 14, 330)
>>> datetime_UTC.toLocalTime().toLocalTime()            # 重复转换也不会出错，该操作有幂等性
PyQt5.QtCore.QDateTime(2019, 10, 9, 22, 19, 14, 330)
##
##
##

QtWidgets模块
QApplication类
## QApplication类：用于创建Qt应用（它采用单例模式）。需要导入：from PyQt5.QtWidgets import QApplication
- app = QApplication.instance()
  - 功能：返回Qt应用的引用，总是返回一个单例对象。
- app.closeAllWindows() -> None
  - 功能：关闭所有窗口。
- app.quit() -> None
  - 功能：终止Qt应用。
-
  - 功能：
-
  - 功能：
-
  - 功能：
-
  - 功能：

##
##
##
##
##

QWidget类
## QWidget类：用于创建普通窗口。需要导入：from PyQt5.QtWidgets import QWidget
- QWidget是所有窗口的基类，是QDialog、QMainWindow、QFrame的父类。
- w = QWidget(parent: QWidget = None)
  - 功能：创建一个窗口。
  - 如果它没有父控件，它就会成为唯一的顶级窗口。
- w.show() -> None
  - 功能：显示控件。
  - 父控件在第一次显示时会初始化布局，将它的各个子控件也显示出来。如果在父控件初始化之后才加入子控件，则需要主动调用子控件的show()方法。
- w.close() -> bool
  - 功能：关闭控件的显示（但并没有销毁）。
  - 如果成功关闭显示，或者该控件本来就没有显示，则返回True。
-
-
## 窗口的特有方法。
- w.setWindowTitle(str) -> None
  - 功能：设置窗口的标题。
- w.setWindowIcon(QIcon) -> None
  - 功能：设置窗口的图标。
  - 例：
from PyQt5.QtGui import QIcon
w.setWindowIcon(QIcon(r"C:\Users\Leo\Pictures\1.jpg"))
- w.isMaximized() -> bool
  - 功能：判断窗口是否被最大化了。
  - 窗口最大化时不一定是全屏，比如限制了窗口最大尺寸时，不能填满屏幕。
- w.isMaximized() -> bool
  - 功能：判断窗口是否被最小化了。
## 控件的通用方法。
- w.setFocus() -> None
  - 功能：使控件得到焦点。
- w.setEnabled(bool) -> None
  - 功能：设置控件是否可以被用户操作，这会影响到它的所有子控件。
- w.isActiveWindow() -> bool
  - 功能：判断控件是否获得了屏幕焦点。
- w.isVisible() -> bool
  - 功能：判断控件现在是被show()显示了，还是被close()关闭显示了。
- w.setToolTip(str) -> None
  - 功能：设置提示语。当鼠标悬停在该控件上方时就会立即显示。
  - 例：
w.setToolTip("This is a tip.\n")                            # 支持转义字符
w.setToolTip("这是一个提示。")                                # 支持Unicode字符
w.setToolTip('This is a <font color="red">tip</font>.')        # 支持HTML语法
  - 可定义ToolTip的字体：
from PyQt5.QtWidgets import QToolTip
from PyQt5.QtGui import QFont
QToolTip.setFont(QFont("微软雅黑", 12))
w.setToolTip('This is a <font color="red">tip</font>.')
-
  - 功能：
-
  - 功能：
-
  - 功能：
-
##
##
##
##

QMainWindow类
## QMainWindow类：用于创建包含菜单栏、工具栏、状态栏的经典风格的窗口。
- w = QMainWindow(parent: QWidget = None)
  - 功能：创建一个主窗口。
## 菜单栏。
- menubar = w.menuBar()
  - 功能：第一次调用将创建菜单栏，重复调用将返回菜单栏这个单例对象的引用。
- menubar.addMenu(str) -> QMenu                # 输入名字
menubar.addMenu(QIcon, str) -> QMenu        # 输入图标和名字
menubar.addMenu(QMenu) -> QMenu            # 输入一个QMenu对象
  - 功能：加入一个菜单。
  - 可以在一个菜单中嵌套另一个菜单，称为子菜单。例：
file_menu = menubar.addMenu("File")
sub_menu = file_menu.addMenu("Recent Files...")
- QMenu.addAction(str) -> QAction
QMenu.addAction(QIcon, str) -> QAction
QMenu.addAction(QAction) -> QAction
  - 功能：在某个菜单下加入一个动作（按钮）。
  - 下例是定义一个普通的动作：
from PyQt5.QtWidgets import QAction

# 定义动作
exit_action = QAction(QIcon(r'C:\Users\Leo\Pictures\1.jpg'), "Exit", w)
exit_action.setShortcut("Ctrl+Q")                        # 设置快捷键
exit_action.setStatusTip("Exit the application.")        # 设置显示在状态栏的提示
exit_action.triggered.connect(app.quit)                # 绑定到一个槽函数

menubar = w.menuBar()
file_menu = menubar.addMenu("File")        # 创建菜单
file_menu.addAction(exit_action)            # 添加动作
  - 下例是定义一个勾选的动作：
def debug_mode(state):        # 触发该槽函数时，会传入一个参数，表示当前按钮是否被勾选
    if state:
        w.statusBar().showMessage("Debug mode is enabled")
    else:
        w.statusBar().showMessage("Debug mode is disabled")

debug_action = QAction("Debug mode", w, checkable=True)
debug_action.setChecked(True)        # 设置按钮初始的状态是否被勾选
debug_action.triggered.connect(debug_mode)

menubar = w.menuBar()
fileMenu = menubar.addMenu("fileMenu")
fileMenu.addAction(debug_action)
- QAction(parent: QWidget = None) -> QAction
QAction(str, parent: QWidget = None) -> QAction
QAction(QIcon, str, parent: QWidget = None) -> QAction
  - 功能：定义一个动作。
## 上下文菜单：即右键菜单。
- 定义上下文菜单需要重载contextMenuEvent()方法。如下：
class MyWindow(QMainWindow):
    def contextMenuEvent(self, event):
        contextMenu = QMenu(self)
        open_action = contextMenu.addAction("open")
        quit_action = contextMenu.addAction("quit")

## 工具栏：显示一些常用的动作，便于使用。
- 例：
w.exit_tool = w.addToolBar("Exit")
w.exit_tool.addAction(exit_action)
## 状态栏。
- statuebar = w.statusBar()
  - 功能：第一次调用将创建状态栏，重复调用将返回状态栏这个单例对象的引用。
- statuebar.showMessage(str, msecs: int = 0)
  - 功能：在状态栏中显示一行字符串。默认永久显示，输入msecs参数可设置最大显示时长。
##
##
##

坐标、尺寸
## 坐标。
- w.pos() -> QPoint
  - 功能：查看控件的坐标，返回一个QPoint对象。
  - 例：
>>> w.pos()
PyQt5.QtCore.QPoint(639, 237)
>>> pos = w.pos()
>>> pos.x()
639
>>> pos.y()
237
  - 顶级窗口的坐标代表其左上角相对于屏幕左上角的距离，子控件的坐标代表其左上角相对于父控件左上角的距离。
  - 顶级窗口的坐标可以移动到屏幕之外，子控件的坐标可以移动到父控件的显示区域之外。
>>> w.mapToGlobal(w.pos())        # 从局部坐标转换成全局坐标（即加上当前控件的坐标）
PyQt5.QtCore.QPoint(1279, 512)
>>> w.mapFromGlobal(w.pos())        # 从全局坐标转换成局部坐标（即减去当前控件的坐标）
PyQt5.QtCore.QPoint(-1, -38)
- w.move(int, int) -> None            # 输入横坐标x、纵坐标y（单位为pixel）
w.move(QPoint) -> None            # 输入一个QPoint对象
  - 功能：移动控件到指定坐标。
## 尺寸。
- w.size() -> QSize
  - 功能：查看控件的尺寸，返回一个QSize对象。
  - 例：
>>> w.size()
PyQt5.QtCore.QSize(640, 480)
>>> size = w.size()
>>> size.width()
640
>>> size.height()
480
- w.resize(int, int) -> None        # 输入宽度width、高度height（单位为pixel）
w.resize(QSize) -> None            # 输入一个QSize对象
  - 功能：调整控件的尺寸。
  - 控件的尺寸不能设置为0或负数，否则控件会被关闭显示。
  - 控件的尺寸不能超过屏幕的可用显示范围，即使用resize()设置了更大的尺寸也不会生效，即使用户用鼠标拖动窗口边框也不能变得更大。
- w.adjustSize() -> None
  - 功能：根据控件需要显示的内容，自动调整尺寸。
- 设置最大尺寸。
w.setMaximumHeight(int) -> None
w.setMaximumWidth(int) -> None
w.setMaximumSize(int, int) -> None
w.setMaximumSize(QSize) -> None
- 设置最小尺寸。
w.setMinimumHeight(int) -> None
w.setMinimumWidth(int) -> None
w.setMinimumSize(int, int) -> None
w.setMinimumSize(QSize) -> None
- 设置固定尺寸。
w.setFixedHeight(int) -> None
w.setFixedWidth(int) -> None
w.setFixedSize(int, int) -> None
w.setFixedSize(QSize) -> None
  - 可以在程序运行时随时改变窗口的尺寸，但是如果设置了固定尺寸，用户就不能再拖动窗口的边界了，只能由程序改变。
## 几何属性。
- w.geometry() -> QRect
  - 功能：查看控件的几何属性，返回一个QRect对象。
  - 例：
>>> w.geometry()
PyQt5.QtCore.QRect(640, 275, 640, 480)
>>> geometry = w.geometry()
>>> geometry.x()            # QRect对象兼容QPoint对象、QSize对象的属性和方法
640
>>> geometry.y()
275
>>> geometry.width()
640
>>> geometry.height()
480
- w.setGeometry(int, int, int, int) -> None        # 输入x、y、width、height
w.setGeometry(QRect) -> None                    # 输入一个QRect对象
  - 功能：设置控件的几何属性。
  - QRect对象提供了一些移动控件的方法，但不会影响到原控件。可以先修改QRect对象，再把它应用到原控件。
>>> geometry = w.geometry()
>>> geometry.right()                # 同理还有left()、top()、bottom()
1279
>>> geometry.moveRight(1000)        # 同理还有moveLeft()、moveTop()、moveBottom()
>>> geometry.topLeft()            # 同理还有topRight()、bottomLeft()、bottomRight()、center()
PyQt5.QtCore.QPoint(361, 275)        # 返回一个QPoint对象
>>> geometry.moveTopLeft(geometry.center())
# 同理还有moveTopRight()、moveBottomLeft()、moveBottomRight()、moveCenter()
>>> w.setGeometry(geometry)        # 把QRect对象应用到原控件
## 获取桌面的尺寸信息。
- 获取桌面窗口的实例：
>>> from PyQt5.QtWidgets import QDesktopWidget
>>> desktop = QDesktopWidget()
- 它兼容QWidget的部分方法，可像QWidget一样查看尺寸：
>>> desktop.size()
PyQt5.QtCore.QSize(1920, 1080)
- 它的特有方法：
>>> desktop.availableGeometry()                # 查看桌面的可用显示范围（略小于屏幕尺寸，因为要减去边框）
PyQt5.QtCore.QRect(0, 0, 1920, 1030)
##
##

布局
## 设置控件的位置时，使用布局方法比使用绝对坐标更好，因为使用布局方法可以适应窗口的伸缩变化，而且在不同平台上的显示效果都一致。
- 不可以直接将多个水平布局、垂直布局组合在一起，但可以将一个布局嵌套成另一个布局中的元素。
- 给一个控件设置了布局之后，只能在该布局的基础上进行修改，不能换成另一个布局。
## QHBoxLayout类：用于实现水平布局（Horizontal Layout），使多个控件在水平方向均匀排列。
## QVBoxLayout类：用于实现垂直布局（Vertical Layout），使多个控件在垂直方向均匀排列。
- 例：
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QHBoxLayout, QVBoxLayout
import sys

app = QApplication(sys.argv)
w = QWidget()
w.show()
button1 = QPushButton("One")
button2 = QPushButton("Two")

hbox = QHBoxLayout()            # 创建一个水平布局（即一行空间）
hbox.addStretch(1)            # 添加一个拉伸因子（拉伸因子会尽可能地挤占空白空间）
hbox.addWidget(button1)        # 添加控件（这些空间会按添加的先后顺序排列）
hbox.addWidget(button2)

vbox = QVBoxLayout()            # 创建一个垂直布局（即一列空间）
w.setLayout(vbox)            # 采用该布局（之后再修改该布局时，会立即生效）
vbox.addStretch(1)
vbox.addLayout(hbox)            # 添加一个布局作为元素
  - 拉伸因子的值越大，挤占空间的优先级越高。
## QGridLayout类：用于实现网格布局，将空间分成多行多列，将控件放在某个格子内，或者占据多个格子。
- 例：
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QGridLayout
import sys

app = QApplication(sys.argv)
w = QWidget()
w.show()

grid = QGridLayout()
w.setLayout(grid)
grid.setSpacing(10)        # 设置每个格子的间距

button1 = QPushButton("Send")
grid.addWidget(button1)                # 添加一个控件，默认使用垂直布局
grid.addWidget(button1, 0, 0)            # 添加一个控件，放在第0行、第0列
textEdit1 = QTextEdit()
grid.addWidget(textEdit1, 1, 0, 2, 2)    # 添加一个控件，占据从第1行、第0列到第2行、第2列之间的格子

- 下例是添加一些按矩阵排列的控件：
positions = [(i, j) for i in range(5) for j in range(4)]
names = ['Cls', 'Bck', '', 'Close',
         '7', '8', '9', '/',
         '4', '5', '6', '*',
         '1', '2', '3', '-',
         '0', '.', '=', '+']
for position, name in zip(positions, names):
    if name == '':
        continue
    button = QPushButton(name)
    grid.addWidget(button, *position)
##
##
##

控件
按钮
## QPushButton类：普通按钮。
- QPushButton(parent: QWidget = None)                # 只输入父控件，则显示一个空白按钮
QPushButton(str, parent: QWidget = None)            # 输入显示内容、父控件
QPushButton(QIcon, str, parent: QWidget = None)        # 输入图标、显示内容、父控件
- 例：
>>> button = QPushButton("Quit", w)
>>> button.clicked.connect(QApplication.instance().quit)    # 将按钮按下的信号绑定到一个槽函数
>>> button.text()                                # 返回按钮的名字
'Quit'
- 可以让普通按钮保持在“按下”或“未按下”状态。
def changeState(pressed):
    if pressed:
        print("On")
    else:
        print("Off")

button.setCheckable(True)                        # 使普通按钮可以保持状态
button.clicked[bool].connect(changeState)        # 绑定信号
button.toggle()                                # 切换状态
## QToolButton类：点击时不会显示虚线边框。
## QCheckBox类：勾选按钮。有“选中”、“未选中”两种状态。
- QCheckBox(parent: QWidget = None)
QCheckBox(str, parent: QWidget = None)
- 例：
def changeState(self, state):
    if state == Qt.Checked:
        print("On")
    else:
        print("Off")

>>> checkBox = QCheckBox("On", w)
>>> checkBox.stateChanged.connect(changeState)        # 将状态改变的信号绑定到一个槽函数
>>> checkBox.isChecked()                            # 判断是否被选中了
True
>>> checkBox.setChecked(True)                        # 设置状态
>>> checkBox.toggle()                                # 切换状态
## QRadioButton类：单选按钮。
##
##
##
##
##
##
##
##
##
##
##
##
##

关于输入
## QLineEdit类：单行输入框，用于输入一行字符串。
- QLineEdit(parent: QWidget = None)
QLineEdit(str, parent: QWidget = None)        # str参数表示输入框的初始内容
- 例：
>>> lineEdit = QLineEdit(w)
>>> lineEdit.show()
>>> lineEdit.setText("hello")            # 设置输入框的内容
>>> lineEdit.text()                    # 获取输入框的内容
'hello'
>>> lineEdit.setMaxLength(10)            # 设置输入内容的最大长度
>>> lineEdit.setReadOnly(True)        # 使输入框变成只读
>>> lineEdit.setEchoMode(QLineEdit.Password)        # 使输入框的内容按密文显示
- 常用信号：
lineEdit.textChanged.connect(...)            # 当输入框的内容改变时（不管是被用户改变，还是被程序改变）
lineEdit.editingFinished.connect(...)        # 当用户输入结束时（比如按下回车、焦点从输入框移动到其它控件）
lineEdit.selectionChanged.connect(...)        # 当用户的选中范围改变时（没有选中范围时不会触发）
## QTextEdit类：多行输入框，用于输入多行字符串，可以插入富文本。
- QTextEdit(parent: QWidget = None)
QTextEdit(str, parent: QWidget = None)
- 当输入的字符串行数过多时，会自动显示一个垂直滚动条。
- 例：
>>> textEdit = QTextEdit(w)
>>> textEdit.show()
>>> textEdit.toPlainText("Hello")            # 设置输入框的纯文本内容
>>> textEdit.toPlainText()                # 获取输入框的纯文本内容（QTextEdit对象没有text()方法）
'Hello'
>>> textEdit.setHtml("<h1>标题一</h1>")    # 设置输入框的html内容
>>> textEdit.toHtml()                        # 获取输入框的html内容
'<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">\n<html><head><meta name="qrichtext" content="1" /><style type="text/css">\np,...
>>> textEdit.clear()                        # 清空输入框
- 关于插入文本：
>>> textEdit.append("Hello")                    # 在末尾附加内容（这会新起一行）
>>> from PyQt5.QtGui import QTextCursor
>>> textEdit.moveCursor(QTextCursor.Start)        # 将光标移动到最前面
>>> textEdit.moveCursor(QTextCursor.End)        # 将光标移动到最后面
>>> textEdit.insertPlainText("Hello")            # 在光标处插入纯文本
>>> textEdit.insertHtml("<h1>标题一</h1>")        # 在光标处插入html
- 下例是将stdout、stderr重定向到textEdit。
from PyQt5.QtWidgets import QApplication, QWidget
from PyQt5.QtCore import QObject, pyqtSignal
from PyQt5.QtGui import QTextCursor

class EmittingStream(QObject):
    output = pyqtSignal(str)      # 定义output信号，接收一个str参数
    def write(self, text):
        self.output.emit(str(text))
    def flush(self):
        pass

class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.log_view = QTextEdit(self)

        # 重定向stdout、stderr，让它们触发output信号，并把信号绑定到logger槽函数
        sys.stdout = EmittingStream(output=self.logger)
        # sys.stderr = sys.stdout        # 重定向stderr的话，程序就不能捕捉异常，容易崩溃

    def logger(self, text):
        """ 接收log信号的槽函数，用于记录日志 """
        self.log_view.moveCursor(QTextCursor.End)
        self.log_view.insertPlainText(text)

# 尝试发送stdout、stderr
print("hello")
raise RuntimeError("testing...")

## QComboBox类：下拉列表。
- QComboBox(parent: QWidget = None)
- 例：
>>> combo = QComboBox(w)
>>> combo.show()
>>> combo.addItem("One")        # 添加一个选项（只是显示一个str）
>>> combo.addItem("Two")
>>> combo.currentText()        # 获取当前的选项
'One'
- 常用信号：
def onActivated(text):
    print(text)

combo.activated[str].connect(onActivated)
## QScrollBar类：滚动条，用于拖动显示区域。
## QSlider类：滑动条，用户可以通过拖动滑动条来调整某个数值。
- QSlider(parent: QWidget = None)
QSlider(Qt.Orientation, parent: QWidget = None)
  - Qt.Orientation有水平、竖直两种显示方向，默认是Qt.Vertical，可设置成Qt.Horizontal。
- 例：
>>> slider = QSlider(Qt.Horizontal, w)            # 创建一个水平显示的滑动条
>>> slider.show()
>>> slider.setValue(100)                        # 设置值（取值范围为0~99，超出范围则设置成最大/小值）
>>> slider.value()
99
- 常用信号：
def changeValue(value):
    print(value)
slider.valueChanged[int].connect(changeValue)    # 绑定取值改变的信号（取值范围为0~99）
## QCalendarWidget类：日历。用于让用户方便地选择一个日期。
- QCalendarWidget(parent: QWidget = None)
- 例：
def getDate(date):    # 传入的date参数是QDate对象
    print(date.toString())

calendar = QCalendarWidget(w)
calendar.show()
calendar.clicked[QDate].connect(getDate)
##
##
##
##
##
##
##
##
##

关于输出
## QLabel类：标签，用于显示一个只读的字符串。
- QLabel(parent: QWidget = None)
QLabel(str, parent: QWidget = None)
- 例：
>>> label = QLabel("hello", w)
>>> label.show()
## QProgressBar类：进度条。
- QProgressBar(parent: QWidget = None)
- 例：
>>> progressBar = QProgressBar(w)
>>> progressBar.show()
>>> progressBar.setValue(100)        # 设置进度值。取值范围为0~100
>>> progressBar.value()
100
>>> progressBar.setValue(99.99)    # 小数部分的值会被舍去
>>> progressBar.value()
99
##
##
##
##
##
##
##
##
##
##
##
##
##
##

关于布局
## QFrame类：框架，用于将多个控件组合在一起。
## QSplitter类：分割器。插入到控件之间，从而用户用户拖动控件的边界。
- QSplitter(parent: QWidget = None)
QSplitter(Qt.Orientation, parent: QWidget = None)
- 例：
from PyQt5.QtWidgets import QApplication, QWidget, QFrame, QHBoxLayout, QSplitter
from PyQt5.QtCore import Qt
import sys

app = QApplication(sys.argv)
w = QWidget()

frame1 = QFrame(w)
frame1.setFrameShape(QFrame.StyledPanel)    # 设置frame的主题，以支持QSplitter
frame2 = QFrame(w)
frame2.setFrameShape(QFrame.StyledPanel)
frame3 = QFrame(w)
frame3.setFrameShape(QFrame.StyledPanel)

splitter1 = QSplitter(Qt.Horizontal)        # 创建一个水平方向的分割器splitter1
splitter1.addWidget(frame1)                # 用splitter1分割topleft和topright
splitter1.addWidget(frame2)

splitter2 = QSplitter(Qt.Vertical)
splitter2.addWidget(splitter1)
splitter2.addWidget(frame3)

hbox.addWidget(splitter2)
##
##
## QTableView
## QListView
## QTreeView
## QListWidget
## QTableWidget
## QTabWidget
## QStackedWidget
## QDockWidget
##
##
##
##
##

对话框
## QDialog类：所有对话框窗口的基类。
## QInputDialog类：输入对话框。
- 例：
text, ret = QInputDialog.getText(w, "Input Dialog", "Please input your name:")
if ret:
    print("Your name is:" + text)
  - text存储用户输入的文本，ret是一个bool值，表示用户是否点击了Yes按钮。
## QFontDialog类：选择字体的对话框。
- 例：
font, ret = QFontDialog.getFont()
if ok:
    lable.setFont(font)
## QColorDialog类：选择颜色的对话框。
- 例：
color = QColorDialog.getColor()
if color.isValid():
    w.setStyleSheet("QWidget {{ background-color: {} }}".format(color.name()))
## QFileDialog类：选择文件的对话框。
- 选择一个文件：
filename, _filter = QFileDialog.getOpenFileName(w, "Open file", ".", "*.py")
                    # 输入参数：父控件、窗口名、打开的目录、筛选的文件名
                    # 返回的filename和_filter都是str型
if filename:
    with open(filename, "r") as f:
        textEdit.setText(f.read())
- 选择多个文件：
filenames, _filter = QFileDialog.getOpenFileNames(w, "Open files", ".", "*.py")
                    # 返回的filenames是一个字符串列表
- 选择保存文件的路径：
>>> QFileDialog.getSaveFileName(w, "Save to", ".", "*.py")
('D:/1/move_files/src/1.py', '*.py')
- 选择一个目录：
>>> QFileDialog.getExistingDirectory(w, "Open file", ".")
'D:/1'
## QMessageBox类：消息框，用于通知用户某个消息。
- 提问框：有Yes、No两个选项。
>>> reply = QMessageBox.question(w, "标题...", "内容...")
>>> reply == QMessageBox.Yes
True
>>> reply == QMessageBox.No        # 当用户点击No选项或关闭按钮时，返回值为QMessageBox.No
False
- 提示框：只有一个Ok选项。
>>> reply = QMessageBox.information(w, "标题...", "内容...")
>>> reply == QMessageBox.Ok        # 当用户点击Ok选项或关闭按钮时，返回值为QMessageBox.Ok
True
- 警告框：只有一个Ok选项。
>>> reply = QMessageBox.warning(w, "标题...", "内容...")
>>> reply == QMessageBox.Ok
True
- 错误框：只有一个Ok选项。
>>> reply = QMessageBox.critical(w, "标题...", "内容...")
>>> reply == QMessageBox.Ok
True
##
##
##
##
##
##
##

QtGui模块
## QFont类：用于选择字体。
- 例：
>>> from PyQt5.QtGui import QFont
>>> QFont("微软雅黑", 12)        # 输入字体名、字号
<PyQt5.QtGui.QFont object at 0x0000023BE20F9358>
## QColor类：用于选择颜色。
- QColor(int, int, int, alpha: int = 255)
  - 前三个参数代表RGB三个通道的值（取值为0~255），alpha参数表示不透明度。
- 例：
>>> from PyQt5.QtGui import QColor
>>> color = QColor(0, 0, 255)            # 选择颜色
>>> color.name()                        # 返回颜色的十六进制值
'#0000ff'
>>> color.isValid()                    # 判断是否为有效的颜色值
True
  - 可以单独访问red、green、blue、alpha通道。
>>> color.alpha()
255
>>> color.setAlpha(0)
## QIcon类：用于导入图片。
- 例：
>>> from PyQt5.QtGui import QIcon
>>> QIcon(r"C:\Users\Leo\Pictures\1.jpg")
<PyQt5.QtGui.QIcon object at 0x0000023BE1C45C18>
## QPixmap类：用于显示图片。
- 例：
>>> pic = QPixmap(r"C:\Users\Leo\Pictures\1.jpg")
>>> label = QLabel(w)
>>> label.setPixmap(pic)            # 用图片填充label
>>> label.show()
>>> w.adjustSize()
## QPainter类：用于绘画。
##
## stylesheet：样式表。
- 子控件会自动继承父控件的stylesheet，为了避免这种情况，应该注明stylesheet的作用对象，如下：
QMainWindow{                            # 作用于QMainWindow类对象
background-color: rgb(255, 255, 0);
color: rgb(255, 85, 0);
}
QMainWindow:mainwindow{                # 只作用于mainwindow对象
background-color: rgb(255, 255, 0);
color: rgb(255, 85, 0);
}
-
##
##

♢ pyqt5-tools
## pyqt5-tools：Python的第三方库，提供了Qt的一些工具。
- 安装：pip install PyQt5-tools==5.10.1.1.3
  - 这些工具安装在Python/Scripts目录下，并且注册在环境变量PATH中，可以输入工具名直接调用。
-
-
## designer：用于设计Qt的GUI界面，生成.ui文件。
- 用法：用designer.exe启动，或在命令行输入designer启动。
##
##
##
##
##
## pyuic5：用于将.ui文件转换成.py文件。
- 用法：
pyuic5 mainwindow.ui -o mainwindow_ui.py
- 可以将.ui文件转换成.py文件之后再导入，如下：
import sys
from PyQt5.QtWidgets import QApplication, QMainWindow
from mainwindow_ui import Ui_MainWindow

class MyWindow(QMainWindow, Ui_MainWindow):  # 多继承，QMainWindow是基类，Ui_MainWindow用于配置
    def __init__(self):
        super().__init__()
        self.setupUi(self)

app = QApplication(sys.argv)
w = MyWindow()
w.show()
sys.exit(app.exec())
- 也可以直接导入.ui文件（但这样不能打包到exe文件中），如下：
from PyQt5 import uic

class MyWindow(QMainWindow):                # 不继承
    def __init__(self):
        super().__init__()
        uic.loadUi("mainwindow.ui", self)    # 调用其setupUi()方法
## pyrcc5：用于将.qrc文件转换成.py文件，便于打包。
- 用法：
pyrcc5 resource.qrc -o resource.py
- 导入图片等资源文件的方法有两种：
  - 使用文件路径直接导入，但这样必须将资源文件与程序打包到同一个文件夹发布。
  - 把资源文件记录到.qrc文件中（使用designer的资源窗口），再转换成.py文件，然后在主脚本中导入。如下：
import resource
QIcon(r":resource/img/logo.ico")    # 使用冒号:加文件路径导入图片，该路径必须与.qrc文件中的一致
##
## 用pyinstaller打包PyQt程序。
1.    写好程序，能用Python解释器成功启动。
2.    将.qrc文件转换成.py文件，然后在主脚本中导入。
3.    到源代码目录下，执行：
pyinstaller mainwindow.py -w -i resource/img/logo.ico
  - 如果启动失败，就先不用-w选项，在终端启动，可以看到报错信息。
4.    将源代码目录下的.ui文件、resource目录都拷贝到dist目录下，因为程序打包时没有集成它们，还需要按相对路径导入。
##
##
##
##
##
##
##
##

designer
##
##
## 按F4进入信号-槽的设置模式
可以自定义signal或slot，等导入该ui文件时再定义相应的方法。

## 在designer中导入图片等资源时，要先点击Resource菜单，创建一个.qrc文件，用于记录导入的所有资源。
- 也可以直接导入文件路径。
##
## 自定义widget，做成插件后便可以显示在designer左侧的widget列表中，也可以通过“promoted widget”功能导入。
https://www.xdbcb8.com/archives/1675.html
https://ilmvfx.wordpress.com/2016/02/16/use-promoted-widgets-in-qt-designer/
##
##
##
##
##
##



# 设计模式

## 设计模式的根本目的是解耦、提高效率。
## Python作为动态语言，其设计模式的实现方法与Java等静态语言不同。有些设计模式Python用自身的语法就可以实现。
##
## 面向对象编程（Object Oriented Programming，OOP）
##
##
- 模块化设计：把可以独立实现的功能分离成一个个模块。
  - 高内聚：将每个功能需要用到的代码都封装到模块中，使模块内部尽量不依赖外部。
  - 低耦合）：让模块与外部的各种联系尽可能地少。
- 单一职责原则    ：每个模块只做它应该做的事，少管闲事，且能独立地把自己的事做好。
- 开闭原则        ：每个模块对扩展开放、对修改关闭。
- 依赖抽象原则    ：每个模块依赖于外部的抽象接口，而不是具体细节。
- 组合优于继承    ：如果两个类之间是is a的关系，应该用继承进行管理，否则使用组合更好。
  - 组合和继承都能实现对象的多态性、提高代码的复用性，但组合能避免类之间的耦合。
  - 继承会加深父类与子类的耦合，破坏子类和父类的封装（导致它们的成员混合在一起）。
## 测试驱动的开发：先规划开发需求、编写测试用例，再开始开发代码。
##
- 发布/订阅（publish/subscribe）模式：消息的发布者（Publisher）会把消息发送到代理（Broker），由代理接受订阅者（Subscriber）的订阅请求并发布消息。
  - Publisher可以同时是Subscriber。
  - 代理可以是一台设备或一个应用程序。
  - 从客户端/服务器模式来看，Publisher和Subscriber都是客户端（Client），Broker则是服务器（Server）。
- 观察者模式与发布/订阅模式很像，但是被观察对象会直接将消息推送给各个观察者，不存在代理。
##
##
## MVC模式：
Model（模型）：负责读写数据库
View（视图）：负责从Model读取数据，显示给用户
Controller（控制器）：从View读取用户的输入信息，向Model发送数据。

软件架构没有银弹，往往是取舍。


##
##
##
:::
