::: v-pre

待看：
- https://python3-cookbook.readthedocs.io/zh_CN/latest/



基本语法
代码规范
## Python代码通常采用PEP8规范。
- 标识符可以使用数字、字母或下划线，不能以数字开头，字母要区分大小写。
  - 标识符不能是关键字或保留字。
  - 把变量名的所有字母都小写，函数名的首字母小写，类名的首字母大写。
- 标识符的命名规范有多种：
  - 下划线命名法：当标识符由多个单词组成时，将单词通过下划线拼接。比如 `my_name`
  - 大驼峰命名法：将所有单词的首字母都大写，直接拼接在一起。比如 `MyName`
  - 小驼峰命名法：类似于大驼峰命名法，但是将第一个单词的首字母小写。比如 `myName`
  - 匈牙利命名法：类似于大驼峰命名法，但是在标识符前加上一个小写字母，表示数据类型。比如 `sMyName`
    - 现代的 IDE 通常支持自动提示标识符的数据类型，因此没必要使用匈牙利命名法。
  - 建议对变量名、函数名采用下划线命名法，或小驼峰命名法，而类名采用大驼峰命名法。
  - 常量名的所有字母都大写，因此不能用驼峰命名法，只能采用下划线命名法。例如：MAX_LEN。



- 给某段代码添加注释时：
  - 注释应该用于解释代码这么做的原因、目的，而不是解释代码的逻辑，因为代码本身应该让人容易看懂其逻辑。


- 使用缩进距离来划分语句块（虽然允许使用花括号但是不提倡），同一语句块的所有语句的缩进距离必须相同（否则解释器运行时会报错）。
  - 通常每级缩进为4个空格。（Tab在不同编辑器中的值不统一，会引发混乱，应该尽量不使用）
  - 通常类和函数的结尾用两个空行分隔，其它语句块用一个空行分隔。
  - 在交互式编程时，输入完一个语句块后要敲一个空行表示结束。
  - 当一个语句块为空时，解释器可能会报错。可以用关键字pass填补空缺。
  - 每行包括行首缩进的最大宽度为79个字符。
- 每行写一条语句，每条语句的结尾不要加分号（虽然允许加分号但是不提倡）。
  - 如果在语句的结尾加分号，就可以在同一行内写多条语句。例如：str1="Hello!"; print(str1)
- 在操作符的两侧、逗号的右侧加上空格，美化排版（但是括号的两侧不需要加空格）。例如：a = f(1, 2) + g(3, 4)
- 用 # 标明单行注释，用三个引号（'''或"""）标明多行注释。
  - 如果将三个引号的注释放在函数的def语句之下，就会被当做说明文档保存。如下：
>>> def fun1(x, y):
...     """Hello World"""        # 三个引号的注释不会被解释器忽略，可以填补语句块的空缺
...
>>> fun1.__doc__
Hello World
  - 整个模块的说明文档应该放在.py文件的开头位置，如下：
"""
This module collects some functions and classes as follows:
...
"""
## 其它。
- 在Linux中，可以在Python脚本的第一行写入 #!/usr/bin/Python3。当使用 ./test.py 的方式运行Python脚本时，Linux就会使用该路径的Python解释器来运行该脚本。
- Python3默认采用utf-8编码来读取Python脚本文件，而Python2没有，因此要在脚本开头声明：
# -*- coding: utf-8 -*-
## 使用Python的一些高级语法虽然能使代码更优雅、简洁，但是也可能导致代码的阅读门槛变高。
##
##

输入输出
## print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
- 功能：将value参数的值显示到终端。
  - sep=' '：如果value有多个，就在它们之间加上sep，合并成一个字符串。
  - end='\n'：输出了value之后，在末尾加上一个换行符。
  - file=sys.stdout：默认输出到stdout。可以改为输出到文件流。
  - flush=False：不刷新缓存区。（输出会被先保存到缓存区，累计了一定数量之后才输出到stdout）
- 例：
>>> print("Hello World", end=" "); print("!")
Hello World !
>>> print("Hello", "World", "!")
Hello World !
- 下例是显示一个进度条：
>>> for i in range(101):
...     print("\rProgress: {:12}{}%".format((i // 10) * '▇', i), end='', flush=True)
...     time.sleep(0.1)
...
Progress: ▇▇▇▇▇▇▇▇▇▇  100%
  - 用回车符 \r 回到行首重新编辑。此时要用flush=True强制刷新缓存区。
## input(prompt=None)
- 功能：将prompt输出到stdout（不会自动换行），然后从stdin读取一行字符串（会忽略末尾的换行符），将它作为返回值。
- 例：
>>> x=input("x=")
x=
##
##
##

运算符
## 算术运算符。
>>> 1 + 2        # 加
3
>>> 1 - 2        # 减
-1
>>> 1 * 2        # 乘
2
>>> 2 ** 3        # 幂运算
8
>>> 2 / 1        # 一个斜杠 / 表示算术除（保留商的小数部分，结果为浮点型）
2.0
>>> 1 // 2        # 两个斜杠 // 表示整除（去除商的小数部分，结果为整型）
0
>>> 1 % 2        # 取模（即取余数）
1
- 整型与浮点型混合运算时，整数会被自动转换成浮点数。
- 数字不可以与字符串混合运算。
- Python中没有自加、自减运算符，可以用 a+=1 、a-=1 的格式实现相同的功能。
- 被除数为0时会抛出异常。如下：
>>> 1 / 0
ZeroDivisionError: division by zero
>>> 1 // 0
ZeroDivisionError: integer division or modulo by zero
## 赋值运算符：即等号 = 。
- 复合赋值运算符：将算术运算符与赋值运算符组合使用。比如x+=1、x-=1。
- 可以用多个等号给多个变量连续赋值：（赋值运算符按照从右往左的运算顺序）
a = b = c = 1
- 可以在等号左边对多个变量同时赋值：
>>> a, b = b, a            # 此时解释器会把等号右边的值复制成元组再依次赋值，所以可以交换变量的值
>>> a, b = [1, 2, 3]        # 等号右边的元素个数要与等号左边的变量数一致
ValueError: too many values to unpack (expected 2)
## 比较（关系）运算符：与C语言相同，包括 >、<、>=、<=、==、!= 。
- 比较的结果为真则返回True，结果为假则返回False。
- 连续比较的例子：
>>> 1<2<3        # 相当于1<2 and 2<3 ，类似数学中的写法
True
>>> 1<2<2
False
>>> (1<2)<2        # 首先比较1<2，得到True。再比较True<2即1<2，得到True
True

比较运算符可以用于int型对象之间，或str型对象之间。

>>> 1 < 2
True
>>> 1 < 'a'                 # 不能混合比较一个int型对象与一个str型对象
TypeError: '<' not supported between instances of 'int' and 'str'
>>> 'a' < 'b' < 'c'
True
>>> 'ac' < 'b'                 # 用于str型对象之间时，是比较首字母的大小
True
>>> 'ca' < 'b'
False
## 逻辑运算符：与C语言不同，与、或、非运算符分别写作and、or、not。
- x and y    相当于：
if x:
    return y
else:
    return x
- x or y    相当于：
if x:
    return x
else:
    return y
- not x    相当于 !bool(x)
  - Python可以使用 ! 、not两种逻辑非运算符，! 通常用于表达式中，not通常与关键字if、in、is搭配使用。
- 例：
>>> 0 and 1
0
>>> 1 and 0
0
>>> 0 or 1
1
>>> 1 or 0
1
>>> not "Hello"
False
## 三目运算符：与C语言的 ... ? ... : ... 不同，写作以下格式：
>>> True if 1>2 else False
False
## 位运算符：与C语言相同。
>>> x=1; y=0
>>> x & y        # 按位与
0
>>> x | y        # 按位或
1
>>> x ^ y        # 按位异或
1
>>> ~ x            # 取反（相当于 -x-1 ）
-2
>>> x << 1        # 左移
2
>>> x >> 1        # 右移
0
## 成员运算符。
- in    ：判断成员是否在序列或集合中。例如：
>>> 'H' in "Hello"
True
- not in
## 身份运算符。
- is    ：判断两个对象是否相同。例如：
>>> a=1; b=1
>>> a is b        # 相当于id(a)==id(b)
True
  - 运算符 is 是判断两个对象的id是否相同，运算符 == 是判断两个对象的值是否相等。如下：
>>> 0 == 0.0
True
>>> 0 is 0.0
False
- is not：相当于id(...)!=id(...)。
##
##
##

选择结构
## Python的选择结构只有if语句。
## if语句：一般格式如下：
if condition:        # if、else语句的末尾要加上冒号
statement_block
elif condition:
statement_block
else:
statement_block
##
##
##

循环结构
## Python的循环结构只有for语句和while语句。
- 可以用break跳出当前层循环，用continue跳到下一次循环。
- for语句、while语句可以与else语句连用，当循环正常结束时就会执行else语句，如果是因为break等原因退出循环，则不会执行else语句。
## for语句：不是用于进行指定次数的循环，而是用于遍历一个迭代器中的元素。
- 一般格式如下：
for var in iterable:
statement_block
else:
statement_block
- 遍历时，每次可以取出多个元素。
for var1,var2 in sequence:        # 相当于for line in sequence；var1,var2 = line
statement_block
else:
statement_block
- for语句在开始遍历一个可迭代对象时，会暂存该对象的值。
>>> def fun1():
...     print("fun1")
...     return [1, 2, 3]
...
>>> for i in fun1():            # Python解释器会调用fun1()，获得一个可迭代对象，然后暂存它
...     print(i)
...
fun1                            # fun1()只会被执行一次
1
2
3
- 用range()可以方便地控制for语句的循环次数。如下：
>>> for i in range(4):
...     print(i)
...
1
2
3
## while语句：一般格式如下：
while condition:
    statement_block
else:
statement_block
##
##
##

Python的for、while循环支持与else连用，如下：
```py
for i in "Hello":
    print(i)
    # break
else:
    print('else...')
```
如果正常结束循环，则执行else语句块；如果用break等方式跳出循环，则不执行else语句块。


变量
## Python中，使用变量之前不需要先定义或声明它，变量会在第一次赋值时被自动创建。
- Python中的变量只是一个标识符，本身没有存储数据。像一个不受限制的指针，可以指向任何类型的对象。
- 访问变量时，实际上是访问变量所指的对象。
- 赋值语句并不会修改变量所指的对象，而是让变量指向另一个对象。
## 变量。
- 创建变量：
>>> a = 1            # 让变量a指向一个值为1的int类对象
>>> a = "Hello"        # 让变量a指向一个str类对象
- 变量本身没有数据类型，只有变量所指的对象才有类的概念。
>>> type(a)            # 用函数type()可以返回变量所指对象的类名
<class 'int'>
- 用关键字 del 可以销毁已创建的变量：
>>> del a
>>> a                # 访问没有创建的变量标识符时会报错
NameError: name 'a' is not defined
## 常量。
- Python中没有关键字const，不能把变量声明成符号常量。通常把一些变量大写所有字母，当作符号常量使用。
- int、float、complex、tuple、str、bytes等数据类型是只读的，也相当于常量。
  - 例如，12345是int类型的常量对象，"Hello World!"是str类型的常量对象。
##
##
##

变量与对象
## Python是纯面向对象的语言，所有标识符、常量都是以对象（某个类的实例）的形式保存，都可以赋值给变量。
- 创建一个对象时，Python会自动分配存储空间，并在修改对象时自动调整容量。
  - 例如，可以创建一个任意大的int型常量，可以把一个list型对象扩展到任意大。
- Python解释器有内存自动回收机制：每个对象有一个引用计数器，记录了当前指向该对象的引用数。当引用数减少为0时，解释器就会回收该对象的内存空间。
  - 可以通过 sys 模块的函数 getrefcount(x) 查看某个对象的当前引用数。

每个Python对象实际上是一个C的结构体：

typedef struct _object {
    Py_ssize_t ob_refcnt;        // 该对象的引用计数
    struct _typeobject *ob_type;    // 该对象的类型
} PyObject;


## 引用类型：指向某个对象的内存地址。
- 引用类型是对指针类型的封装，限制了指针的一些灵活却不安全的功能。
  - 引用类型的变量只是一个标识符，本身没有存储数据，相当于对象的别名。
- 引用类型的变量在创建时就必须赋值，不可能为空。
  - 指针在创建时如果不初始化，就会指向一个无法确定的内存地址，操作这个指针就有危险。
- 值类型的变量存储在栈区，引用类型的变量、引用所指的对象实例存储在堆区（因为要动态分配内存）。
  - 值类型、指针类型赋值时采用值传递（拷贝实际存储的数据），而引用类型赋值时采用引用传递（拷贝内存地址）。
- 因为指针存在安全性、操作复杂等问题，C++、Java、C#、Python中用引用类型取代了指针类型。
  - C++中，用 & 创建一个引用。例如：int &b=a;
  - Java中，基本类型的数据存储在堆栈中，赋值时采用值传递，而非基本类型的数据都是对堆栈上某些数据的引用，赋值时采用引用传递。
  - C#中，可以创建值类型、引用类型、指针类型（不推荐使用）。
## 例：
>>> a=1                # 让变量a指向一个值为1的int类对象
>>> id(a)            # 用函数id()返回变量所指对象的地址
1533892880
>>> a=2; id(a)        # 让变量a指向一个值为2的int类对象
1533892896            # a所指的地址改变了
>>> a=1; id(a)        # 让变量a指向一个值为1的int类对象
1533892880            # a又重新指向之前的地址
- 当用户使用了[-5,256]之内的整数常量、20位以内的字符串常量时，Python解释器会将它们缓存起来，不会销毁，避免用户再使用它们时重复创建对象。因此，重复使用这些常量时，会指向相同的内存地址。如下：
>>> a=256
>>> b=256
>>> a is b
True                    # 指向相同的内存地址
>>> a=257
>>> b=257
>>> a is b
False                # 指向不同的内存地址
- Python的赋值一般是采用引用传递，而不是值传递。因此改变原对象时会改变引用者，改变引用者时会改变原对象。
>>> list1 = [1, 2, 3]
>>> list2 = list1        # 引用传递
>>> list2
[1, 2, 3]
>>> list1[0] = 0        # 改变变量list1所指对象
>>> list1
[0, 2, 3]
>>> list2            # 此时变量list2与变量list1指向同一个对象
[0, 2, 3]
>>> list1 = 1            # 让变量list1指向一个值为1的int类对象
>>> list2            # 此时变量list2与变量list1指向不同对象
[0, 2, 3]
- 用list.copy()、切片等方法可实现浅拷贝。
  - list像一个指针数组，每个指针指向一个对象。浅拷贝时，是创建一个新list，拷贝所有指针。
>>> list1 = [1, 2, 3]
>>> list2 = list1.copy()
>>> list2
[1, 2, 3]
>>> list2 is list1            # 新list不是原list
False
>>> list2[0] is list1[0]        # 新list中的元素就是原list中的元素
True
##
##
##

变量的作用域
## Python中，变量的作用域分为四种级别。
- 局部作用域（Local）
- 外部非全局作用域（Enclosing）
- 全局作用域（Global）
- 内建作用域（Built-in）
## 访问一个变量的标识符时，解释器会按照L→E→G→B的顺序寻找该变量。
- 例：
dir                    # 访问内建作用域中的函数
g = 3                # 全局作用域
def outer():
e = 2            # 外部非全局作用域
def inner():
l = 1        # 局部作用域
- Python中，只有模块（module）、类（class）和函数（def、lambda）才会创建作用域。
  - 在if语句、for语句、while语句等语句块中创建的变量不会被立即销毁、可以被外部访问。
  - 例：
>>> if True:
...     x=1
...
>>> x
1
- Python中，在局部作用域中可以直接读取外部变量的值（如果不重名的话），但是不可以直接修改外部变量。
  - 如果是外部非全局变量，要用关键字 nonlocal 声明才能修改。
  - 如果是全局变量，要用关键字 global 声明才能修改。
  - 例：
>>> a = 1
>>> def fun1():
...     a = 2        # 不能直接修改外部变量，所以这条语句会创建一个局部变量a
...
>>> def fun2():
...     b = a        # 此时变量a是指全局变量a
...     a = 2        # 此时变量a依然是指全局变量a，不能对它进行赋值，这会导致函数在运行时报错
...
>>> fun2()
UnboundLocalError: local variable 'a' referenced before assignment
  - 例：
a = 1
def outer():
global a
a = 2        # 此时变量a是指全局变量a
b = 2
def inner():
nonlocal b
b = 3
##
##
##

基本数据类型
## Python的基本数据类型。
- 可变类型（可读可写）：list、set、dict。
- 不可变类型（只读）：int、float、complex、tuple、str、bytes。
  - 例：
>>> str1 = "Hello"
>>> str1[0] = 'h'        # 修改不可变类型时会报错
TypeError: 'str' object does not support item assignment
>>> str1 = "hello"    # 这并不是修改字符串，而是让变量str1指向另一个对象
>>> str1
'hello'
## Python的数据类型不是关键字，而是通过类来实现的（小写的类名）。
- 数据类型名可以像普通标识符一样修改。
>>> int
<class 'int'>    # int是一个类名
>>> int = 1        # 可以被修改
>>> int
1
- 数据类型名可以用来创建这种类型的对象。
>>> int()
0
- 数据类型名可以用来转换对象的数据类型。
>>> int(3.14)
3
>>> float(3)
3.0

>>> type(1)
<class 'int'>
>>> type(1.0)
<class 'float'>

特殊的 float 常量：
>>> float('+inf')   # 正无穷大
inf
>>> float('-inf')   # 负无穷大
-inf
>>> float('nan')    # 非数字
nan

- 数据类型名可以被继承、重载。
## None：空值。属于NoneType类型。
>>> type(None)
<class 'NoneType'>
>>> None == 0            # 空值并不等于0
False
##
##
##

类型提示：typing 模块


bool
## bool：布尔型。取值为True或Flase（首字母大写）。
- True、Flase在底层是以数字1、0存储。
>>> True - 1
0
>>> True + 1
2
>>> True + False
1
>>> True > False
True
>>> True > True
False
## 使用bool(object)时，只有以下情况会被转换成False，其它情况都会被转换成True。
>>> bool(0), bool(0.0), bool(-0), bool(-0.0)                # 整数0、浮点数0.0以及两者的负数
(False, False, False, False)
>>> bool(1), bool(2), bool(-1), bool('0'), bool("False")
(True, True, True, True, True)
>>> bool(""), bool(()), bool([]), bool({}), bool(None)        # 空值、空的基本数据类型对象
(False, False, False, False, False)
>>> bool(1 > 2)                                            # 结果为假的逻辑表达式
False
##
##
##

数字
## int：整数。
>>> 1 + 2
3
>>> type(1)
<class 'int'>
- int型常量的前缀。
  - 0b    ：转换为二进制。转换失败的话会抛出异常。
  - 0o    ：转换为八进制。转换失败的话会抛出异常。
  - 0x    ：转换为十六进制。转换失败的话会抛出异常。
>>> 0b1100
12
>>> 0011                        # 普通数字常量不能以0开头
  File "<stdin>", line 1
    0011
       ^
SyntaxError: invalid token
>>> 0o14
12
>>> 0x14
20
## float：浮点数。
- 例：
>>> 1.0            # float型在保存时至少会保留一位小数
1.0
>>> 1.0 - 1.0
0.0
- 浮点数可以用字母 e 声明为科学计数法。
>>> 1.2e+3
1200.0
>>> 1.2e-3
0.0012
- float型在计算机中无法精确存储，因此在运算时会有很小的误差。
>>> 0.1 + 0.2
0.30000000000000004
## complex：复数。实部和虚部都是浮点型，用字母 j 标明虚部。
>>> 2j
2j
>>> 1 + 2j
(1+2j)
>>> complex(1, 2)        # 用complex()创建一个复数
(1+2j)
>>> complex(1)        # 没有虚部时，默认为0j
(1+0j)
##
##
##

数制的转换
## 将其它进制的字符串转换成int型数字。
- 使用int()即可转换。
>>> int("100",2)
4
>>> int("100", 8)
64
>>> int("100", 16)
256
  - 字符串中也可以加上表示进制的前缀。
>>> int("0b100",2)
4
>>> int("0bb100",2)            # 前缀不对时会报错
ValueError: invalid literal for int() with base 2: '0bb100'
## 将int型数字转换成其它进制的字符串。
- def bin(int) -> str
  - 功能：将一个整数转换成二进制字符串。
  - 例：
>>> bin(10)
'0b1010'
- def oct(int) -> str
  - 功能：将一个整数转换成八进制字符串。
  - 例：
>>> oct(8)
'0o10'
- def hex(int) -> str
  - 功能：将一个整数转换成十六进制字符串。
  - 例：
>>> hex(16)
'0x10'
##
##
##

list
## list：列表类型，按顺序存储一组元素。
- 可以用中括号 [ ] 创建list，各个元素之间用逗号分隔。
>>> list1 = [1, 2, 3]
>>> list1
[1, 2, 3]
>>> [1, 2, 3, "Hello", list1]        # 列表中的元素可以是任意类型
[1, 2, 3, 'Hello', [1, 2, 3]]
- list(iterable=...) -> list
  - 功能：创建一个list。
  - 例：
>>> list()                    # 不输入参数时，是创建一个空list
[]
>>> list("Hello")                # 输入一个可迭代对象时，其中的各个元素会被拆开
['H', 'e', 'l', 'l', 'o']
##
##
##

增查
## 增。
- list.append(object) -> None
  - 功能：将一个对象附加到list的末尾，作为最后一个元素。
  - 例：
>>> list1 = [1, 2, 3]
>>> list1.append("Hello")
>>> list1
[1, 2, 3, 'Hello']

- list.extend(iterable) -> None
  - 功能：将一个可迭代对象中的每个元素逐个附加到list的末尾。
  - 相当于for i in iterable: list.append(i)。
  - 例：
>>> list1 = [1, 2, 3]
>>> list1.extend("Hello")
>>> list1
[1, 2, 3, 'H', 'e', 'l', 'l', 'o']
>>> list1.extend(1)
TypeError: 'int' object is not iterable


extend() 方法相当于列表相加：
>>> list1 = [1, 2, 3]
>>> list1 += "Hello"
>>> list1
[1, 2, 3, 'H', 'e', 'l', 'l', 'o']



- list.insert(index: int, object) -> None
  - 功能：将一个对象插入到list的指定位置。
  - 例：
>>> list1 = [1, 2, 3]
>>> list1.insert(2, "Hello")
>>> list1
[1, 2, 'Hello', 3]
>>> list1.insert(100, 'Hi')   # 下标允许超过范围，此时相当于 list1.append('Hi')
>>> list1
[1, 2, 'Hello', 3, 'Hi']

## 查。
- list.count(object) -> int
  - 功能：在list中查找某个元素，返回其存在的个数。如果不存在该元素则返回0。
  - 例：
>>> list1 = [1, 2, 3]
>>> list1.count(3)
1
>>> list1.count(4)
0
- list.index(object, start: int=..., stop: int=...) -> int
  - 功能：在list的 [start,stop) 范围内查找某个元素，返回第一个存在的位置。如果不存在该元素则抛出异常。
  - 例：
>>> list1 = [1, 2, 3]
>>> list1.index(3)
2
>>> list1.index(3, 0, 2)
ValueError: 3 is not in list
>>> list1.index(3, 0, 3)
2
- list.copy() -> list
  - 功能：返回list的一个浅拷贝。
##
##
##

改删
## 改。
- list.sort(key=None, reverse=False) -> None
  - 功能：对list进行排序。（这会改变原list）reverse=True时是反向排序。
  - 例：
>>> list1 = [1, 3, 2]
>>> list1.sort()
>>> list1
[1, 2, 3]
>>> list1.sort(reverse=True)
>>> list1
[3, 2, 1]
- list.reverse() -> None
  - 功能：翻转list。（这会改变原list）
  - 例：
>>> list1 = [1, 2, 3]
>>> list1.reverse()
>>> list1
[3, 2, 1]
## 删。
- list.clear() -> None
  - 功能：清空list，删除所有元素。
  - 例：
>>> list1 = [1, 2, 3]
>>> list1.clear()
>>> list1
[]
- list.remove(object) -> None
  - 功能：删除list中的某个元素（只会删除第一个存在）。如果不存在该元素则抛出异常。
  - 例：
>>> list1 = [1, 2, 3]
>>> list1.remove(1)
>>> list1
[2, 3]
>>> list1.remove(1)
ValueError: list.remove(x): x not in list
- list.pop(index: int) -> object
  - 功能：删除list中的某个元素（下标为index的那个），并返回它。
  - 如果index所指的元素不存在，则抛出异常。
  - 如果index为空，则取出最后一个元素。
  - 如果list为空，则抛出异常。
  - 例：
>>> list1 = [1, 2, 3]
>>> list1.pop(2)
3
>>> list1.pop()
2
>>> list1.pop()
1
>>> list1.pop()
IndexError: pop from empty list
  - list.pop()的效率很高，可以与list.append()搭配使用，把list用作先入后出的栈。
  - list.pop(index)的效果较低，因为每取出一个前面的元素，都要移动后面所有元素的位置。
##
##
##

列表生成式
## 列表生成式：通过遍历某个序列来生成列表。
>>> [i for i in range(5)]
[0, 1, 2, 3, 4]
- 可以加上if条件：
>>> [i for i in range(5) if i%2==0]
[0, 2, 4]
- 可以使用多个for语句（这并不是同时遍历，而是像多维数组一样逐层遍历）。
>>> [x+str(y) for x in "ABC" for y in range(1,4)]
['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']
## 用括号 () 写出的是生成器，不是元组。
>>> (i for i in range(5))
<generator object <genexpr> at 0x7fde23dcd780>
## 字典生成式：通过遍历某个序列来生成字典。
>>> {i:bin(i) for i in range(5)}
{0: '0b0', 1: '0b1', 2: '0b10', 3: '0b11', 4: '0b100'}
## 集合生成式：通过遍历某个序列来生成集合。
>>> {i for i in range(5)}
{0, 1, 2, 3, 4}
##
##
##

tuple
## tuple：元组类型，相当于只读的list。
- 可以用小括号 ( ) 创建tuple，各个元素之间用逗号分隔。
>>> tuple1 = ("Hello", "World")
>>> tuple1
('Hello', 'World')
  - 如果只有一个元素，则要加上逗号，强调为元组。
>>> (1)            # 被看做int类对象
1
>>> (1,)            # 被看做tuple类对象
(1,)
- tuple(iterable=...) -> tuple
  - 功能：创建一个tuple。
  - 例：
>>> tuple()                    # 不输入参数时，是创建一个空tuple
()
>>> tuple("Hello")
('H', 'e', 'l', 'l', 'o')        # 输入一个可迭代对象时，其中的各个元素会被拆开
- tuple中的元素不能改变（每个位置只能指向固定的对象），但如果这些对象本身是可变类型，则可以被修改。
>>> tuple1=(1, 2, [])
>>> tuple1
(1, 2, [])
>>> tuple1[2] = [3]            # 不能改变某个位置所指的对象
TypeError: 'tuple' object does not support item assignment
>>> tuple1[2].append(3)        # 可以修改这个对象本身
>>> tuple1
(1, 2, [3])
## tuple的常用方法较少，只是兼容两个list的查询方法。
- tuple.count(object) -> int
- tuple.index(object, start: int=..., stop: int=...) -> int
##
##
##

str、bytes
## Python中没有字符类型，只有字符串类型。一个字符就是一个长度为1的字符串。
## Python3中，解释器在内存中处理字符串时默认采用str类型，与外部交互时才转换成bytes类型。
- str：字符串类型，以字符为单位处理字符串。
  - str相当于只能存储字符的tuple。
  - 采用 Unicode 编码，每个字符占用 8 字节。
- bytes：字节类型，与str的用法相同，但采用更底层的编码格式（比如utf-8、ASCII），以字节为单位处理字符串。
- bytearray：相当于列表类型的bytes，可以被修改。
  - 例：
>>> bytearray(3)                # 直接输入数字，是创建一个指定长度的bytearray
bytearray(b'\x00\x00\x00')
>>> bytearray('hello')        # 不能直接输入str类型，要转换成bytes类型
TypeError: string argument without an encoding
>>> bytearray('hello'.encode())
bytearray(b'hello')
>>> b = bytearray('hello'.encode())
>>> del b[0]
>>> b
bytearray(b'ello')
## 字符串常量。
- 字符串常量的定界符有三种。
  - 单引号 ' ：此时字符串中不能包含单引号。
  - 双引号 " ：此时字符串中不能包含双引号。
  - 三引号 ''' 或 """    ：此时字符串中可以包含单引号、双引号，而且可以在写入时换行。例如：
>>> """,,,'hello',,,"world"
...    ,,,"""
',,,\'hello\',,,"world"\n\t,,,'
- 字符串常量的可用前缀。
  - r：声明为raw（原始字符)，让反斜杠不发生转义。
>>> print(r"Hello!\n")
Hello!\n
  - b：声明为bytes对象。
>>> b"Hello"
b'Hello'
>>> b"你好"            # 该字符串只能包含ASCII字符，否则不能声明为bytes对象
SyntaxError: bytes can only contain ASCII literal characters.
  - u：声明为Unicode字符。
>>> u"你好"
'你好'
>>> u"\u4f60\u597d"
'你好'
  - ASCII码中的非显示字符可以用一个\x加两个十六进制数表示。
>>> '\v\f\b'
'\x0b\x0c\x08'
## 常用方法。
- str(...)
  - 功能：创建str对象。
  - 例：
>>> str()                            # 不输入参数时，是创建一个空str
''
>>> str(b"Hello", encoding="utf-8")    # 将一个bytes对象转换成str对象
'Hello'
>>> str(5)                            # 将其它类型的对象转换成str对象
'5'
- bytes(...)
  - 功能：创建bytes对象。
  - 例：
>>> bytes()                            # 不输入参数时，是创建一个空bytes
b''
>>> bytes("Hello", encoding="utf-8")    # 将一个str对象转换成bytes对象
b'Hello'
>>> bytes(5)                            # 创建一个5字节大小的bytes对象
b'\x00\x00\x00\x00\x00'
- str.encode(encoding='utf-8', errors='strict')
  - 功能：对str对象进行编码，返回一个bytes对象。
  - errors='strict'表示采用严格模式，一旦编码出错就抛出异常。
  - 例：
>>> "www.你好.com".encode()
b'www.\xe4\xbd\xa0\xe5\xa5\xbd.com'
  - Python解释器中看不到str对象的Unicode值，可以用"unicode_escape"编码格式将str对象显示地转换成Unicode格式。
>>> "www.你好.com".encode("unicode_escape")
b'www.\\u4f60\\u597d.com'                        # 该字符串的内容被改变了，不能按正常格式解码
>>> "www.你好.com".encode("unicode_escape").decode("unicode_escape")
'www.你好.com'
- bytes.decode(encoding='utf-8', errors='strict')
  - 功能：对bytes对象进行解码，返回一个str对象。
  - 例：
>>> b'www.\xe4\xbd\xa0\xe5\xa5\xbd.com'.decode()
'www.你好.com'
##
##
##

查
## 查。
- str.count(sub, start: int=..., stop: int=...) -> int
- str.index(sub, start: int=..., stop: int=...) -> int
- str.find(sub, start: int=..., stop: int=...) -> int
  - 功能：在str的 [start,stop) 范围内查找某个字符串，返回第一个存在的位置。如果不存在该元素则返回-1。
  - 当元素不存在时，str.find()、str.rfind()会返回-1，而str.index()会抛出异常。
  - 例：
>>> "Hello".find("H")
0
>>> "Hello".find("o", 0, 4)
-1
>>> "Hello".find("o", 0, 5)
4
因此截取字符串时可能出错，如下：
>>> s = 'cmd.exe'
>>> s[:s.rfind('.')]
'cmd'                   # 成功截取文件名
>>> s = 'cmd'
>>> s[:s.rfind('.')]
'cm'                    # 出错



- str.rfind(sub, start: int=..., stop: int=...) -> int
  - 功能：在str的 [start,stop) 范围内，从右向左查找某个字符串，返回第一个存在的位置（正常顺序的位置）。如果不存在该元素则返回-1。
  - 例：
>>> "Hello".rfind("H")
0
>>> "Hello".rfind("o", 0, 4)
-1
>>> "Hello".rfind("o", 0, 5)
4
## 判断字符串的类型。
- str.startswith(prefix) -> bool
  - 功能：如果str以指定的字符串开头。则返回True。
  - prefix是一个字符串，或者是包含多个字符串的元组（否则会报错）。
  - 例：
>>> "Hello".startswith("He")
True
>>> "Hello".startswith(("H","h"))
True
- str.endswith(suffix) -> bool
  - 功能：如果str以指定的字符串结尾。则返回True。
  - suffix是一个字符串，或者是包含多个字符串的元组（否则会报错）。
  - 例：
>>> "Hello".endswith("o")
True
>>> "Hello".endswith(("O","o"))
True
- str.isalnum() -> bool
  - 功能：如果str不为空，且所有字符都是字母或数字，则返回True。
  - 例：
>>> "1G".isalnum()
True
>>> "-1G".isalnum()
False
- str.isalpha() -> bool
  - 功能：如果str不为空，且所有字符都是字母，则返回True。
  - 例：
>>> "1G".isalpha()
False
>>> "Hello".isalpha()
True
- str.isdecimal() -> bool
  - 功能：如果str不为空，且所有字符都是十进制数字，则返回True。
  - 例：
>>> "12".isdecimal()
True
>>> "1.2".isdecimal()
False
- str.islower() -> bool
  - 功能：如果str中包含字母，且所有字母都是小写，则返回True。
  - 例：
>>> "12".islower()
False
>>> "12hello".islower()
True
- str.isupper() -> bool
  - 功能：如果str中包含字母，且所有字母都是大写，则返回True。
  - 例：
>>> "HELLO".isupper()
True
>>> "Hello".isupper()
False
- str.istitle() -> bool
  - 功能：如果str为标题格式，则返回True。
  - 例：
>>> "Hello World! 123".istitle()
True
##
##
##

改
## 改。
- str.replace(old: str, new: str, count: int=...) -> str
  - 功能：返回str的一个副本，将其中的old字符串替换成new字符串，最多替换count次。
  - 若count为空，或者为负数，则替换无限次。
  - 例：
>>> "Hello".replace("l", "L")            # 替换无限次
'HeLLo'
>>> "Hello".replace("l", "L", -1)        # 替换无限次
'HeLLo'
>>> "Hello".replace("l", "L", 0)        # 替换0次
'Hello'
>>> "Hello".replace("l", "L", 1)        # 替换1次
'HeLlo'
- str.lower() -> str
  - 功能：返回str的一个副本，将其中的所有字母转换成小写。
  - 例：
>>> "Hello".lower()
'hello'
- str.upper() -> str
  - 功能：返回str的一个副本，将其中的所有字母转换成大写。
  - 例：
>>> "Hello".upper()
'HELLO'
- str.title() -> str
  - 功能：返回str的一个副本，将它转换成标题格式，即每个字段的首字母大写。
  - 例：
>>> "hello world! 123".title()
'Hello World! 123'
- str.split(sep: str=..., maxsplit: int=...) -> list
  - 功能：以sep作为分隔符，将str分割成多段，返回一个list。最多分割maxsplit次。
  - 若sep为空，则以所有空白字符（ \t\n\r\x0b\x0c）作为分隔符。
  - 若maxsplit为空，或者为负数，则分割无限次。
  - 例：
>>> "www.baidu.com..test".split(".")
['www', 'baidu', 'com', '', 'test']        # 如果有两个连续的分隔符，分割出来的是空字符串
>>> "www.baidu.com..test".split(".", 1)
['www', 'baidu.com..test']
>>> "11 \t\n\r\v\f22".split()
['11', '22']
- str.join(iterable) -> str
  - 功能：以str作为分隔符，将一个可迭代对象中的各个元素拼接成一个字符串，返回该字符串。
  - 输入的可迭代对象中的所有元素必须都是str类型，否则会抛出异常。
  - 例：
>>> ",".join([1, 2, 3])
TypeError: sequence item 0: expected str instance, int found
>>> ",".join(["1", "2", "3"])
'1,2,3'
##
##
##

格式化字符串
## str.format(*args: Any, **kwargs: Any) -> str
- 功能：以str为基础，生成一个经过格式化的字符串。
- 例：
>>> "{} {}!".format("Hello", "World")                # 字符串中的 {} 会被format()中的参数依次替换
'Hello World!'
>>> "{} {}!".format(123, [1, 2])                    # format()中的参数可以是任意类型
'123 [1, 2]!'
>>> "{{{} {}!}}".format("Hello", "World")            # 如果想在字符串中显示花括号，则要转义成 {{ }}
'{Hello World!}'
>>> "{0} {1}!".format("Hello", "World")            # 可以用 {n} 的格式指定要替换的元组参数
'Hello World!'
>>> "{0} {arg2}!".format("Hello", arg2="World")    # 可以用 {key} 的格式指定要替换的字典参数
'Hello World!'
- 在 {} 中可以加上 :n ，控制输出样式。
  - 控制输出位数。
>>> "{:4}".format(12)            # 至少输出4位，不足的位默认用空格填补
'  12'
>>> "{:04}".format(12)        # 至少输出4位，不足的位用0填补
'0012'
  - 关于对齐。
>>> "{:4}".format("12")        # 输入参数为int类型时默认右对齐，为str类型时默认左对齐
'12  '
>>> "{:<4}".format(12)        # 左对齐
'12  '
>>> "{:>4}".format("12")        # 右对齐
'  12'
>>> "{:^4}".format("12")        # 居中对齐
' 12 '
  - 关于正负号。
>>> "{:+4}".format(-12)        # 输出时总是加上正负号
' -12'
>>> "{:-4}".format(12)        # 输出负数时才加上负号
'  12'
  - 转换进制。
>>> "{:b}".format(12)            # 输出为二进制（输入必须为int型）
'1100'
>>> "{:#b}".format(12)        # 加上 # ，则会根据当前进制自动加上0b、0o、0x前缀
'0b1100'
>>> "{:o}".format(12)            # 输出为八进制（输入必须为int型）
'14'
>>> "{:x}".format(12)            # 输出为小写的十六进制（输入必须为int型）
'c'
>>> "{:X}".format(12)            # 输出为大写的十六进制（输入必须为int型）
'C'
  - 关于浮点数。
>>> "{:f}".format(12)                # 输出为float类型（小数点后默认保留6位）
'12.000000'
>>> "{:e}".format(12)                # 输出为科学计数法（小数点后默认保留6位）
'1.200000e+01'
>>> "{:.4f}".format(12.3456789)    # 小数点后最多输出4位（会进行四舍五入）
'12.3457'
>>> "{:.4}".format(12.3456789)    # 总共最多输出4位（会进行四舍五入）
'12.35'
## 其它格式化方法。


>>> "Hi".center(4,"-")
'-Hi-'
- str.ljust(width: int, fillchar: str=...) -> str
  - 功能：返回str的一个副本，将它左对齐，至少输出width位，不足的位用fillchar填补。
  - fillchar只能是单个字符，默认是空格。
  - 例：
>>> "Hi".ljust(4,"-")
'Hi--'
- str.rjust(width: int, fillchar: str=...) -> str
  - 功能：返回str的一个副本，将它右对齐，至少输出width位，不足的位用fillchar填补。
  - 例：
>>> "Hi".rjust(4,"-")
'--Hi'
- str.center(width: int, fillchar: str=...) -> str
  - 功能：返回str的一个副本，将它居中对齐，至少输出width位，不足的位用fillchar填补。
  - 例：


- str.strip(chars: str=...) -> str
  - 功能：返回str的一个副本，将它左右两侧每个匹配 chars 的字符去掉。
  - chars 是一个字符串，默认匹配所有空白字符（即string.whitespace）。
  - 例：
>>> '  Hi\n\r'.strip()
'Hi'
>>> '--Hi--'.strip('--')
'Hi'
>>> 'Hello'.strip('lo')  # 只要该字符存在于 chars 中，就去掉它
'He'

- str.lstrip(chars: str=...) -> str
  - 功能：返回str的一个副本，将它左侧匹配 chars 的字符去掉。
  - 例：
>>> '  Hi\n\r'.lstrip()
'Hi\n\r'
- str.rstrip(chars: str=...) -> str
  - 功能：返回str的一个副本，将它右侧匹配 chars 的字符去掉。
  - 例：
>>> '  Hi\n\r'.rstrip()
'  Hi'

##
##
##

字符串的转换
## 字符串的转换。
- 可以用int()把int格式的字符串转换成int型对象。
>>> int("123")
123
>>> int("3.14")
ValueError: invalid literal for int() with base 10: '3.14'
- 不能用int()把字符转换成数字，因为Python并不是按ASCII码存储字符。
>>> int("H")
ValueError: invalid literal for int() with base 10: 'H'
- 可以用float()把float格式的字符串转换成float型对象。
>>> float("3.14")
3.14
>>> float("314")
314.0
- 将list转换成str。
  - 直接用str()转换会留下两端的中括号。
"['Hello', 'World', '!']"
>>> str([1, 2, 3])
'[1, 2, 3]'
  - 如果list中的元素全是字符串，可以用join()合并成一个字符串。
>>> ''.join(["Hello", "World"])
'HelloWorld'
  - 如果list中的元素不全是字符串，就先将它们转换成字符串，再用join()合并。
>>> list1 = [1, 2, 3]
>>> list2 = []
>>> for i in list1:
...     list2.append(str(i))
...
>>> ",".join(list2)
'1,2,3'
## 单个字符的转换。
- def chr(code: int) -> str
  - 功能：根据编码值生成一个Unicode字符。code的取值范围为区间 [0 , 0x110000)。
  - 例：
>>> chr(0)
'\x00'
>>> chr(65)
'A'
>>> chr(1000)
'Ϩ'
- def ord(char:[str, bytes]) -> int
  - 功能：返回一个Unicode字符的编码值。
  - 例：
>>> ord("A")
65


在 Python 的底层，存储字符串时是存储其 Unicode 值，因此不能用 int() 强制类型转换成 ASCII 码。
```py
>>> int('A')
ValueError: invalid literal for int() with base 10: 'A'
>>> int(b'A')
ValueError: invalid literal for int() with base 10: b'A'
```

但是存储 bytes 对象时是存储每个字符的 ASCII 码，因此索引单个元素时是返回其 ASCII 码，索引切片时是返回字符。
```py
>>> b = b'Hello'
>>> b[0]
72
>>> b[0:1]
b'H'
```




序列
## 序列（sequence）：包括list、tuple、str、bytes。
- 序列支持索引和切片。
- 序列支持用加号 + 拼接。
>>> [1] + [2]
[1, 2]
>>> (1,) + (2,)
(1, 2)
>>> "Hello" + "World"
'HelloWorld'
>>> {1} + {2}                # 不支持
TypeError: unsupported operand type(s) for +: 'set' and 'set'
>>> {1:1} + {2:2}            # 不支持
TypeError: unsupported operand type(s) for +: 'dict' and 'dict'
- 序列支持用乘号 * 复制。
##
##
##

索引
## 索引：用 [下标] 选取一个元素。
- [0]指向第一个元素，[n]指向第n+1个元素。
>>> list1 = [1, 2, 3]
>>> list1[0]
1
- 下标可以为负数，表示从右往左索引。[-n]指向从右往左的第n个元素。
>>> list1[-1]        # [-1]指向最右端的那个元素，相当于[len(list1)-1]
3
>>> list1[-0]        # [-1]相当于[0]
1
- 下标不能超过列表长度，否则会报错。即下标的取值范围为区间 [-len, len-1] 。
>>> list1[3]
IndexError: list index out of range
>>> list1[-4]
IndexError: list index out of range
## list类型的索引结果可以被修改。
- 修改索引结果会改变原list。
>>> list1 = [1, 2, 3]
>>> list1[0] = 0
>>> list1
[0, 2, 3]
>>> del list1[0]        # 可以用关键字del直接删除选中的元素
>>> list1
[2, 3]
- 如果把索引结果赋值给其它变量，则得到的是该元素的真实引用。
>>> list1 = [1, 2, 3]
>>> list2 = [list1]
>>> a = list2[0]
>>> a is list2[0]
True
>>> a[:] = []            # 可以通过该引用修改元素
>>> list2
[[]]
##
##
##

切片
## 切片：用 [头下标:尾下标] 选取一部分元素，区间为 [头下标, 尾下标) 。
>>> list1 = [1, 2, 3]
>>> list1[0:2]
[1, 2]
>>> list1[0:-1]
[1, 2]
>>> list1[0:0]
[]
- 切片中的下标可以不填。
>>> list1[:3]        # 头下标的默认值为0
[1, 2, 3]
>>> list1[0:]        # 尾下标的默认值为 len(list1)
[1, 2, 3]
>>> list1[:]
[1, 2, 3]
- 切片中的下标可以越界，不会报错。
>>> list1[0:3]        # 当切片长度过大时，只会截取有效元素
[1, 2, 3]
>>> list1[10:3]        # 当切片长度小于1时，截取结果为空列表
[]
>>> list1[0:-4]
[]
- 切片中可以设置第三个参数——步进值：表示每隔几个元素索引一次。
>>> print(str1[::2])
wrd                        # 提取索引为0、2、4的元素
>>> str1[::-1]            # 步长值为-1时可以翻转切片
'dlrow'
>>> list2 = [1, 2, 3, 4, 5]
>>> list2[::1]
[1, 2, 3, 4, 5]
>>> list2[::2]
[1, 3, 5]
>>> list2[::5]
[1]
  - 步进值为负数时是从右向左索引。
>>> list2[::-1]            # 翻转
[5, 4, 3, 2, 1]
>>> list2[::-2]
[5, 3, 1]

可以对切片赋值，这会修改原list
>>> list2
>>> list1[0:2] = [1, 2, 3]    # 赋值时，元素个数不必一致
>>> list1
[1, 2, 3, 3]
>>> list1[0:2] = []            # 赋值为空时，相当于删除这部分元素
>>> list1
[3, 3]
>>> del list1[:]                # 可以用关键字del直接删除选中的元素
>>> list1
[]

可以将切片赋值给其它变量，这会得到该片段的浅拷贝，相当于 list.copy() 。
>>> list1 = [1, 2, 3]
>>> list2 = list1[:]
>>> list1 is list2
False
>>> list1[:] = []
>>> list2
[1, 2, 3]
##
##
##

set
## set：集合类型，无序地存储一些元素，并且会自动去重。
- 可以用 {value1, value2, ...} 的格式创建set。
>>> {1, 2, 3, 3}
{1, 2, 3}
  - set中的元素必须是不可变类型。
- set(iterable=...) -> set
  - 功能：创建一个set。
  - 例：
>>> set()                # 不输入参数时，是创建一个空set
set()
>>> set("Hello")            # 输入一个可迭代对象时，其中的各个元素会被拆开，并自动去重
{'l', 'e', 'o', 'H'}
  - 创建空集合时只能用set()，因为空的花括号 {} 表示空字典。
- set可以进行交集、并集、差集运算。
>>> a = {'YY', 'XY'}
>>> b = {'X', 'Y'}
>>> a & b                # 交集
set()
>>> a | b                # 并集
{'X', 'YY', 'XY', 'Y'}
>>> a - b                # 差集（属于集合a但不属于集合b的元素）
{'YY', 'XY'}
>>> a ^ b                # 并集-交集（两个集合不共同拥有的元素）
{'XY', 'YY', 'X', 'Y'}
##
##
##

增查改删
## 增。
- set.add(x) -> None
  - 功能：增加一个元素到set中。
  - 每次增加元素时，set会判断该元素是否已存在，如何已存在则不加入。
  - 例：
>>> a = {1, 2, 3}
>>> a.add(3)            # 加入一个重复的元素
>>> a
{1, 2, 3}
>>> a.add(4)            # 加入一个不重复的元素
>>> a
{1, 2, 3, 4}

合并两个集合，不能用加号 + ，可以用 | 或 set.union() 方法：
>>> set({1}) + set({2})
TypeError: unsupported operand type(s) for +: 'set' and 'set'
>>> set({1}) | set({2})
{1, 2}
>>> s = {1}
>>> type(s)
<class 'set'>
>>> s.union({2})
{1, 2}
>>> s   # 原集合并没有被修改
{1}



## 查。
- set.copy() -> set
  - 功能：返回set的一个浅拷贝。
  - 例：
>>> a = {1, 2, 3}
>>> a.copy()
{1, 2, 3}
## 改。
- set.update(iterable) -> None
  - 功能：更新一些元素到set中。
  - 如果输入的元素在原set中存在，则无影响；如果输入的元素在原set中不存在，则加入它们。
  - 例：
>>> a = {1, 2, 3}
>>> a.update({3, 4})
>>> a
{1, 2, 3, 4}
>>> a.update(3)
TypeError: 'int' object is not iterable
## 删。
- set.clear() -> None
  - 功能：清空set，删除所有元素。
  - 例：
>>> a = {1, 2, 3}
>>> a.clear()
>>> a
set()
- set.remove(object) -> None
  - 功能：删除list中的某个元素。如果不存在该元素则抛出异常。
  - 例：
>>> a = {1, 2, 3}
>>> a.remove(1)
>>> a.remove(1)
KeyError: 0
- set.discard(object) -> None
  - 功能：删除list中的某个元素。如果不存在该元素则无影响。
  - 例：
>>> a = {1, 2, 3}
>>> a.discard(1)
>>> a.discard(1)
>>> a
{2, 3}
- set.pop() -> object
  - 功能：删除list中的一个元素（随机一个），并返回它。
  - 如果set为空，则抛出异常。
  - 例：
>>> a = {1, 2, 3}
>>> a.pop()
1
>>> a.pop()
2
>>> a.pop()
3
>>> a.pop()
KeyError: 'pop from an empty set'
##
##
##

dict
## dict：字典类型，存储一些键值对形式的元素。

采用 dic 作为字典的缩写

- key必须是不可变类型、取值唯一。value可以是任何类型、可以重复。
  - dict采用哈希表的存储结构，根据key的哈希值确定value的存储地址，因此查询、插入的效率高。
- 可以用 {key:value...} 的格式创建dict。
>>> {"name": "Leo","age": 10}
{'name': 'Leo', 'age': 10}
- dict(iterable=..., **kwargs) -> dict
  - 功能：创建一个dict。
  - 例：
>>> dict()                                # 不输入参数时，是创建一个空dict
{}
>>> dict([("name", "Leo"), ("age", 10)])    # iterable要求是一个能产生二元组 (k, v) 的可迭代对象
{'name': 'Leo', 'age': 10}
>>> dict(name="Leo", age=10)                # 也可以输入关键字参数来创建字典
{'name': 'Leo', 'age': 10}
- 可以用 [key] 进行索引，获取字典中某个key对应的value。
>>> d = {"name": "Leo","age": 10}
>>> d["name"]
'Leo'
>>> d["age"] = 0        # 可通过索引修改value
  - 访问一个不存在的key时会抛出异常。
>>> d["time"]
KeyError: 'time'
  - 为了减少出错，应该先判断key是否存在，再进行访问。
>>> if "time" in d:        # 用in关键字判断key是否存在
...     print(d["time"])
...
>>> d.get("time")            # 用get()方法判断key是否存在


如果在字典中添加多个相同的 key ，则取最后一次的 value 。
>>> {1: 'A', 1: 'B', 1: 'C'}
{1: 'C'}


##
##
##

查改删
## 查。
- dict.keys()
  - 功能：返回dict的所有key。
  - 例：
>>> d = {"name": "Leo","age": 10}
>>> d.keys()
dict_keys(['name', 'age'])            # 返回的是一个可迭代对象
>>> [k for k in d.keys()]
['name', 'age']
- dict.values()
  - 功能：返回dict的所有value。
  - 例：
>>> d.values()
dict_values(['Leo', 10])
- dict.items()
  - 功能：返回dict的所有键值对。
  - 例：
>>> d.items()
dict_items([('name', 'Leo'), ('age', 10)])
>>> for k,v in d.items():
...     print(k, v)
...
name Leo
age 10
- dict.get(key, default=None) -> object
  - 功能：返回dict中某个key对应的value。如果不存在该key，则返回default参数。
  - 例：
>>> d = {"name": "Leo","age": 10}
>>> d.get("name")
'Leo'
>>> print(d.get("time"))
None
>>> d.get("time", "")
''
- dict.copy() -> dict
  - 功能：返回dict的一个浅拷贝。
## 改。
- dict.update(iterable=..., **kwargs) -> None
  - 功能：更新一些键值对到dict中。
  - 如果输入的键值对在原dict中存在，则覆盖其value；如果输入的键值对在原dict中不存在，则加入它们。
  - 例：
>>> d = {"name": "Leo","age": 10}
>>> d.update({"name": "Leo","age": 10})    # 可以输入一个能产生二元组的可迭代对象进行update
>>> d
{'name': 'Leo', 'age': 10}
>>> d.update(age=0)                        # 也可以输入关键字参数进行update
>>> d
{'name': 'Leo', 'age': 0}
## 删。
- dict.clear() -> None
  - 功能：清空dict，删除所有元素。
- dict.pop(key, default) -> object
  - 功能：删除dict中某个key对应的键值对，返回其value。
  - 如果不存在该key，且没有输入default参数，则抛出异常。
  - 如果不存在该key，但输入了default参数，则返回default作为value。
  - 例：
>>> d = {"name": "Leo","age": 10}
>>> d.pop("name")
'Leo'
>>> d
{'age': 10}
>>> d.pop("name")
KeyError: 'name'
>>> print(d.pop("name", None))
None
- dict.popitem() -> tuple(k, v)
  - 功能：删除dict中的一个键值对（排在最后的那个），并作为二元元组返回。
  - 如果dict为空，则抛出异常。
  - 例：
>>> d = {"name": "Leo","age": 10}
>>> d.popitem()
('age', 10)
>>> d.popitem()
('name', 'Leo')
>>> d.popitem()
KeyError: 'popitem(): dictionary is empty'


在迭代字典的过程中，如果增减字典的 key ，会引发异常：
```py
>>> d = {'name': 'Leo', 'age': 10}
>>> for k in d.keys():
...   d.pop(k)
...
'Leo'
RuntimeError: dictionary changed size during iteration
>>> d
{'age': 10}
```
因此应该先迭代完毕，再增减字典的 key ：
```py
>>> d = {'name': 'Leo', 'age': 10}
>>> for k in list(d.keys()):
...   d.pop(k)
...
'Leo'
10
```


##
##
##

函数
## 函数。
- Python中定义函数的一般格式为：
def function_name([arg1, arg2, ...]):
statement_block
return
- Python的return语句可以返回多个值，它们以元组的形式返回。
>>> def fun1(a, b):
...     return a, b
...
>>> fun1(1, 2)
(1, 2)

- 如果函数中不包含return语句，则会在函数执行完毕之后返回None。
## Python是动态语言，大部分语句要等到被Python解释器执行时，才能发现是否有错误。除非是明显的语法错误。
- 有些语句即使被成功执行了，也可能仍然有错误。
- 比如如果函数内使用了一些标识符，当Python解释器执行到该函数时，才能发现这些标识符是否有效。
>>> def fun1():
...     print(os.name)
...
>>> fun1()
NameError: name 'os' is not defined
- 比如如果函数内使用了一个外部变量，当Python解释器执行到该函数时，才会尝试读取该变量的值。如下：
>>> funs = [lambda x: x + i for i in range(5)]
>>> funs[0](0)
4
  - 将外部变量作为形参的默认值传入函数，就会在定义函数时就将它的值保存到函数的内置属性__defaults__中。
>>> funs = [lambda x=i: x for i in range(5)]
>>> funs[0]()
0
>>> funs[1]()
1
>>> funs[1](0)
0

## 高阶函数：可以接受函数作为输入参数，或者以函数作为返回值。
## 嵌套函数：在一个函数中定义另一个函数。
## 匿名函数：用关键字lambda定义，只有一个形参列表和一行表达式（相当于return语句），没有函数名。
- 一般格式为：
lambda [arg1,arg2,...]:expression
  - lambda函数也属于函数，有独立的作用域、命名空间。
  - lambda函数应该用于只用一次、不需要记录函数名的紧凑情况。
- 例：
>>> fun1 = lambda x,y : x+y
>>> fun1(1, 2)
3
>>> fun1 = lambda x,y : x=y            # 匿名函数的表达式中不可以进行赋值
SyntaxError: can't assign to lambda
>>> fun1 = lambda x,y=0 : x+y            # 匿名函数也可以使用关键字参数、设置默认值
>>> fun1(x=1,y=2)
3
- Python的lambda函数类似于C语言的宏定义、C++的内联函数。
  - C语言中可以通过宏定义实现一些简单的函数功能，C++中把宏定义升级成了内联函数（用关键字inline声明）。
  - 使用内联函数会建议编译器把调用该函数的语句换成实际的函数体（如果函数体并不小，编译器可能并不会这么做）。这样做可以减少程序调用函数的开销（要保存现场、把变量入栈、跳转执行、跳转回来、恢复现场）。不过会导致编译出来的可执行文件体积变大。
## 闭包函数（closure）：一种特殊的嵌套函数。
- 如下，在一个函数内嵌套定义另一个函数，调用外部函数时会返回内部函数。如果内部函数能读取外部函数定义的局部变量，则称为闭包函数。
def fun1():
    x = 1
    def fun2():
        print(x)
return fun2
  - 该变量称为自由变量：可以在作用域之外的位置被访问。
- Python 使用装饰器时，就会把被装饰的函数变成闭包函数。

闭包就是可以使用参数的代码片段，在闭包内创建的变量在闭包被调用的范围内同样可以被引用。
##
##
##

函数参数
## 在C语言中，调用函数时如果实参列表与形参列表不一致就会报错。但是在Python中，函数的参数比较灵活。
## 实参的类型：
- positional argument    ：key型，必须与形参的顺序一致。
- keyword argument        ：key=value型，不必与形参的顺序一致，解释器会根据参数名来赋值。
>>> def fun1(x, y):
...     print(x, y)
...
>>> fun1(y=2, x=1)
1 2
>>> fun1(x=1, 2)            # 在实参列表中，key=value型参数必须放在key型参数之后
SyntaxError: positional argument follows keyword argument
## 形参的类型。
- 位置参数：key型，没有默认值，调用函数时必须传入相应的实参。
- 关键字参数：key=value型，有默认值，如果调用函数时没有传入相应的实参，则使用该形参的默认值。
>>> def fun2(x, y=2):
...     print(x, y)
...
>>> fun2(1)
1 2
>>> def fun2(x=1, y):
...     print(x,y)
...
SyntaxError: non-default argument follows default argument
- 元组参数：用一个星号 * 声明，只能声明一个。调用函数时会将额外传入的key型实参打包成一个字典。
>>> def fun3(x, y, *args):
...     print(x, y, args)
...
>>> fun3(1, 2, 3, 4)
1 2 (3, 4)
>>> fun3(1,2)            # 如果没有传入额外的实参，元组参数就为空元组
1 2 ()
- 字典参数：用两个星号 ** 声明，只能声明一个。调用函数时会将额外传入的key=value型实参打包成一个元组。
>>> def fun4(x, y, **kwargs):
...     print(x, y, kwargs)
...     if "name" in kwargs:
...         print(kwargs["name"])
...
>>> fun4(1, 2, 3, 4)
TypeError: fun4() takes 2 positional arguments but 4 were given
>>> fun4(1, 2, a=3, b=4)
1 2 {'a': 3, 'b': 4}
- 四种参数的排列顺序应该是：Key型、key=value型、元组参数、字典参数。
## 使用元组参数和字典参数的技巧。
- 万能参数：把函数的形参定义成一个元组参数加一个字典参数，就可以给函数传入任何实参而不会报错。
>>> def fun5(*args, **kwargs):
...     print(args, kwargs)
...
>>> fun5(1, 2, a=3, b=4)
(1, 2) {'a': 3, 'b': 4}
- 在实参列表中，可以用 * 把一个序列拆散成多个key型参数，可以用  ** 把一个字典拆散成多个key=value型参数。
>>> fun5(*(1, 2), **{'a':3, 'b':4})
(1, 2) {'a': 3, 'b': 4}
>>> print(*"Hello")
H e l l o
  - 如果序列或字典为空，拆散之后就没有得到参数。
>>> print(())
()
>>> print(*())


迭代拆包运算符 * 、字典拆包运算符 **

## 给函数传参时，要小心实参被函数改变。
- 如果实参是不可变的数据类型，无论如何也不会被改变。
- 如果实参是可变的数据类型，传入函数就可能会被改变（像C语言的指针函数），安全的做法是将实参所指的对象做一个副本，再传入函数。如下：
>>> def fun1(x, y):        # 调用函数时，解释器会创建形参变量，用实参赋值，使它们指向相同的对象
...     x[:] = y            # 修改形参时，也就是修改实参所指的对象
...     x = [0, 0]        # 对形参赋值时，是改变它所指的对象，不再影响实参所指的对象
...
>>> x = [1, 2]
>>> y = [3, 4]
>>> fun1(x, y)
>>> print(x, y)
[3, 4] [3, 4]
##
##
##

装饰器
## 装饰函数：体现装饰模式的函数，用于向某个函数附加功能而不改变其原本内容。
- 例如，已存在函数fun1()，如下：
>>> def fun1(x, y):
...     print(x, y)
...
>>> fun1(1, 2)
1 2
- 通过另一个函数来间接地调用fun1()，就可以附加一些功能。如下：
>>> def wrapper(func, *args, **kwargs):
...     print("[DEBUG]: enter {}()".format(func.__name__))
...     return func(*args, **kwargs)
...
>>> wrapper(fun1, 1, 2)        # 调用wrapper()，输入函数名和参数，间接地执行fun1(1, 2)
[DEBUG]: enter fun1()
1 2
- 也可写作以下格式：
>>> def debug(func):
...     def wrapper(*args, **kwargs):
...         print("[DEBUG]: enter {}()".format(func.__name__))
...         return func(*args, **kwargs)
...     return wrapper
...
>>> debug(fun1)(1,2)            # debug(fun1)会返回装饰函数的函数名wrapper
[DEBUG]: enter fun1()
1 2

```py
def decorator(func):
    def wrapper(*args, **kwargs):
        print('enter', func.__name__)
        return func(*args, **kwargs)
    return wrapper

@decorator
def fun1():
    return 1

```



## Python提供了装饰器（Decorator）语法：可以在定义函数时用 "@装饰函数名" 的格式方便地添加装饰函数。
- 例：
>>> @debug                    # 指定装饰器为debug()，函数fun1()被调用时会自动被debug()装饰
... def fun1(x, y):
...     print(x, y)
...
>>> fun1(1,2)                # 相当于debug(fun1)(1,2)
[DEBUG]: enter fun1()
1 2
- 加上装饰器之后，原函数的函数名会指向装饰函数的函数名。如下：
>>> fun1
<function debug.<locals>.wrapper at 0x000001A0BF1B8B70>
>>> fun1.__name__
'wrapper'
  - 可以用@wraps(func)装饰wrapper()函数，从而拷贝func的__name__、__doc__等元属性。
- 如果想给装饰器本身传入参数，还要在定义装饰器时外加一层函数，组成双层装饰器。如下：
>>> from functools import wraps
>>> def debug(level=None):
...     print("Decorator was set.")    # 装饰器的外层函数中的语句会在用 @ 指定装饰器时执行
...     def decorator(func):
...         @wraps(func)
...         def wrapper(*args, **kwargs):
...             print("[DEBUG]: enter {}()".format(func.__name__))
...             return func(*args, **kwargs)
...         return wrapper    # 第一层装饰器
...     return decorator      # 第二层装饰器
...
>>> @debug(level=3)    # 该句会先执行函数debug(level=3)，然后用它的返回值作为装饰器，即@__decorator
... def fun1(x, y):
...     print(x, y)
...
Decorator was set.
>>> fun1
<function fun1 at 0x000001A0BF1E3950>
>>> fun1.__name__
'fun1'
>>> fun1(1, 2)
[DEBUG]: enter fun1()
1 2
## 修改对象的装饰器：需要输入一个obj参数，返回obj参数。
- 这种装饰器用于修改对象的成员，可以作用于函数、类。
- 例：
def wrapper(obj):
    obj.name = "test"
    return obj

@wrapper                # 相当于fun1 = wrapper(fun1)
def fun1():
    pass

@wrapper                # 相当于Test = warp(Test)
class Test():
    pass

## 作用于类方法的装饰器：需要在内层多输入一个self参数。
- 例：
def catch_exception(method):
    def wrapper(self, *args, **kwargs):
        try:
            return method(self, *args, **kwargs)
        except Exception as e:
            print(str(e))
    return wrapper

class Test:
    @catch_exception
    def fun1(self, x):
        return 1 + x

>>> Test().fun1(1)
2
>>> Test().fun1('a')
unsupported operand type(s) for +: 'int' and 'str'

## 用类实现的装饰器：需要定义类的__call__()方法。
##
##
##

类
## 使用class关键字可以定义类。
- 例如：
>>> class Test:                        # 如果没有继承就不需要在类名后加括号
...     def __init__(self, x, y):
...         self.a = x
...         self.b = y
...         print(self)
...         print("init...")
...     def fun1(self):
...         print(self.a, self.b)        # 通过指针self调用类实例的成员
...
>>> t1 = Test(1, 2)        # 创建Test类的实例，并将实例对象的引用赋值给变量t1
<__main__.Test object at 0x00AC5970>
init...
>>> t1                    # 变量t1和self都指向实例对象
<__main__.Test object at 0x00AC5970>
>>> t1.a                    # 访问对象的实例变量
1
>>> t1.fun1()            # 调用对象的方法
1 2
  - __init__()是类的构造方法，如果不写解释器也会提供一个默认的。
- 可以用类名给变量赋值，让这个变量可以当做类名使用。
>>> Test
<class '__main__.Test'>
>>> a = Test
>>> a
<class '__main__.Test'>
>>> b = a()
>>> b
<__main__.Test object at 0x010C0DF0>
##
##
##

类的成员
## 类中定义的变量称为类的“属性”，类中定义的函数称为类的“方法”，它们都属于类的“成员”。
- 属性的分类：
  - 实例变量
  - 类变量
- 方法的分类：
  - 实例方法
  - 类方法
  - 静态方法
## 类成员的访问控制。

- public    ：公有成员，定义时不以下划线 _ 开头，可以被任何对象访问，可以通过import语句导入。
- protected ：受保护成员，定义时以一个下划线 _ 开头，只能在当前类或子类中，或通过对象访问。
- private   ：私有成员，定义时以两个下划线 __ 开头，只能在当前类中访问。


- 例：
>>> class Test:
...     a = 0
...     _b = 0
...     __c = 0
...
>>> Test.a
0
>>> Test._b
0
>>> Test.__c
AttributeError: 'Test' object has no attribute '__c'
>>> Test().__c
AttributeError: 'Test' object has no attribute '__c'
##
##
##

类的属性
## 类的属性。
- 实例变量：每个实例对象各有一份，互不影响。
  - 定义类时，只能在方法内访问（此时要通过self指针访问）。
  - 定义类之后，只能作为实例对象的成员引用。
>>> class Test:
...     def __init__(self, n):
...         self.num = n
...     def getNum(self):
...         return self.num
...
>>> Test.num
AttributeError: type object 'Test' has no attribute 'num'
>>> Test(1).num
1
>>> Test(1).getNum()
1
- 类变量：所有实例对象共用一份。
  - 定义类时，既可以在方法内访问（此时可以通过指针 cls 或 self 访问），也可以在方法外访问。
  - 定义类之后，既可以通过 "对象名.成员名" 的方式访问，也可以通过 "类名.成员名" 的方式访问。
>>> class Test:
...     num = 0                # 在方法外访问类变量
...     def __new__(cls):
...         cls.num = 1        # 在方法内通过指针 cls 访问类变量
...         return super().__new__(cls)
...     def getNum(self):
...         return self.num    # 在方法内通过 self 访问类变量
...     def setNum(self, n):
...         self.num = n
...
>>> Test.num
0
>>> Test().num
1
>>> Test.num                    # 类变量被实例改变了
1
>>> Test().getNum()
1
  - 如果类变量与实例变量重名，则通过self指针访问时优先访问实例变量。
>>> t = Test()
>>> t.setNum(2)
>>> t.num            # 此时访问的是实例变量
2
>>> Test.num            # 类变量没有被改变
1
## Python支持给一个已定义的类加上成员。
>>> t.id
AttributeError: 'Test' object has no attribute 'id'
>>> t.id = 1
>>> t.id
1
>>> Test.ID
AttributeError: type object 'Test' has no attribute ID
>>> Test.ID = 1
>>> Test.ID
1
>>> t.ID            # 加上的类变量可以正常被实例对象访问
1
- 因为这个特性，给一个类或对象的成员进行赋值时，即使该成员不存在，也可以赋值成功。如下：
>>> Test.__id
AttributeError: type object 'Test' has no attribute '__id'
>>> Test.__id = 1            # 私有成员显然不能在类外被访问，但这里还是赋值成功了
>>> Test.__id
1
##
##
##

类的方法
## 类的方法。
- 实例方法：第一个参数必须是self。
  - 调用实例对象的普通方法时，会自动传入该对象的引用作为第一个参数。一般把该参数命名为self。
  - 普通方法一般通过 "对象名.方法名" 的方式访问，也可以通过 "类名.方法名" 的方式访问，此时需要传入第一个参数self。如下：
>>> Test.getNum()
TypeError: getNum() missing 1 required positional argument: 'self'
>>> Test.getNum(Test())
1
- 类方法：用装饰器 @classmethod 定义，第一个参数必须是cls。
  - 调用类方法时，会自动传入该类名的引用作为第一个参数。一般把该参数命名为cls。
  - 类方法既可以通过 "对象名.成员名" 的方式访问，也可以通过 "类名.成员名" 的方式访问。如下：
>>> class Test:
...     num = 0
...     @classmethod
...     def class_getNum(cls):        # 定义类方法
...         return cls.num
...     @staticmethod                # 定义静态方法
...     def static_getNum():
...         return Test.class_getNum()
...
>>> Test.class_getNum()
0
>>> Test().class_getNum()
0
- 静态方法：用装饰器 @staticmethod定义，不必传入self或cls参数，相当于一个独立的函数。
  - 静态方法既可以通过 "对象名.成员名" 的方式访问，也可以通过 "类名.成员名" 的方式访问。如下：
    >>> Test().static_getNum()  # 此时传入了参数 self
    0
    >>> Test.static_getNum()    # 此时不传入参数 self 或 cls
    0
  - 通过 "对象名.方法名" 的方式访问时，装饰器会把自动传入的参数self拦截下来，因此没有装饰器就会出错。如下：
>>> class Test:
...     def static_getNum():
...         return 0
...
>>> Test.static_getNum()
0
>>> Test().static_getNum()
TypeError: static_getNum() takes 0 positional arguments but 1 was given
## @property：将一个方法名转换成属性名（这样就能在读取属性值时执行某些动作）。
>>> class Test:
...     @property
...     def sum(self):
...         return 0
...
>>> Test().sum
0
>>> Test().sum()
TypeError: 'int' object is not callable
##
##
##

类的内置方法
## 类的内置方法：以两个下划线 __ 开头、两个下划线 __ 结尾，可以被重载。
- 又称为魔法方法。
- 一些内置方法是每个类都默认自带的，比如__new__()、__init__()、__str__()、__repr__()。
## 关于创建对象的内置方法。
- __new__()    ：实例化类时被自动调用，用于创建对象。
  - 它是一个静态方法，输入的第一个参数是cls，返回新对象的引用即self指针。
  - 让__new__()总是返回同一个对象的引用，就可以实现单例模式。如下：
>>> class Test:
...     def __new__(cls):
...         if not hasattr(cls, 'instance'):
...             cls.instance = super().__new__(cls)
...         return cls.instance
...
>>> Test()
<__main__.Test object at 0x7f96450d45c0>
>>> Test()
<__main__.Test object at 0x7f96450d45c0>
- __init__()    ：构造函数，对象被创建之后被自动调用，用于初始化对象。
  - 如果子类没有重载构造函数，Python解释器会自动调用父类的__init__()方法。如果子类重载了构造函数，就需要主动调用父类的__init__()方法。如下：
class B(A, C):
    def __init__(self):
        super().__init__()
- __del__()    ：析构函数，用于销毁对象。当对象的被引用数减到0时被自动调用（不能用del语句主动调用）。
  - 一般情况下不用重构__del__()方法。
- 例：
>>> class Test:
...     def __new__(cls, x):
...         print("cls: ", cls)
...         print("Object created successfully.")
...         return super().__new__(cls)            # 通常是调用父类的__new__()方法来创建对象
...     def __init__(self, x, y):
...         self.a = x
...         self.__b = y
...         print("self: ", self)
...         print("initialization completed.")
...     def __del__(self):
...         print("Object was deleted.")
...
>>> t1 = Test(1)
cls:  <class '__main__.Test'>
Object created successfully.
TypeError: __init__() missing 1 required positional argument: 'y'
>>> t1=Test(1, 2)
TypeError: __new__() takes 2 positional arguments but 3 were given
  - 执行Test()时会实例化该类，先调用__new__()方法创建对象，再调用__init__()方法初始化对象。
  - __new__() 的形参列表必须与 __init__() 的一致，或者兼容。例如，将上例中的def __new__(cls, x)改为def __new__(cls, *args, **kwargs)之后，便可成功创建一个对象。
## 使对象能够实现一些基本功能的内置方法。
- __str__()    ：当对象被转换成字符串时被自动调用。
- __repr__()    ：当对象在终端上打印时被自动调用。
- __len__()    ：当对象被len()访问时被自动调用。
- __getitem__()        ：可以通过索引获得对象中的某项元素的值。
- __setitem__()        ：可以通过索引对对象中的某项元素赋值。
- __iter__()和__next__()：使对象可以作为迭代器使用。
## 使对象能进行加减乘除运算的内置方法。
- __add__()        ：左加，当对象出现在加号 + 的左边时被自动调用。
- __radd__()        ：右加，当对象出现在加号 + 的右边时被自动调用。
- __sub__()        ：左减。
- __rsub__()        ：右减。
- __mul__()        ：左乘。
- __rmul__()        ：右乘。
- __truediv__()    ：左除。
- __rtruediv__()    ：右除。
- 例如：
>>> class Test:
...     def __str__(self):
...         return "__str__"
...     def __repr__(self):
...         return "__repr__"
...     def __sub__(self, other):
...         return 0 - other
...     def __rsub__(self, other):
...         return other - 0
...
>>> t1 = Test()
>>> t1
__repr__
>>> str(t1)
'__str__'
>>> print(t1)        # print()在显示对象时会先将对象转换成字符串
__str__
>>> t1 - 1
-1
>>> Test() - Test()
0
## 实现了__enter__() 和 __exit__()方法的对象支持用关键字 with 进行上下文管理。
- 例：
class Test:
    def __init__(self, filename, mode='r'):
        self.filename = filename
        self.mode = mode
    def __enter__(self):
        self.f = open(self.filename, self.mode)
        return self.f
    def __exit__(self, *args):   # 抛出异常时会传入异常名、异常内容、traceback对象
        self.f.close()

with Test("1.txt") as t:
    t.read()
  - 执行with Test("1.txt")时，Python解释器会先创建对象f=Test("1.txt")，然后调用f.__enter__()。当执行完with语句块或者抛出异常时，就调用f.__exit__()。
## 其它内置方法。
- __getattr__()    ：当用户访问对象中没有定义的属性时，就会到__getattr__()中寻找，仍然找不到就会报错。
  - 例：
def __getattr__(self, attr):
    if attr == "age":
        return 18
else
    return None
- __call__()        ：使对象的标识符可以像函数名一样被调用。
  - 例：
>>> t1 = Test()
>>> t1()
TypeError: 'Test' object is not callable    # 如果重载了__call__()，此时就会调用__call__()
- __sizeof__()        ：返回对象占用的内存（单位为bytes）。
  - 例：
>>> "".__sizeof__()
51


__slots__ 用于限制动态添加到实例中的成员。
参考：https://www.liaoxuefeng.com/wiki/1016959663602400/1017501655757856


对象的内置属性
## 函数的内置属性。
- __name__：一个str，存储函数名。
  - 例：
>>> f = print
>>> f.__name__
'print'
- __doc__：一个str，存储函数的说明文档。
  - 例：
>>> print.__doc__
"print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\n
- __closure__：对于非闭包函数，它是None。对于闭包函数，它是一个tuple，记录函数引用的所有自由变量。
  - 例：
>>> def fun1():
...     x = 1
...     def fun2():
...         print(x)
...     return fun2
...
>>> f = fun1()
>>> f.__closure__
(<cell at 0x0000020398E80828: int object at 0x00007FF8C8196290>,)
>>> f.__closure__[0].cell_contents
1
- __defaults__：一个tuple，存储函数的默认值形参。
  - 如果函数形参的默认值为可变类型，就可能被修改。因此，应该尽量使用不可变类型，或者检查函数中所有用到它的语句是否修改了它。
  - 例：
>>> def fun2(x=[], y=[]):
...     print(x, y)        # 没有传入实参时，解释器会用__defaults__[0]、__ddefaults__[1]给形参赋值
...     y.append(0)
...     print(fun2.__defaults__)
...
>>> fun2()
[] []
([], [0])            # 对__defaults__的修改会一直保留，直到解释器关闭
>>> fun2()
[] [0]
([], [0, 0])
- __annotations__：一个dict，存储有注释的形参。
  - 例：
>>> def fun1(a, b: "字符串或None", c: int = 0)-> int:    # 定义函数时，可以用冒号 : 给形参加上注释
...     pass
...
>>> fun1.__annotations__
{'b': '字符串或None', 'c': <class 'int'>, 'return': <class 'int'>}

__class__：指向对象所属的类，返回值与type()一样。
self.__class__相当于cls

>>> a = 1
>>> a.__class__
<class 'int'>
>>> int.__class__
<class 'type'>


## 实例方法的私有属性。
>>> class Test(int):
...     def fun1(self):
...         pass
...
- __self__：指向类的实例。实例的普通方法、类方法具有该属性。
  - 例：
>>> Test().fun1.__self__
0
>>> Test(1).fun2.__self__            # 类方法的__self__属性指向类名
<class '__main__.Test'>
>>> Test(1).fun3.__self__            # 静态方法实际上是个函数，没有__self__属性
AttributeError: 'function' object has no attribute '__self__'
- __func__：指向该方法绑定的函数名。非built-in类的实例的普通方法、类方法具有该属性。
  - 普通方法、类方法本身会绑定到一个静态函数，各个实例对象都是调用该静态函数。
  - 例：
>>> Test(1).fun1
<bound method Test.fun1 of 1>            # 该方法绑定到Test.fun1函数
>>> Test(1).fun1.__func__
<function Test.fun1 at 0x000001AD6E0CA048>
>>> Test(1).fun1.__func__ is Test(2).fun1.__func__
True
>>> Test(1).fun2
<bound method Test.fun2 of <class '__main__.Test'>>
>>> Test(1).fun3                        # 静态方法本身不会绑定
<function Test.fun3 at 0x000001AD6E0CA2F0>
##
##
##

类的继承
## 在定义类名时，在类名后加上括号并填入某个类名，就可以让当前类继承某个类的成员。
- Python3中，所有类都隐式地继承object类。
- 例：
>>> class Person:
...     num = 0
...
>>> class Man(Person):        # 创建一个继承类Person的类Man
...     pass
...

- 子类继承父类的类变量之后，会保留相同的引用。

>>> Person.num, Man.num
(0, 0)
>>> Person.num is Man.num   # 此时子类的类变量，与父类的类变量，实际上是引用同一个对象
True

>>> Person.num = []         # 改变父类的类变量的引用，会导致子类的类变量也变化，因为子类与父类的类变量依然引用同一个对象
>>> Person.num, Man.num
([], [])
>>> Person.num is Man.num
True

>>> Person.num.append(0)    # 修改父类的类变量的值，子类与父类的类变量依然引用同一个对象
>>> Person.num, Man.num
([0], [0])
>>> Person.num is Man.num
True

>>> Man.num.append(1)       # 修改子类的类变量的值，子类与父类的类变量依然引用同一个对象
>>> Person.num, Man.num
([0, 1], [0, 1])
>>> Person.num is Man.num
True

>>> Man.num = [2]           # 但是，改变子类的类变量的引用，会与父类的该类变量从此取消关联
>>> Person.num, Man.num
([0, 1], [2])
>>> Person.num is Man.num
False




- 类的定义语句执行完之后，该类的定义就确定了。即使重新定义父类，它依然继承的是之前的父类。
>>> class Person:
...     num = 0
...     name = ""
...
>>> Man.name                        # 子类不会继承父类的新成员
AttributeError: type object 'Man' has no attribute 'name'



C++等语言中支持定义多个名称相同、形参列表不同的方法，实现更丰富的多态性。如下，当调用 Test.get(x=1) 时，根据输入的实参与哪个形参列表匹配，从而判断调用哪个方法。
但Python不支持这样的多态性，同名的多个方法中，只有最后一个定义的方法会生效。

class Test:

    def get(self):
        pass

    def get(self, x):
        pass

    def get(self, x, y):
        pass

##

多继承
## Python的类支持多继承。如下：
>>> class A:
...     def __init__(self, *args):
...         print("A start")
...         print("A end")
...
>>> class B(A):
...     def __init__(self, *args):
...         print("  B start")
...         super().__init__(*args)    # 调用父类的构造方法
...         print("  B end")
...
>>> b = B()
  B start
A start
A end
  B end
- 使用A.__init__()的格式也可调用父类的方法，但是在多继承的情况下可能会重复继承，应该使用super()获取父类，避免重复继承。
- 使用多继承时，几个父类之间不能有继承关系，否则会重复继承某个类。
>>> class C(A, B):
...     def __init__(self, *args):
...         super().__init__(*args)
...
TypeError: Cannot create a consistent method resolution
order (MRO) for bases A, B
- 使用多继承时，几个父类可以继承自相同的超父类。这样并不会重复继承。
>>> class C(A):
...     def __init__(self, *args):
...         print("    C start")
...         super().__init__(*args)
...         print("    C end")
...
>>> class D(B, C):
...     def __init__(self, *args):
...         print("      D start")
...         super().__init__(*args)
...         print("      D end")
...
>>> d = D()
      D start
  B start
    C start
A start
A end
    C end
  B end
      D end
- 定义一个类时，Python会自动决定其方法继承顺序（Method Resolution Order, MRO）。
>>> D.mro()            # 获取该类的MRO列表（子类在前，父类在后）
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
  - 如果子类调用父类的成员时没有指定路径，解释器会在各个父类中查找该成员。查找顺序按照C3算法，有些类似于广度优先：先从左往右在各个父类中查找，没有找到再进入父类的父类中查找。

##
##
##

元类
## 一般的类实际上是type类的实例。当Python解释器执行到class定义语句时，实际上是调用type()创建该类。
- 在代码中可用type()动态创建类，使程序更加灵活。
## class type(name: str, bases: Tuple[type, ...], dict: Dict[str, Any]) -> a new type
- 功能：创建一个类。（实际上是type类的实例）
- name参数是类名，bases参数是一个包含所有父类的元组，dict参数是一个包含所有方法名及其绑定的函数的字典。
- 例：
>>> Test = type("Test", (int,), {"fun1": fun1})
>>> Test
<class '__main__.Test'>
>>> Test().fun1()
hello
  - 相当于以下定义：
class Test(int):
    def fun1(self):
        print("hello")
## 元类：继承自type类，可用于创建其它类。
- 使用元类可以方便地初始化其它类，设置成员，比setattr()更方便。
  - 创建一个类时，Python解释器会优先用它或它父类的元类来创建它，如果没有元类则用type()来创建它。
- 例：
>>> class Mymeta(type):
...     def  __new__(cls, name, bases, attrs):
...         attrs["fun1"] = lambda self: print("hello")
...         return super().__new__(cls, name, bases, attrs)
...
>>> class Test(metaclass=Mymeta):
...     pass
...
>>> Test().fun1()
hello
##
##
##

迭代器
## 迭代：遍历某个对象中的所有元素。
- 不同的容器实现了迭代器接口之后，就可以使用相同的API进行遍历。
## 可迭代对象（iterable）：具有__iter__()方法。可以被for语句遍历，不能被next()遍历。
- __iter__()：返回一个迭代器。
  - for语句在遍历可迭代对象时，就是先调用对象的__iter__()方法，获得迭代器。
  - 例：
>>> list1 = [1, 2, 3]
>>> list1.__iter__()
<list_iterator object at 0x7fa01109d048>
>>> next(list1.__iter__())
1
## 迭代器（iterator）：具有__iter__()、__next__()方法。可以被for语句、next()遍历。
- Python中的迭代器属于单向只读迭代器：只能向前遍历，不能后退。
  - 大部分迭代器遍历完所有元素之后就停止迭代，也可以创建无限循环的迭代器。
  - 迭代器只能通过迭代获取其中的元素，不能进行索引。
- __next__()：返回迭代器中的下一个元素，如果没有下一个元素则抛出异常StopIteration。
  - 例：
>> class Number:
...     def __init__(self):
...         self.a = 0
...     def __iter__(self):
...         return self
...     def __next__(self):
...         if self.a < 10:             # 最多迭代10次
...             self.a += 1
...             return self.a
...         else:
...             raise StopIteration
...
>>> n = Number()
>>> next(n)
1
>>> next(n)
2
## 相关函数。
- def iter(iterable) -> iterator
  - 功能：将一个可迭代对象转换成迭代器。实际上是调用对象的__iter__()方法。
  - 例：
>>> iter("Hello")
<iterator object at 0x7f19cd6e6810>
>>> list(iter("Hello"))
['H', 'e', 'l', 'l', 'o']
- def next(iterator, default=...) -> object
  - 功能：获取迭代器中的下一个元素。如果不存在则报错，或者返回default参数。
  - 实际上是调用对象的__next__()方法。
  - 例：
>>> i = iter("Hello")
>>> next(i)
'H'
>>> next(i)
'e'
##
##
##

生成器
## 生成器（generator）：Python特有的一种迭代器。
- 使用yield关键字给出函数的返回值时，函数会返回一个生成器。
  - yield的用法与return类似。函数执行到yield语句时会中断函数并返回一个生成器，当迭代生成器的下一个元素时，会让函数从中断处继续执行。
  - 优点：可以中断函数，让函数在需要时才继续执行，有利于节省CPU和内存、控制函数运行。
  - 例：
>>> def fun1():
...     print("step 1")
...     yield 1
...     print("step 2")
...     yield 1, 2
...     print("step 3")
...
>>> g = fun1()
>>> g
<generator object fun1 at 0x7fa011114678>
>>> next(g)
step 1
1
>>> next(g)
step 2
(1, 2)
>>> next(g)
step 3
StopIteration
- 使用生成式的语法也可以创建生成器。
>>> g = (i for i in range(100000))        # 不会一次创建所有元素，而是每次迭代后才创建下一个元素
>>> g
<generator object <genexpr> at 0x7fa011114678>
>>> next(g)
0
>>> next(g)
1
##
##
##

异常处理
## Python程序的错误分为两种。
- SyntaxError：语法错误，在编译时报出错误。
- exception：异常，在运行时被抛出。
  - 除了语法错误，其它的都算异常。
  - 变量未定义、数据类型不符合要求等问题在运行时才能发现，不属于语法错误。
## 使用try-except语句可以捕捉异常。
- 其语法为：首先执行try语句块，如果有异常抛出，则立即执行异常名与其匹配的except语句块。如果没有与其匹配的except，该异常就会被抛出。
- 例：
try:
x = int(input("Please enter a number: "))
except Exception as e:                # 捕捉一个Exception类的异常并实例化成对象e
print(str(e))                    # 显示用str()提取的简要异常信息
except (RuntimeError, TypeError):        # 一个except可以捕捉多种异常
print("RuntimeError / TypeError")
except :                                # 最后一个except可以不设异常名，从而匹配所有类型的异常
print("Unexpected error:", sys.exc_info()[0])
raise        # 将异常抛出
else:            # 可以在try-except语句后加上一个else语句，没有发生异常时就执行该语句块
pass
finally:            # 可以在try-except语句后加上一个finally语句，不管是否发生异常都会执行该语句块
pass            # 即使有return语句，也会在return之前先执行finally语句块
## 用关键字with可以实现try-finally的作用，保证在执行语句块时一定会执行某种操作。
- 如下，定义一个支持with操作的类，使用with时会调用类的__enter__()方法，当语句块执行结束或出现异常时会调用类的__exit__()方法。
- 例：
>>> class Test():
...     def __enter__(self):
...         return self
...     def __exit__(self, type, value, trace):
...         print("exit")
...
>>> with Test() as t:
...     print("inside")
...
inside
exit
## 抛出异常。
- 使用“raise X”的格式可以主动抛出一个异常。X可以是一个异常类或者异常的实例。
- 在 except 语句块中，单独使用关键字raise ，会抛出已捕捉的异常。
>>> raise NameError
NameError
>>> raise NameError('test...')
NameError: test...
- 使用关键字assert可以写一个断言，当表达式结果为假时则抛出AssertionError异常。
>>> assert 1 == 0
AssertionError
>>> assert 1 == 0, "not equal"        # 可以给该异常加上描述信息
AssertionError: not equal
## BaseException：所有异常类的基类。
- SystemExit
- KeyboardInterrupt
- GeneratorExit
- Exception：Common base class for all non-exit exceptions.
  - EOFError        ：Read beyond end of file
  - ImportError    ：Import can't find module, or can't find name in module.
  - NameError    ：Name not found globally.
  - OSError        ：Base class for I/O related errors.
  - KeyError        ：字典中没有该key。
  - AttributeError：对象没有该属性。
  - RuntimeError    ：Unspecified run-time error.
  - SystemError    ：Python解释器的内部错误。
  - TypeError    ：参数的数据类型错误。
  - ValueError    ：参数的值错误（数据类型正确）。
  - Warning        ：Base class for warning categories.
## 下例是自定义一个异常类：

class MyException(Exception):
    def __init__(self, msg=''):
        self.msg = msg

    def __repr__(self):
        return 'MyException({})'.format(repr(self.msg))

    def __str__(self):
        return self.__repr__()

>>> raise MyExcept
__main__.MyExcept
>>> raise MyExcept('test...')
__main__.MyExcept: test...
##
##
##

其它知识
pass 和 ...
## pass在Python中是一个关键字，可用于填补语句块的空缺。
- 例：
>>> def fun1():
...     pass
...
## 省略号...在Python中是一个属于ellipsis类的单例对象Ellipsis，其布尔值为True。
>>> ...
Ellipsis
>>> type(...)
<class 'ellipsis'>
>>> bool(...)
True
- ...可以替代pass填补语句块的空缺。
>>> def fun1():
...     ...
...
- ...可以用于赋值。
>>> x = ...
>>> x
Ellipsis
  - 而pass是一个关键字，不能用于赋值。
>>> x = pass
SyntaxError: invalid syntax
- 当对象中的某个元素是对自身的循环引用时，会被解释器替代为...。
>>> list1 = [1, 2, 3]
>>> list1.append(list1)
>>> list1
[1, 2, 3, [...]]
>>> list1[3]
[1, 2, 3, [...]]
>>> list1[3][3]
[1, 2, 3, [...]]
  - 但直接用list1赋值时，不会造成循环引用。
>>> list1 = [1, 2, 3]
>>> list1 = [1, 2, 3, list1]
>>> list1
[1, 2, 3, [1, 2, 3]]
##
##
##

内置函数
## Python解释器启动时会自动导入builtins模块，它提供了一些内置函数。
##
##
##

关于底层
## def id(object) -> int
- 功能：返回对象的唯一ID。
  - 在CPython中是把对象的内存地址转换成十进制，作为ID。
- 例：
>>> id(1)
140706485723792
>>> x = 1; id(x)
140706485723792
## def help(object)
- 功能：返回对象的帮助文档（包括Python的帮助文档、源代码的说明文档）
- 例：
>>> help(id)
Help on built-in function id in module builtins:...
>>> x=1; help(x)
Help on int object:...
## def callable(object) -> bool
- 功能：判断一个对象是否可以调用（是否为函数名或类名）。
- 例：
>>> callable(10)
False
>>> callable(int)
True
## def globals() -> dict
- 功能：返回一个字典，包含所有全局变量。
- 例：
>>> globals()
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>}
## def locals() -> dict
- 功能：返回一个字典，包含当前作用域的所有局部变量。
- 例：
>>> def fun1():
...     x = 1
...     print(locals())
...
>>> fun1()
{'x': 1}
##
## def repr(obj) -> str
- 功能：返回对象的__repr__()方法的返回值。
- 当对象A在终端被打印时，显示的值就是 print(A.__repr__())
- 例：
>>> repr(3.14)
'3.14'
>>> repr(int)
"<class 'int'>"
>>> repr('Hello')        # 如果对象本来就是字符串类型，则会加上引号
"'Hello'"
>>> repr(b'Hello')
"b'Hello'"
##
##

关于执行代码
## def exec(src, globals=..., locals=...) -> None
- 功能：执行一段代码。
- 例：
>>> exec("1+2")
>>> exec("a=0")
>>> a
0
- 执行时可以访问外部变量：
>>> a = 1
>>> exec("print(a)")                        # 默认使用当前作用域的可用变量
1
>>> exec("print(a)", {"a":2})                # 可以给定变量
2
>>> exec("print(a)", globals(), locals())    # 传入当前的全局变量、局部变量
1
## def eval(src, globals=..., locals=...) -> object
- 功能：执行一段代码，返回其结果。
- 例：
>>> eval("1+2")
3
>>> eval("int")                    # 返回值是某个对象的引用，不是单纯的字符串
<class 'int'>
>>> eval("print('hello')")        # 返回值可以来自stdout
hello
>>> eval("a = 1")                    # 不能执行赋值语句
    a = 1
      ^
SyntaxError: invalid syntax
>>> eval("print(1);print(2)")        # 只能执行一条语句，返回一个结果
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<string>", line 1
    print(1);print(2)
            ^
SyntaxError: invalid syntax
## def compile(src, filename, mode) -> code
- 功能：将字符串编译成code对象，可以被exec()或eval()执行。
- 例：
>>> code = compile("print(1+2)", '<string>', "eval")
>>> eval(code)
3
##
##
##

关于类
## class type(object) -> className
- 功能：返回对象的类型（即类名）。
- 例：
>>> type(1)
<class 'int'>
>>> type(int)        # 一般的类实际上是type类的实例
<class 'type'>
>>> type(object)
<class 'type'>
## def isinstance(object, type) -> bool
- 功能：判断一个对象是否是某个类的实例。
- type参数可以是一个类名，或者一个包含多个类名的元组。
- 例：
>>> isinstance(1.0, int)
False
>>> isinstance(1.0, (int, float))
True
## def issubclass(cls, another_cls) -> bool
- 功能：判断一个类是否是某个类的子类或同一个类。
- another_cls参数可以是一个类名，或者一个包含多个类名的元组。
- 例：
>>> class Test(int):
...     pass
...
>>> issubclass(Test, int)
True
>>> issubclass(Test, Test)
True
>>> issubclass(Test, (float, str))
False
## class super(type, object) -> superclass
- 功能：获取一个对象的父类。
- type是一个类名，object是该类或其子类的一个实例。例如，
- 例：
>>> super(int, 1)            # 获取int类在实例1的MRO列表中的下一个父类
<super: <class 'int'>, <int object>>
- 下例是调用父类的构造方法：
>>> class Test(int):
...     def __init__(self):
...         super(Test, self).__init__()    # 在Python3中可将super(Test, self)简写为super()
...
>>> Test()
0
##
##
##

关于类的成员
## 反射：根据类的成员的名称字符串，获得它的引用。
- 使用反射可以让Python程序在运行时更加动态。
## def dir(object=...) -> list of strings
- 功能：查看对象的所有成员，返回一个字符串列表。
- 不输入object参数时，返回当前作用域的所有可用标识符。
- 例：
>>> dir(1)
['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', ...]
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']
## def getattr(object, name:str, default=...) -> attribute
- 功能：获取对象的某个成员。如果不存在则报错，或者返回default参数。
- 例：
>>> getattr(str(), "encode")
<built-in method encode of str object at 0x000002ACBA2F7CE0>
>>> getattr(str(), "len")
AttributeError: 'str' object has no attribute 'len'
## def hasattr(object, name:str) -> bool
- 功能：判断对象是否拥有某个成员。
- 实际上是调用getattr()并捕捉异常。
- 例：
>>> hasattr(str(), "encode")
True
>>> hasattr(str(), "len")
False
## def setattr(object, name:str, value) -> None
- 功能：设置对象的某个成员，实际上是更改它的引用。
- 例：
>>> class Test:
...     def fun1(self):
...         print("this is fun1")
...
>>> def fun2():
...     print("this is fun2")
...
>>> t = Test()
>>> setattr(t, "fun1", fun2)        # 相当于t.fun1 = fun2
>>> t.fun1()
this is fun2
## def delattr(object, name:str) -> None
- 功能：删除对象的某个成员。
- 例：
>>> delattr(str(), "encode")
AttributeError: 'str' object attribute 'encode' is read-only
##
##
##

关于迭代
## class range(stop: int) -> iterable
class range(start: int, stop: int, step: int=...) -> iterable
- 功能：生成一个等差数列。从start开始、到stop结束（不包含stop所在位），步进值为step。这些参数可以是负数。
- 例：
>>> range(5)                    # range()的返回值不是列表，要像迭代器一样遍历
range(0, 5)
>>> list(range(5))            # 生成一个在 [0, 5) 区间的等差数列
[0, 1, 2, 3, 4]
>>> list(range(1, 5))            # 生成一个在 [1, 5) 区间的等差数列
[1, 2, 3, 4]
>>> list(range(-1, -10, -2))    # 生成一个在 [-1, -10) 区间、步进值为-2的等差数列
[-1, -3, -5, -7, -9]
- 以下情况中，range()生成的等差数列为空。
>>> list(range(0))
[]
>>> list(range(-1))
[]
>>> list(range(5, 1))
[]
>>> list(range(1, 10, -2))
[]
## class enumerate(iterable, start=0) -> iterator
- 功能：枚举一个可迭代对象，返回一个迭代器。每次迭代返回一个元组 (n, iterable[n]) ，包含序号 n 和第 n 个元素。
- 常用于生成带序号的序列。
- 例：
>>> list(enumerate("Hello"))
[(0, 'H'), (1, 'e'), (2, 'l'), (3, 'l'), (4, 'o')]
## def sorted(iterable, key: callable=None, reverse=False) -> list
- 功能：将一个可迭代对象中的所有元素进行排序，放在一个list中返回。
- 默认直接比较各个元素的大小，可以通过key参数生成一个值再比较大小。
- 默认reverse=False，按升序排序，即后一项比前一项大。
- 例：
>>> list1 = [3, 2, 4, 5]
>>> sorted(list1)
[2, 3, 4, 5]
>>> sorted(list1, key=lambda x:-x)
[5, 4, 3, 2]
>>> sorted(list1, reverse=True)
[5, 4, 3, 2]
- 对字典进行排序：
>>> dict1 = {1:'c', 2:'b', 3:'a'}
>>> sorted(dict1)                                        # 对key进行排序
[1, 2, 3]
>>> sorted(dict1.items(), key=lambda x: x[1])            # 按value进行排序
[(3, 'a'), (2, 'b'), (1, 'c')]
>>> dict(sorted(dict1.items(), key=lambda x: x[1]))        # 排序后再转换成dict
{3: 'a', 2: 'b', 1: 'c'}
## def zip(*iterable) -> iterable[tuple]
- 功能：返回一个生成器，每次迭代取出各个iterable的第n项元素，组成一个元组返回。
- 例：
>>> zip(range(5))
<zip object at 0x7fa35d9d7fc8>
>>> list(zip(range(5)))
[(0,), (1,), (2,), (3,), (4,)]            # 每次迭代的返回值是一个元组
>>> list(zip(range(5), "Hellooo"))        # zip()可以迭代n次，n等于最短的那个可迭代对象的可迭代次数
[(0, 'H'), (1, 'e'), (2, 'l'), (3, 'l'), (4, 'o')]
>>> list(zip(*zip(range(5), "Hellooo")))        # zip(* )是zip的逆过程，可实现二维矩阵的转置
[(0, 1, 2, 3, 4), ('H', 'e', 'l', 'l', 'o')]
## def map(func, *iterable) -> iterable
- 功能：返回一个生成器，每次迭代会取出各个iterable的第n个元素，传给func函数执行，然后返回函数的返回值。
- 例：
>>> map(print, range(5))
<map object at 0x7fa35e250dd8>
>>> list(map(print, range(5), 'hello'))
0 h
1 e
2 l
3 l
4 o
[None, None, None, None, None]
- map()比zip()更灵活、功能更强。例如用它们实现二维矩阵的转置：
>>> list(zip([1, 2, 3, 4], [5, 6, 7]))
[(1, 5), (2, 6), (3, 7)]
>>> list(map(lambda x, y: (x, y), [1, 2, 3, 4], [5, 6, 7]))
[(1, 5), (2, 6), (3, 7)]
##
##
##

关于计算

幂运算
def pow(base, exp)    # 近似于 base**exp
>>> pow(2, 3)
8
>>> pow(2, -3)
0.125

## def len(object) -> int
- 功能：返回对象包含的元素个数，由对象的内置方法__len__()决定。
- 例：
>>> len("Hello")
5
>>> len([1, 2, 3])
3
>>> len({1:None, 2:None, 3:None})
3
## def abs(n)
- 功能：返回n的绝对值。
- 例：
>>> abs(-1)
1
>>> abs(-1.0)
1.0
## def round(number, digits=0) -> number
- 功能：将一个数字的小数部分四舍五入，只保留指定位数。
- 例：
>>> round(123.456)
123
>>> round(123.456, 2)
123.46
>>> round(123.456, 5)        # 保留的位数比实际位数多时，不会有影响
123.456
>>> round(123.456, -2)    # 保留-2位小数
100.0

def max(iterable, *_args, key: Callable) -> value
def max(arg1, arg2, *_args, key: Callable) -> value
- 功能：找出多个arg中最大的那个。
- 基于比较运算符 > 比较大小。
例：
>>> max()                                    # 必须传入参数
TypeError: max expected 1 arguments, got 0
>>> max(1)                                    # 只传入一个参数时，它必须是可迭代对象
TypeError: 'int' object is not iterable
>>> max([1, 2, 3])
3
>>> max(1, 2)
2
>>> max('a', 1)
TypeError: '>' not supported between instances of 'int' and 'str'
>>> max('a', 'b')
'b'‘
- 如果传入了key参数，max()不会直接比较arg1>arg2，而是比较key(arg1)>key(arg2)。
例：找出列表中出现频率最高的数字
>>> _list = [1, 2, 3, 2]
>>> max(set(_list), key=_list.count)
2

例：找出字典中value最大的key
>>> d = {'a': 1, 'b': 2, 'c': 3}
>>> max(d, key=d.get)
'c'

- min()函数的原理与max()类似，不过是找出最小值。

## def sum(iterable, start=0) -> value
- 功能：将可迭代对象中的各个元素相加求和。
- 例：
>>> sum(1)
TypeError: 'int' object is not iterable
>>> sum([1, 2, 3])
6
## def all(iterable) -> bool
- 功能：如果iterable中各个元素的bool值都是True，则返回True。
- 例：
>>> all([0])
False
>>> all([1, 2, False])
False
- 例外：如果iterable为空，则也返回True。
>>> all([])
True
## def any(iterable) -> bool
- 功能：如果iterable中有任意一个元素的bool值为True，则返回True。
- 例：
>>> any([])
False
>>> any([0])
False
>>> any([0, 1, 2])
True
##
##
##

常用模块

[Python 的内置模块列表](https://docs.python.org/3.8/py-modindex.html)

关于系统
♢ os
## os：Python的标准库，用于调用系统的API。
>>> import os
>>> os.name                    # 返回当前系统的接口类型，取值为'posix'或'nt'
'nt'
>>> os.abort()                # 终止Python解释器，且没有返回值
## 关于环境变量。
>>> os.environ.get("PATH")    # os.environ返回一个字典，包含当前的环境变量，可直接读写
'C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;...
>>> os.environ["DEBUG"] = "true"
## 关于进程。
>>> os.getpid()            # 获得当前进程的pid
18516
>>> os.getppid()            # 获得当前进程的父进程的pid
6484
>>> os.getlogin()            # 获得当前登录的用户名
'Will'


向进程发送终止信号：
>>> import signal
>>> os.kill(1106, signal.SIGKILL)

在 Windows 系统上不支持 signal.SIGKILL ，要使用 signal.SIGTERM 。





## 关于执行命令。
- os.system(cmd)：创建一个shell（属于当前进程的子进程），执行一条命令，并返回命令的返回码(int类型）。
  - 例如：
>>> os.system("echo hello")
hello            # 命令的stdout会输出到当前进程中
0                # 命令正常结束时的返回码为0
  - 可根据返回值是否为0来判断进程是否正常结束：
if not os.system("..."):
    print("done")
- os.popen(cmd, mode="r", buffering=-1)：在系统shell中执行一条命令，并以文件流的形式返回其stdout。
  - 读取模式可以是'r'或'w'。
  - buffering=-1表示采用系统默认的缓冲方式。
  - os.system()会阻塞当前进程，一直等到命令执行结束。而os.popen()是异步执行命令，如果用p.read()等方法进行交互，也会阻塞当前进程。
  - 例如：
with os.popen("ipconfig") as p:
    result = p.read()




## 关于文件路径。
>>> os.path.split('D:/1/2.py')        # 将一个文件路径分割成目录名和文件名
('D:/1', '2.py')
>>> os.path.split("D:/1/2.py/")        # 最后一个路径分隔符的右侧内容会被视作文件名
('D:/1/2.py', '')
>>> os.path.split("/")                # 处理根目录时，不会分割
('/', '')
>>> os.path.split("")
('', '')

>>> os.path.dirname("D:/1/2.py")        # 返回path的目录名
'D:/1'
>>> os.path.basename("D:/1/2.py")        # 返回path的文件名
'2.py'
>>> os.path.sep                        # 获得当前系统的路径分隔符
'\\'
>>> os.path.join('D:/1', '2.py')        # 用当前系统的路径分隔符，把目录名和文件名合成一个路径
'D:/1\\2.py'
>>> os.path.join('D:/1', 'test', '2.py')    # 可以输入多项参数，一起合并
'D:/1\\test\\2.py'
>>> os.path.abspath(".")                # 返回path的绝对路径
'D:\\1'
>>> os.path.relpath("D:/1", "D:/")        # 返回"D:/1"对于"D:/"的相对路径
'1'
>>> os.path.normpath("D:/1/")            # 将一个path正常化（并不会判断它是否有效），
'D:\\1'                                # 它会自动转换成当前系统的路径分隔符，并去掉path末尾的路径分隔符
>>> os.path.normpath("D://\\1////")    # 即使有多余的路径分隔符，也会自动处理
'D:\\1'
>>> os.path.normpath("")                # 如果输入的path是空字符串，则返回'.'
'.'


例：基于路径分隔符分割path
>>> path = 'D:/1/2.py'
>>> os.path.normpath(path).split(os.path.sep)
['D:', '1', '2.py']

## 获取目录信息。
>>> os.getcwd()                        # 获得当前的工作目录
'D:\\1\\'
>>> os.chdir("D:\\")                    # 切换到指定工作目录
- >>> os.listdir("D:\\")                # 列出指定目录下的所有文件和文件夹
['.vscode', '1.py', '__pycache__']        # 包括隐藏文件，但不包括 . 和 .. 两个特殊文件
  - os.listdir()不能列出子目录下的文件，而且遇到异常时（比如无权限访问某个目录）会立即中断。
- >>> os.walk(".", onerror=print)        # 列出指定目录下，各个目录中的文件和文件夹，返回一个生成器
<generator object walk at 0x000001CC520EBA98>
>>> for i in os.walk(".", onerror=print):
>>>     print(i)
>>>
('.', ['res', 'utils', '__pycache__'], [1.py', '__init__.py'])
('.\\res', ['img'], [])
('.\\res\\img', [], ['9.jpg', 'logo.ico'])
  - 生成器的每行元素为：目录、该目录下的文件夹列表、文件列表。
  - os.walk()默认会忽略遇到的异常，应该传入onerror参数，记录遇到的异常。
## 获取文件信息。
>>> os.path.exists("D:\\1")        # 判断文件是否存在
True
>>> os.path.isfile("D:\\1")        # 判断是否为普通文件
False
>>> os.path.isdir("D:\\1")        # 判断是否为目录
True
>>> os.path.getsize("D:\\1")        # 返回文件的大小（占多少字节）
4096
>>> os.path.getctime("D:\\1")        # 返回文件的创建时间
1546567973.6038435
>>> os.path.getatime("D:\\1")        # 返回文件的最后访问时间
1562806458.460649
>>> os.path.getmtime("D:\\1")        # 返回文件的最后修改时间
1562806458.460649
## 管理文件和目录。
>>> os.link(src, dst)                    # 创建硬链接，如果该文件已存在就会报错
>>> os.symlink(src, dst)                # 创建符号链接（不能在Windows上使用），如果该文件已存在就会报错
>>> os.rename(src, dst)                # rename a file or directory
>>> os.remove("D:\\1\\1.py")            # 删除文件
>>> os.mkdir("D:\\1")                    # 创建目录，若该目录已存在则抛出FileExistsError异常
>>> os.rmdir("D:\\1")                    # 删除目录（当目录不为空时会报错）
>>> os.makedirs("1/2/3")                    # 递归创建多层目录，若该目录已存在则报错
>>> os.makedirs("1/2/3", exist_ok=True)    # 若该目录已存在则不报错
- 给上述函数输入的path既可以是绝对路径，也可以是相对路径。
##
##
##

♢ sys
## sys：Python的标准库，提供了一些与Python解释器进行交互的方法。
- 例：
>>> import sys
>>> sys.path                # 查看搜索模块时采用的所有路径，第一个''的作用是指向当前目录
['','C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\Python37.zip', 'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\DLLs', 'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\lib', 'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32', 'C:\\Users\\Will\\AppData\\Roaming\\Python\\Python37\\site-packages', 'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\lib\\site-packages', 'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\lib\\site-packages\\win32', 'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\lib\\site-packages\\win32\\lib','C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37-32\\lib\\site-packages\\Pythonwin']
>>> sys.exit(1)            # 退出程序，并返回一个值
>>> sys.exit(1)
- >>> sys.getsizeof('a')    # 返回对象占用的内存大小
50
>>> sys.getsizeof('ab')
51
## 可以对stdin、stdout、stderr进行操作。
>>> sys.stdout
<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>
>>> sys.stdout.write("hello")
hello5
>>> sys.stdout.flush()
- 下例是重定向stout、stderr：
>>> f = open("stdout.txt", "w")
>>> sys.stdout = f
>>> sys.stderr = f
>>> print("hello")
>>> raise RuntimeError("testing...")
  - 如果想恢复原本的stdout、stderr，需要先备份：
>>> __stdout__, __stderr__ = sys.stdout, sys.stderr
##
##
##

♢ shutil
## shutil：Python的标准库，提供了一些拷贝文件的方法。
- 例：
>>> import shutil
>>> shutil.copy("D:/1.txt", "D:/1")            # 拷贝源文件，保存到目标目录下
'D:/1\\1.txt'                                # 执行成功之后会返回目标路径
>>> shutil.copy("D:/1.txt", "./1/2.txt")        # 拷贝源文件，保存为目标文件（目标文件已存在时会自动覆盖）
'./2.txt'

拷贝时的目标目录需要已经存在，否则容易出错。
如果目标目录"D:/1"已存在，则源文件会被保存为"D:/1/1.txt"；
如果"D:/1"不存在，或者为文件，则源文件会被保存为"D:/1"，即自动重命名为文件1；
如果目标路径为"./1/2.txt"，且上一级目录'./1/'不存在，则会直接报错，无法拷贝。


>>> shutil.copytree("D:/1", "D:/2")            # 拷贝源目录，保存为目标目录（目标目录已存在时会报错）
'D:/2'
>>> shutil.move("D:/1", "D:/2")                # 移动文件或目录
'D:/2'
##
##
##

♢ psutil
## psutil：Python的第三方库，用于查看系统的硬件信息、运行状态。
- 安装：pip install psutil
- 查看进程的信息。
>>> psutil.pids()                    # 返回所有进程的pid
[0, 4, 88, 120, 140, 344, 412, 532, 612, 628, 728, 800, 808, ……]
>>> psutil.pid_exists(0)            # 查看某个pid的进程是否还在运行
True
>>> psutil.Process(0)                # 得到某个进程的引用，从而可以访问该进程的各种方法
psutil.Process(pid=0, name='System Idle Process', started='2019-06-21 18:25:21')
>>> p = psutil.Process(4500)        # 使用psutil.Process(os.getpid())可获得当前进程的引用
>>> p.status()                    # 返回进程的状态
'running'
>>> p.terminate()                    # 终止进程
>>> p.name()                        # 返回进程的名字
'BaiduNetdisk.exe'
>>> p.exe()                        # 返回进程的可执行文件的路径
'C:\\Users\\Leo\\AppData\\Roaming\\baidu\\BaiduNetdisk\\BaiduNetdisk.exe'
>>> p.cwd()                        # 返回进程当前的工作目录
'C:\\Windows\\System32'
>>> p.cmdline()                    # 返回进程的启动命令
['C:\\Users\\Leo\\AppData\\Roaming\\baidu\\BaiduNetdisk\\BaiduNetdisk.exe']
>>> p.create_time()                # 返回进程的创建时间（为UTC时间戳）
1561193118.0
>>> p.username()                    # 返回启动该进程的用户名
'LEO\\Leo'
>>> p.terminal()                    # 返回启动该进程的终端
AttributeError: 'Process' object has no attribute 'terminal'
>>> p.cpu_percent(1)                # 阻塞1秒，然后返回这段时间内该进程的CPU使用率
15.6
>>> p.memory_info()                # 返回进程的内存使用信息
pmem(rss=63967232, vms=60678144, num_page_faults=554783977, peak_wset=107614208, wset=63967232, peak_paged_pool=809056, paged_pool=751528, peak_nonpaged_pool=109032, nonpaged_pool=66736, pagefile=60678144, peak_pagefile=62353408, private=60678144)
>>> p.connections()                # 查看进程使用的所有网络连接
[pconn(fd=-1, family=<AddressFamily.AF_INET: 2>, type=1, laddr=addr(ip='10.135.149.134', port=56855), raddr=addr(ip='153.37.235.47', port=5287), status='ESTABLISHED'), pconn(……]
>> p.open_files()                    # 查看进程打开的所有文件
[popenfile(path='C:\\Users\\Leo\\AppData\\Local\\Temp\\baidu\\BaiduYunGuanjia\\at_monhavior-shm', fd=-1), popenfile(……]
>>> p.num_threads()                # 查看进程启动的线程数
42
>>> p.threads()                    # 列出该进程启动的所有线程
[pthread(id=17336, user_time=2161.453125, system_time=12109.109375), pthread(……]
>>> p.parent()                    # 返回父进程的引用
psutil.Process(pid=4940, name='explorer.exe', started='2019-06-22 16:18:53')
>>> p.children()                    # 列出所有子进程
[psutil.Process(pid=1524, name='BaiduNetdiskHost.exe', started='2019-06-22 16:45:19'), psutil.Process(pid=9536, name='BaiduNetdiskHost.exe', started='2019-06-22 16:45:20')]
- 查看CPU的信息。
>>> psutil.cpu_count()                            # 查看CPU的核数（默认为逻辑核数）
8
>>> psutil.cpu_count(logical=False)                # 查看CPU的物理核数
4
>>> psutil.cpu_percent()                            # 查看所有CPU的平均使用率（从上一次调用到目前为止）
7.2
>>> psutil.cpu_percent(interval=1, percpu=True)    # 阻塞1秒，然后返回这段时间的各个CPU使用率
[20.6, 7.7, 10.8, 20.0, 12.3, 4.6, 10.8, 4.6]
>>> psutil.cpu_times_percent()                    # 查看CPU各方面的使用率（像Linux的uptime命令）
scputimes(user=3.2, system=4.0, idle=92.5, interrupt=0.2, dpc=0.2)
>>> psutil.cpu_stats()
scpustats(ctx_switches=3346114770, interrupts=2451502960, soft_interrupts=0, syscalls=2114761291)
- 查看内存的信息。
>>> psutil.virtual_memory()                        # 虚拟内存（像Linux的free命令，单位为bytes）
svmem(total=8424906752, available=2264326144, percent=73.1, used=6160580608, free=2264326144)
>>> psutil.swap_memory()                            # swap
sswap(total=15404228608, used=9708523520, free=5695705088, percent=63.0, sin=0, sout=0)
- 查看磁盘的信息。
>>> psutil.disk_partitions()                        # 查看各个磁盘分区的信息
[sdiskpart(device='C:\\', mountpoint='C:\\', fstype='NTFS', opts='rw,fixed'), sdiskpart(device='D:\\', mountpoint='D:\\', fstype='NTFS', opts='rw,fixed')]
>>> for x in psutil.disk_partitions():                # 提取磁盘分区的device名字
...     print(x[0])
...
C:\
D:\
>>> psutil.disk_usage("D:")                        # 查看指定磁盘分区的使用率
sdiskusage(total=295923871744, used=237350260736, free=58573611008, percent=80.2)
>>> psutil.disk_io_counters()                        # 查看磁盘IO的总量
sdiskio(read_count=1898598, write_count=1444576, read_bytes=131522050560, write_bytes=137437140480, read_time=1106, write_time=980)
- 查看网络的信息。
>>> psutil.net_if_addrs()                            # 查看所有网卡的地址
{'以太网': [snicaddr(family=<AddressFamily.AF_LINK: -1>, address='34-64-A9-15-EF-A9', netmask=None, broadcast=None, ptp=None), snicaddr(family=<AddressFamily.AF_INET: 2>, address='192.168.10.172', netmask='255.255.255.0', broadcast=None, ptp=None), snicaddr(family=<AddressFamily.AF_INET6: 23>, address='fe80::7c60:86c4:a3e2:c668', netmask=None, broadcast=None, ptp=None)], ……}
>>> for k, v in psutil.net_if_addrs().items():        # 提取网卡的mac地址
...     for item in v:
...         address = item[1]
...         if '-' in address and len(address) == 17:
...             print(address)
...
34-64-A9-15-EF-A9
>>> psutil.net_if_stats()                        # 查看所有网卡的信息（像Windows的ipconfig -all命令）
{'以太网': snicstats(isup=False, duplex=<NicDuplex.NIC_DUPLEX_FULL: 2>, speed=0, mtu=1500), 'Loopback Pseudo-Interface 1': snicstats(isup=True, duplex=<NicDuplex.NIC_DUPLEX_FULL: 2>, speed=1073, mtu=1500), 'WLAN': ……}
psutil.net_connections(kind="tcp")
>>> psutil.net_connections()                    # 查看所有网络连接的信息（像Linux的ss命令）
[sconn(fd=-1, family=<AddressFamily.AF_INET: 2>, type=2, laddr=addr(ip='0.0.0.0', port=49665), raddr=(), status='NONE', pid=3800), sconn(……]
>>> psutil.net_connections(kind="tcp")            # 只查看TCP类型的网络连接的信息
[sconn(fd=-1, family=<AddressFamily.AF_INET: 2>, type=1, laddr=addr(ip='10.135.149.134', port=57878), raddr=addr(ip='211.97.82.37', port=443), status='CLOSE_WAIT', pid=1524), sconn(……]

##
##
##
##

♢ platform
## platform：Python的标准库，用于获取当前运行平台的信息。
- 关于Python解释器。
>>> import platform
>>> platform.architecture()[0]    # 返回Python解释器的位数
'64bit'
>>> platform.python_version()        # 返回Python解释器的版本
'3.7.3'
- 关于操作系统。
>>> platform.system()                # 返回操作系统的名字（在Linux系统上是返回'Linux')
'Windows'
>>> platform.platform()            # 返回操作系统的具体名字
'Windows-10-10.0.17763-SP0'
>>> platform.machine()            # 返回CPU的架构类型
'AMD64'
>>> platform.processor()            # 返回CPU的具体名字
'Intel64 Family 6 Model 158 Stepping 10, GenuineIntel'
>>> platform.node()                # 返回该主机在网络中的名字
'Leo'
- 以上函数的返回值大多为str类型。如果没有确定的答案，则返回空字符串。
##
##
##

关于时间

常见概念：
- 格林威治时间（Greenwich Mean Time，GMT）
  - 英国伦敦格林威治位于零度经线处，因此常用于代表 0 时区。
- 协调世界时间（Coordinated Universal Time，UTC）
  - UTC 时区是指 0 时区。UTC 时间是指 0 时区的当前时间。
  - UTC 时间比 GMT 更精确，常用于供世界各地校准时间。
  - 考虑到地球自转周期会变化，当 UTC 时间与原子时钟的误差达到 ±0.9 秒时，国际计量局就会将 UTC 时间调快或调慢一秒。这一操作称为闰秒，一般发生在6月或12月的最后一秒。
- 夏令时（Daylight Saving Time，DST）
  - 富兰克林提出了夏令时制度：夏天的太阳比较早升起，所以在夏天开始时将时钟拨快一小时，从而早睡早起，提高日光的利用率，减少晚上的照明耗能。在夏天结束时再将时钟调慢一小时。
- CST ：可能是以下时区的缩写：
  - 美国中部时间：Central Standard Time (USA) UTC-6:00
  - 澳大利亚中部时间：Central Standard Time (Australia) UTC+9:30
  - 中国标准时间：China Standard Time UTC+8:00
  - 古巴标准时间：Cuba Standard Time UTC-4:00

- Unix 时间戳（Unix timestamp）
  - 又称为 Unix time、POSIX time 。
  - 是按 UTC 时区计算从 `1970-1-1 00:00:00` 开始到现在经过的秒数，不考虑闰秒。
    - 如果在东八区，则是计算从 `1970-1-1 08:00:00` 开始的秒数。因此，不同时区计算得到的 Unix 时间戳相同，可以通用。
    - 例如：UTC 时区的 `2020-01-01 08:00:00` 时刻对应的 Unix 时间戳是 `1577808000` 。
  - 一些计算机系统将 Unix 时间戳用 32 位的空间存储，导致最大只能记录到 2038 年。

- ISO8601 ：一种表示日期、时刻的字符串格式。如下：
  ```sh
  1970-01-01T00:00:00Z          # 末尾的字母 Z 表示 UTC 时区
  1970-01-01T00:08:00+08:00     # 末尾的 +8 表示东八区
  ```
  - 采用 24 小时制。
  - 用字母 T 分隔日期与时间。
  - 各个时间字段的位数固定，缺位则用 0 补齐。
  - 各个时间字段按范围大小降序排列，依次是：年、月、日、时、分、秒。




♢ time
## time：Python的标准库，用于获取时间。
- 获取 Unix 时间戳：
>>> import time
>>> time.time()
1544593113.593077
  - 运行time.time()的延迟很小，不足1ms。

> Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。

- 获取UTC时间的struct_time元组：
>>> time.gmtime(time.time())            # 将时间戳转换成struct_time元组
time.struct_time(tm_year=2019, tm_mon=5, tm_mday=31, tm_hour=4, tm_min=40, tm_sec=52, tm_wday=4, tm_yday=151, tm_isdst=0)
>>> time.gmtime().tm_year                # 不输入参数时，默认使用time.time()
2019
  - 可以访问struct_time元组中的任意属性。其中，tm_isdst表示是否是夏令时（DST）。
- 获取本地时间的struct_time元组：
>>> time.localtime(time.time())        # 将UTC时间的时间戳转换成本地时间的struct_time元组
time.struct_time(tm_year=2019, tm_mon=5, tm_mday=31, tm_hour=12, tm_min=46, tm_sec=15, tm_wday=4, tm_yday=151, tm_isdst=0)
>>> time.localtime().tm_year            # 不输入参数时，默认使用time.time()
2019
## struct_time元组。
- 将struct_time元组转换成时间戳（会自动从本地时区转换成UTC时区）：
>>> time.mktime((2019,2,21,14,10,45,3,52,0))
1545878778.0                # 得到的时间戳没有小数部分
  - 如果给time.mktime()输入的年份早于1970年就会报错。
  - time.mktime()在转换时会自动计算本地时区与UTC时区的差值，如下：
>>> time.mktime(time.localtime()) - int(time.time())
0.0
>>> time.mktime(time.gmtime()) - int(time.time())
-28800.0

- 将struct_time元组转换成指定格式的字符串：
  - struct_time元组不包含毫秒，因此生成的字符串中不包含毫秒。
>>> time.strftime("%Y/%m/%d %H:%M:%S", time.localtime())
'2018/12/12 13:52:43'
- 将指定格式的字符串转换成struct_time元组：
>>> time.strptime("2018/12/12 13:52:43", "%Y/%m/%d %H:%M:%S")
time.struct_time(tm_year=2018, tm_mon=12, tm_mday=12, tm_hour=13, tm_min=52, tm_sec=43, tm_wday=2, tm_yday=346, tm_isdst=-1)

## time模块还可暂停当前线程、获取程序的运行时间。
- 暂停当前线程：
>>> time.sleep(3)
  - 让线程保持等待时，调用sleep()函数比空语句pass更好。
while 1:
    pass                # 在这个死循环中，线程会不停地跳转while循环，占用CPU
while 1:
    time.sleep(1)        # 在这个死循环中，线程会被被挂起，不会占用CPU
- 获取程序的运行时间：
>>> time.perf_counter()            # 返回程序的运行时间，在终端里则是打开Python编辑器后的时间
16.795266047
# 运行程序时可以用time.perf_counter()截取多个时间节点，计算它们的差值就可以知道程序的运行时间
>>> time.process_time()
0.078125
>>> time.thread_time()
0.078125
##
##
##

♢ datetime
## datetime：Python的标准库，基于time模块封装了一些API，适合处理日期、切换时区、计算两个日期的差或和。
- 时区要用pytz模块选择：
>>> import pytz
>>> pytz.all_timezones_set        # 返回所有可用时区名的集合
LazySet({'Europe/Tirane', 'Asia/Shanghai', 'America/New_York',...
>>> pytz.timezone("UTC")            # 返回某个时区名对应的时区对象
<UTC>
- 获取当前时间的datetime对象：
>>> from datetime import datetime                # 从datetime模块导入datetime类
>>> datetime.utcnow()                            # 获取UTC时区的当前时间，返回一个datetime对象
datetime.datetime(2019, 5, 30, 10, 0, 0, 505080)
>>> datetime.now()                               # 获取当前时间，时区默认为本地
datetime.datetime(2019, 5, 30, 18, 0, 0, 505080)

- 转换时区：
>>> import pytz
>>> datetime.now(tz=pytz.timezone("UTC"))                # 获取指定时区的当前时间
datetime.datetime(2019, 5, 30, 10, 0, 0, 505080, tzinfo=<UTC>)
>>> datetime.now().astimezone(pytz.timezone("UTC"))      # 将datetime对象从当前时区转换到指定时区
datetime.datetime(2019, 5, 30, 10, 0, 0, 505080, tzinfo=<UTC>)
>>> datetime.now().astimezone(pytz.timezone("Asia/Shanghai"))
datetime.datetime(2019, 5, 30, 18, 0, 0, 505080, tzinfo=<DstTzInfo 'Asia/Shanghai' CST+8:00:00 STD>)


>>> from datetime import date
>>> date(2019, 5, 1)
datetime.date(2019, 5, 1)

## datetime对象。
定义：
class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *)
创建 datetime 对象时，至少要传入 year、month、day 三个参数。
并且会检查传入的所有参数是否在如下合理范围内，否则抛出 ValueError 异常。
```
MINYEAR <= year <= MAXYEAR
1 <= month <= 12
1 <= day <= 指定年月的天数
0 <= hour < 24
0 <= minute < 60
0 <= second < 60
0 <= microsecond < 1000000
```

- datetime对象包含了年、月、日、时、分、秒以及时区信息。
>>> d = datetime.now()
>>> print(d.year, d.month, d.day)
2019 5 30
>>> print(d.hour, d.minute, d.second, d.microsecond)
18 0 0 505080
>>> d.replace(hour=12)            # 修改datetime对象的值
datetime.datetime(2019, 5, 30, 12, 0, 0, 505080)

- datetime 对象的 tzinfo 属性默认为 None ，即不确定时区。在涉及到时区的操作时，可能会被当作UTC时区处理，也可能会被当作本地时区处理，容易出错。所有应该主动标明时区，如下：
>>> d.tzinfo == None
True
>>> d.replace(tzinfo=pytz.timezone("Asia/Shanghai"))
datetime.datetime(2019, 5, 30, 18, 0, 0, 505080, tzinfo=<DstTzInfo 'Asia/Shanghai' LMT+8:06:00 STD>)

time 模块不支持修改时间的时区，而 datetime 模块支持：
- 可以通过 datetime.astimezone() 方法转换时区。此时显示的时间字符串会按时差变化，但底层的Unix时间戳不变。
- 可以通过 datetime.replace() 方法强行改变时区。此时显示的时间字符串不变，但底层的Unix时间戳会按时差变化。

例：将时间字符串从 UTC 时区转换到指定时区
```py
>>> utc_time_str = '2019/05/30 10:00:00'
>>> utc_time = datetime.strptime(utc_time_str, "%Y/%m/%d %H:%M:%S").replace(tzinfo=pytz.timezone("UTC"))
>>> utc_time.astimezone(pytz.timezone("Asia/Shanghai")).strftime("%Y/%m/%d %H:%M:%S")
'2019/05/30 18:00:00'
```

- 与 timetuple 的转换：
>>> d.timetuple()      # 直接转换成 timetuple
time.struct_time(tm_year=2019, tm_mon=5, tm_mday=30, tm_hour=18, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=150, tm_isdst=-1)
>>> d.utctimetuple()   # 先转成成 UTC 时区，再转换成 timetuple ，不过 d.tzinfo 为 None ，得到的 timetuple 并不是正确的 UTC 时间
time.struct_time(tm_year=2019, tm_mon=5, tm_mday=30, tm_hour=18, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=150, tm_isdst=0)
>>> d.replace(tzinfo=pytz.timezone("Asia/Shanghai")).timetuple()
time.struct_time(tm_year=2019, tm_mon=5, tm_mday=30, tm_hour=18, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=150, tm_isdst=0)
>>> d.replace(tzinfo=pytz.timezone("Asia/Shanghai")).utctimetuple()     # 结果为正确的 UTC 时间
time.struct_time(tm_year=2019, tm_mon=5, tm_mday=30, tm_hour=9, tm_min=54, tm_sec=0, tm_wday=3, tm_yday=150, tm_isdst=0)


- 与时间戳的转换：
>>> d.timestamp()                    # 将datetime对象转换成时间戳（不会自动转换成UTC时区）
1559210400.50508
>>> datetime.fromtimestamp(1559210400.50508, tz=pytz.timezone("UTC")) # 将时间戳转换成datetime对象
datetime.datetime(2019, 5, 30, 10, 0, 0, 505080, tzinfo=<UTC>)

- 与字符串的转换：
  - 与time.strftime()相比，datetime能用 %f 输出微妙。
>>> d.strftime("%Y/%m/%d %H:%M:%S.%f")            # 将datetime对象转换成指定格式的字符串
'2019/05/30 18:00:00.505080'
>>> datetime.strptime('2019/05/30 18:0:0.505080', "%Y/%m/%d %H:%M:%S.%f")
datetime.datetime(2019, 5, 30, 18, 0, 0, 505080)    # 将指定格式的字符串转换成datetime对象


- datetime对象支持加减法运算：
>>> from datetime import timedelta                # 从datetime模块导入timedelta类
>>> datetime.now() - datetime.utcnow()            # 两个datetime对象相加减，会生成timedelta对象
datetime.timedelta(seconds=28800)
>>> datetime.now() + timedelta(hours=10)        # 一个datetime对象可以与timedelta对象相加减
datetime.datetime(2019, 5, 31, 4, 0, 0, 505080)
>>> timedelta(milliseconds=100).total_seconds()    # 获取timedelta对象的秒值
0.1
##
##
##

♢ apscheduler
## apscheduler：Python的第三方库，用于执行定时任务。
- 安装：pip install apscheduler
- 原理：当一个任务到达触发时刻时，就创建一个子线程来运行它。
- 例：
from apscheduler.schedulers.blocking import BlockingScheduler
from datetime import datetime, timedelta

schedule = BlockingScheduler()        # 创建一个任务表，它在运行时会阻塞当前线程

# 添加一个定时任务，只会执行一次
schedule.add_job(func=print, args=('hello',), kwargs=None, trigger='date', next_run_time=datetime(2012, 10, 1, 0, 0, 0))

# 添加一个周期性任务，每隔一段时间就执行一次
schedule.add_job(func=print, args=('hello',), trigger='interval', seconds=3)

# 添加一个日常循环任务，在每天的12:30执行一次
schedule.add_job(func=print, args=('hello',), trigger='cron', hour=12, minute=30)

schedule.start()            # 启动任务表
schedule.get_jobs()        # 返回一个列表，包含所有待执行的任务（不包含已经失效的任务）
schedule.shutdown()        # 终止任务表

- 关于add_job()方法。
  - trigger参数表示任务的触发方式。
  - 可传入max_instances参数，控制任务的运行实例数量。默认为1。
  - 对于'interval'类型的任务，可使用以下参数控制任务的间隔时间：
weeks(int)    间隔几周
days(int)    间隔几天
hours(int)    间隔几小时
minutes(int)    间隔几分钟
seconds(int)    间隔多少秒
start_date(datetime or str)    开始日期
end_date(datetime or str)    结束日期
  - 对于'cron'类型的任务，可使用以下参数控制任务的启动时刻：
year、month、week、day_of_week（取值为0~6）、hour、minute、second、start_date、end_date
- 删除任务：
job = scheduler.add_job(func=print, args=('hello',), trigger='interval', seconds=3)
job.remove()
##
##
##

♢ celery
## celery：Python的第三方库，是一个分布式的任务队列，常用于执行大量的异步任务、定时任务。
- 安装：pip install celery
- 原理：用户将任务保存到broker服务器。而worker会从broker服务器提取任务并执行，然后将执行结果保存到backend服务器。
  - broker、backend服务器可以采用RabbitMQ，也可以采用Redis。
  - celery采用分布式架构，可以有多个worker。
- 任务有以下几种状态：
  - PENDING    ：等待被执行。
  - STARTED    ：已被启动，正在执行。
  - RETRY    ：发生异常，正在重新执行。
  - SUCCESS    ：执行成功。
  - FAILURE    ：执行失败。
## 例：
- 创建异步任务：
>>> import celery
>>> cel = celery.Celery(backend='redis://127.0.0.1:6379/1', broker='redis://127.0.0.1:6379/2')
    # 可以加上密码，例如'redis://:123456@127.0.0.1:6379/1'
    # 此时只是创建客户端，等执行实际操作时才会连接到broker
>>> @cel.task            # 使用装饰器添加任务
... def fun1(*args):        # 函数在第一次添加到celery时就固定了，不能再重新定义
...     print(b)
...
>>> fun1('hello')                    # 正常调用该函数
hello
>>> task = fun1.delay('hello')    # 异步执行该函数（这会将任务发送到broker），用delay()方法传入参数
>>> task
[2019-10-28 16:00:35,998: WARNING/MainProcess] <AsyncResult: c399d950-c16e-4912-8d19-624393abf1ef>
>>> result = celery.result.AsyncResult(id=task.id, app=cel)        # 获取任务的result
>>> result.status                    # 查看任务状态
[2019-10-28 16:01:01,766: WARNING/MainProcess] 'PENDING'
- 运行worker有两种方法。
  - 在终端执行以下命令：
celery worker
--app task1            # 指定任务所在的.py文件
--loglevel info
--logfile <file>        # 指定日志文件的保存路径（默认输出到stdout）
  - 或者在python中执行主函数：
cel.worker_main()
- 创建定时任务：
>>> result = fun1.apply_async(args=('hello',), kwargs=None, countdown=10)
>>> result.status
'PENDING'
- 设置周期性任务：
cel.conf.beat_schedule = {
    'schedule1': {
        'task': 'task1.fun1',                # 把task1.py文件中的fun1()函数添加成任务
        'args': ('hello',)                    # 输入参数
        'schedule': timedelta(seconds=2),    # 间隔时间
    },
    'schedule2': {
        ...
    },
}
##
##
##

关于数据

##
##
##

♢ string
## string：Python的标准库，提供了一些常用的字符集合。
- 关于数字。
>>> import string
>>> string.digits                # 全部数字
'0123456789'
>>> string.hexdigits            # 全部十六进制数字
'0123456789abcdefABCDEF'
>>> string.octdigits            # 全部八进制数字
'01234567'
- 关于字母。
>>> string.ascii_letters        # 全部字母
'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
>>> string.ascii_lowercase    # 全部小写字母
'abcdefghijklmnopqrstuvwxyz'
>>> string.ascii_uppercase    # 全部大写字母
'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
- 其它。
>>> string.whitespace            # 所有空白字符。
' \t\n\r\x0b\x0c'

# \x0b 表示让光标垂直换行，等价于 \v 。\x0c 表示让打印机换到下一张纸，等价于 '\f' 。
# \b 表示让光标回退一格， \x20 表示一个空格。

>>> string.punctuation        # 所有标点符号
'!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
>>> string.printable            # 所有可打印字符（等于digits + letters + whitespace + punctuation）
'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c'
##
##
##

♢ collections
## collections：Python的标准库，提供了一些容器类。
- 可迭代对象、迭代器。
>>> from collections.abc import Iterable, Iterator
>>> isinstance("Hello", Iterable)
True
>>> isinstance(iter("Hello"), Iterator)
True
##
##

关于调试
♢ traceback
## traceback：Python的标准库，用于获取stack的信息。
- 例：
import traceback
try:
    ...
except :                                # 使用时不需要实例化异常类
    traceback.print_exc()                # 打印出完整的异常信息
    list1 = traceback.format_exc()        # 保存异常信息
##
##
##
##
##
##
##

♢ inspect
## inspect：Python的标准库，提供了一些查询对象属性、查看堆栈的方法，常用于调试。
## 判断对象的类型。
- def ismodule(object) -> bool
  - 功能：判断对象是否为模块名。
  - 例：
>>> from inspect import ismodule
>>> ismodule(inspect)
True
- def isclass(object) -> bool
  - 功能：判断对象是否为类名。
  - 例：
>>> a = int
>>> isclass(a)
True
- def ismethod(object) -> bool
  - 功能：判断对象是否为某个实例的普通方法或类方法名。（根据该对象是否具有__func__属性）
  - 例：
>>> class Test(int):
...     def fun1(self):
...         pass
...
>>> ismethod(Test().fun1)
True
>>> ismethod(Test.fun1)        # 必须是实例的方法
False
>>> ismethod("".encode)        # 不能为built-in类的实例的方法
False
- def isfunction(object) -> bool
  - 功能：判断对象是否为用户定义的函数名（非built-in）。
  - 例：
>>> isfunction(isfunction)
True
>>> isfunction(lambda : ...)        # 可以是匿名函数
True
>>> isfunction(len)                # 不可以是内置函数
False
>>> isfunction("".encode)        # 不可以是方法
False
- def isbuiltin(object) -> bool
  - 功能：判断对象是否为built-in的函数或方法名。
  - 例：
>>> inspect.isbuiltin(len)
True
>>> inspect.isbuiltin("".encode)
True
- def isroutine(object) -> bool
  - 功能：判断对象是否为函数名或方法名。
  - 例：
>>> inspect.isroutine(len)
True
>>> inspect.isroutine("".encode)
True
- def isgenerator(object) -> bool
  - 功能：判断对象是否为生成器。
  - 例：
>>> isgenerator((x for x in range(5)))
True
## 查看对象的定义。
- def getfile(object: object) -> str
  - 功能：返回定义该对象的.py文件的绝对路径。
  - 例：
>>> getfile(getfile)
'C:\\Users\\Will\\AppData\\Local\\Programs\\Python\\Python37\\lib\\inspect.py'
>>> getfile(int)
TypeError: <module 'builtins' (built-in)> is a built-in class
- def getsourcelines(object) -> (List[str], int)
  - 功能：获取一个对象的源代码，返回一个list（包含每行代码字符串）、行号。
  - 例：
>>> getsourcelines(getfile)
(['def getfile(object):\n', '    """Work out which source or compiled file an object was defined in."""\n', '    if ismodule(object):\n',...'], 642)
- def signature(callable, *, follow_wrapped=True) -> Signature
  - 功能：查看函数的一些属性，返回一个Signature对象。
  - 例：
>>> def fun1(a, b: str, c: int = 0):
...     pass
...
>>> sign = signature(fun1)
>>> sign
<Signature (a, b: str, c: int = 0)>
>>> sign.parameters                # 获取函数的形参列表（与定义处一致），返回一个dict类对象
mappingproxy(OrderedDict([('a', <Parameter "a">), ('b', <Parameter "b: str">), ('c', <Parameter "c: int = 0">)]))
  - 可以模拟给函数形参赋值：
>>> arguments = sign.bind(1, b=2)                # 正常传参，要传入所有必需参数
>>> arguments.arguments                        # 显示被赋值的那些参数
OrderedDict([('a', 1), ('b', 2)])
>>> arguments.args
(1, 2)
>>> arguments.kwargs
{}
>>> sign.bind(1).arguments
TypeError: missing a required argument: 'b'
>>> sign.bind_partial(1).arguments            # 只传入部分参数
OrderedDict([('a', 1)])
##
##
##


♢ pytest
## pytest：Python的第三方库，是一个开源的Python单元测试框架。
- pytest 比 unittest 的功能更多，并且可以兼容地执行 unittest 的测试用例。

- 安装：pip install pytest
- pytest的基本用法如下：
  - 将单元测试的脚本命名为 test_*.py 或 *_test.py 。
  - 将单元测试的函数命名为 test_* 。
  - 将单元测试的类命名为 Test* ，且该类不能定义__init__()方法。
  - 如下：
def fun1(x):
    return x**2

class TestClass:
    def test_fun1_1(self):
        assert fun1(1)

    def test_fun1_2(self):
        for i in range(100):
            assert fun1(i) > 0
- 命令：
pytest [file_or_dir]...    # 让pytest执行指定的测试脚本
-q        # 用一行显示所有测试脚本的测试结果
-v        # 详细地显示每个测试函数的测试结果
    -s        # 显示测试用例的stdout
  - 不指定测试脚本的话，pytest会自动在当前目录及其子目录中搜集单元测试的脚本来执行（搜集过程是import这些脚本）。
- 执行pytest之后的显示内容如下：
D:\1\test_Python>pytest
======================== test session starts ========================
platform win32 -- python 3.7.2, pytest-4.3.1, py-1.8.0, pluggy-0.9.0
rootdir: D:\1\test_Python, inifile:
collected 2 items

test_.py .F                                                          [100%]

  - 测试脚本后，绿色的 . 表示一个测试函数pass了，红色的 F 表示一个测试函数fail了，蓝色的 [100%] 表示pytest的测试进度。
  - 红色的 E代表一个抛出的异常，即源代码没有捕捉到的异常。
## pytest支持传统的单元测试风格：定义setup()、teardown()函数，pytest运行测试函数前会自动调用setup()进行测试前的准备工作，运行测试函数后会自动调用teardown()进行测试后的清理工作。
- 按作用区域分级：
  - setup_module()、teardown_module()        ：执行每个测试模块的前后被调用。
  - setup_function()、teardown_function()    ：执行每个测试函数的前后被调用。
  - setup_class()、teardown_class()        ：执行每个测试类的前后被调用。
  - setup_method()、teardown_method()        ：执行每个测试类中的测试方法的前后被调用。
  - setup()、teardown()                    ：执行每个测试类中的测试函数的前后被调用。
- 例如：
  - 定义如下测试类：
import pytest

class TestClass:
    def setup_class(self):
        self.result = []
        self.result.append("setup_class")

    def teardown_class(self):
        self.result.append("teardown_class")
        with open("1.txt", 'w') as f:
            f.writelines('\n'.join(self.result))    # 记录测试方法的运行结果

    def setup_method(self):
        self.result.append("setup_method")

    def teardown_method(self):
        self.result.append("teardown_method")

    def test_1(self):
        self.result.append("test_1")

    def test_2(self):
        self.result.append("test_2")
- 输入命令pytest进行测试，在1.txt中可看到测试结果如下：
setup_class
setup_method
test_1
teardown_method
setup_method
test_2
teardown_method
teardown_class
## 用with pytest.raises()可以判断源代码是否抛出了某个异常。如果抛出了，则pass；如果没抛出，则fail。
import pytest

def fun1():
    raise KeyboardInterrupt

def test_fun1():
    with pytest.raises(KeyboardInterrupt):
        fun1()
## pytest还提供了装饰器 @pytest.fixture，用于标记一个fixture函数，只要把它的函数名作为形参传入测试函数，pytest就会在进行测试时自动调用它。
- 直接使用该装饰器的例子：
@pytest.fixture(scope="function")        # 相当于@pytest.fixture
def fun1(request):
    print("fun1")

def test_1(fun1):                        # 传入fixture函数的函数名
    assert 0
  - scope = 'function' 表示在运行某个测试函数时调用fixture函数。scope可取值为"function"（默认该值）、
- 给fixture函数传入参数的例子：
@pytest.fixture(params=[1, 2, 3], ids=['a', 'b','c'])
def fun1(request):            # fixture函数通过request参数获取装饰器的一些信息
    print(request.param)
    assert request.param == 0

def test_1(fun1):
    pass
  - 这里执行test_1()时会调用三次fun1()——即测试三次。每次传入一个参数，并给test_1()记上一个id，即test_1[a]、test_1[b]、test_1[c]。
  - 如果没有给装饰器设置参数ids，pytest会自动生成数字编号，即test_1[1]、test_1[2]、test_1[3]。
## pytest的可用插件。
- pytest-cov：用于统计测试覆盖率，即每个py文件中的源代码被测试用例执行到的百分比。
- pytest-django：用于执行Django项目目录下的测试用例。
##


也可通过调用 pytest.main() 来执行 pytest ，支持传入命令参数。
```py
import pytest

if __name__ =="__main__":
    exit(pytest.main(['-v']))
```





关于运行
♢ argparse
## argparse：Python的标准库，用于处理启动脚本时输入的命令行参数。
- 输入命令行参数时通常有两种形式：
D:\1\test_Python>python test.py --test            # 只输入选项名
D:\1\test_Python>python test.py --test     1        # 输入选项名，并输入该选项的参数
  - 选项名通常还可使用简写（如果程序支持这种操作的话），比如--test/-t。
- 例如，在test.py中保存以下内容：
import argparse
parser = argparse.ArgumentParser(description="This script is use to test.")
# description是该脚本的说明信息，使用选项--help/-h时会显示出来
parser.add_argument("--test", "-t", help="just for test", action="store_true")
    # help是该选项的说明信息，使用选项--help/-h时会显示出来
    # action="store_true"表示当输入选项--test/-t时（不需要输入其值）会将args.test的值置为true
parser.add_argument("--level", "-l", type=int, default=0)
    # default=0表示该选项的默认值是0，而且限制输入值为int型

, required=True)
非必须参数才设置默认值

args = parser.parse_args()        # 将启动脚本时输入的命令行参数解析并保存到args中
print(args.test)                    # 获取选项test的值
print(args.level)                # 获取选项level的值
- 然后，在终端测试启动该脚本：
  - argparse会自动生成选项--help/-h的相应内容，可直接使用：
D:\1\test_Python>python test.py –h
usage: test.py [-h] [--test] [--level LEVEL]
This script is use to test.
optional arguments:
  -h, --help            show this help message and exit
  --test, -t            just for test
  --level LEVEL, -l LEVEL
  - 这里使用选项--test/-t时不需要输入其值。
D:\1\test_Python>python test.py --test
True
0
  - 这里使用选项--level/-l时需要输入该选项的值，除非不使用该选项（会用默认值）。
D:\1\test_Python>python test.py
False
0

D:\1\test_Python>python test.py --level
usage: test.py [-h] [--test] [--level LEVEL]
test.py: error: argument --level/-l: expected one argument

D:\1\test_Python>python test.py --level 1
False
1


还可以直接获取命令行参数列表：
import sys
print(sys.argv)

注意argv[0]是执行的文件名


♢ pyinstaller
## pyinstaller：Python的第三方库，用于将Python脚本打包成可执行文件。
- 安装：pip install pyinstaller
- 例：
pyinstaller  D:\1\1.py     # 打包成一个文件夹，包含一堆运行库
-F                # 打包成一个可执行文件，体积较大
-w                # 启动程序时只显示GUI窗口，不打开一个终端窗口（针对Windows、MacOS的选项）
-p ./utils        # 指明寻找模块的路径（如果找不到该模块的话）
--icon 1.ico        # 设置程序的图标
  - 基于64位的Python解释器打包的可执行文件不能在32位的电脑上使用，但反之可以兼容。
  - 使用-w选项的话，如果启动程序失败，就看不到报错信息了。
  - build目录下的warn-*.txt文件中记录了找不到的模块，但那些模块可能不需要导入。
- 打包之后，会在当前目录下生成两个文件夹。
  - build：保存打包过程中的一些信息。
  - dist：保存打包结果。
-
##
##
##

其它模块
♢ functools
## functools：Python的标准库，提供了一些功能函数、装饰器。
##
## class partial(func, *args, **keywords)
- 功能：给函数传入一些参数，装饰成一个新函数。又称为偏函数。
- 例：
>>> import functools
>>> def fun1(a, b, c=0, d=0):
...     print(a, b, c, d)
...
>>> fun1_new = functools.partial(fun1, 1, 2, c=3)
>>> fun1_new
functools.partial(<function fun1 at 0x7f58aa51aa60>, 1, 2, c=3)
>>> fun1_new()
1 2 3 0
>>> fun1_new('c')            # 此时传入的位置参数会被赋值给参数c
TypeError: fun1() got multiple values for argument 'c'
>>> fun1_new(c='c')        # 以关键字的形式传入参数，就不会报错重复赋值
1 2 c 0
##
##
##





## 创建子进程、子线程时，可以把它们设置成daemon，即后台运行。（此daemon不是指守护进程）
- Python创建的子进程、子线程默认是非daemon。
- 创建一个daemon之后，就不必考虑如何让它结束。
  - 当一个进程组中的所有非daemon进程结束时，系统会自动终止所有daemon线程，然后结束该进程组。
  - 当一个进程中的所有非daemon线程结束时，系统会自动终止所有daemon线程，然后结束该进程。

## 结束子线程的方法。（对子进程同理）
- 由主线程控制何时停止子线程。
  - 尽量不要强制杀死子进程，应该让它自己自愿结束，清理自己占用的资源。因为子线程可能正在执行一些不宜中断的操作，比如拿到了某个资源的锁、打开了某个文件还没有关闭、创建了孙线程还没有关闭。
  - 当主进程异常终止时（比如被kill -9），子进程就会变成没人管的孤儿进程。
- 把子线程设置成daemon，当主进程退出时它们就会被系统自动终止。
- 等子线程处理完所有业务，自然结束。
  - 这需要事先确定子线程不会无限运行。
- 让子线程自己定期判断，是否要结束运行。


## CPython早先引入了GIL（Global Interpreter Lock，全局解释锁）机制。
- 为了保证多线程之间不冲突，同一时间只有一个线程拿到GIL运行，当该线程暂时不用执行字节码时（比如等待IO响应时）就会把GIL传递给其它线程，或者隔一小段时间后解释器会抢走这个GIL给其它线程（这可能中断正在执行的某个任务，所以以防万一，还是要加锁来保证线程安全）。
- 由于GIL机制，CPython程序同时只能使用CPU的一个核。因此，处理IO密集型任务时，用多线程能提高效率；处理CPU密集型任务时，用多进程或协程才能提高效率。


♢ threading
## threading：Python的标准库，用于创建多线程。
## 第一种创建线程的方法：直接调用类Thread()。
- class Thread(group=None, target=None, name=None, args=(), kwargs=None, daemon:bool)
  - 功能：定义一个线程。
  - group是线程组（目前尚未实现），target是要在线程中运行的函数，name是线程名，args是传递给线程函数的参数（必须是tuple型）。
  - 调用Thread.run()方法时，会在系统中创建该进程，分配资源，并调用Thread.start()方法开始运行。
  - 例：
>>> import threading
>>> def fun1(string):
...     print(string)
...
>>> t1 = threading.Thread(target=fun1, args=("Hello",))
>>> t1.start()        # 启动线程
Hello
  - Thread.start()方法会在系统中创建一个进程，分配资源，并调用Thread.run()方法。
  - Thread.run()方法定义了该线程的运行内容（即运行target函数）。
  - 每个线程只能调用一次start()方法，否则会报错。
- 查看线程的信息。
>>> t1.getName()        # 获得线程的名字
'Thread-1'
>>> t1.setName("t1")    # 设置线程的名字
>>> t1.isAlive()        # 判断线程是否正在运行
False
- 关于daemon线程。
>>> t1.isDaemon()                # 判断t1是否为daemon线程
>>> False
>>> t1.setDaemon(True)        # 将t1设置成daemon线程（必须在线程启动之前设置daemon属性）
RuntimeError: cannot set daemon status of active thread
- 阻塞线程。
>>> t1.join()            # 使CPU只运行该线程，阻塞其它线程的运行
>>> t1.join(3)            # 使CPU只运行该线程，最多持续3秒（t1可能提前运行结束）
- 关于多线程。
>>> threading.current_thread()        # 返回当前所在的线程对象
<_MainThread(MainThread, started 140176114464576)>
>>> threading.current_thread().getName()
'MainThread'
>>> threading.active_count()            # 返回当前运行的线程总数
2
>>> threading.enumerate()                # 列出当前运行的所有线程对象
[<_MainThread(MainThread, started 140176114464576)>, <Thread(Thread-1, started 140175977273088)>]
  - 调试运行时，会创建几个额外的线程。
  - 用 t.ident 可以获得线程的 ID 。

Python 的 threading 库没有提供杀死线程的方法，只能等线程自行退出。因此设计线程时必须让它能够自行退出。
如果不能自行退出，则只能使用 multiprocessing 库创建子进程，可以用 p.terminate() 杀死。



## 第二种创建线程的方法：继承threading.Thread类，重载其run()方法。
- 例：
>>> class myThread(threading.Thread):
...     def __init__(self, *args, **kwargs):
...         super().__init__(*args, **kwargs)    # 先调用super().__init__()进行初始化，再进行修改
...         self.name = kwargs.get("name")
...     def run(self):
...         print("Hello!")
...
>>> t1 = myThread(name="t1")
>>> t1.start()
Hello!
## 线程的锁。
- threading.Lock()：互斥锁。获得后使系统只运行当前线程，阻塞其它线程的运行。
>>> lock = threading.Lock()
>>> lock.acquire()        # 请求获得锁，这会阻塞当前线程，直到请求成功
True
>>> flag1 = True
>>> lock.release()        # 释放锁
  - 互斥锁同一时间只能被一个线程获得。
  - 死锁：线程请求获得锁时，锁一直没有释放，导致线程一直在等待。
例如：如果一个线程在获得锁之后没有释放就再调用acquire()方法，就会一直等待获得锁，陷入死锁。
- threading.RLock()：可重入锁。
  - 可重入锁可以重复获得，只不过调用了多少次acquire()就得调用多少次release()才能完全释放该锁。
>>> rlock = threading.RLock()
>>> rlock.acquire()
True
>>> rlock.acquire()
True
>>> rlock.release()
>>> rlock.release()
>>> rlock.release()
RuntimeError: cannot release un-acquired lock
## 定时任务。
- class Timer(interval, function, args=None, kwargs=None)
  - 功能：定义一个线程，在interval秒之后执行function函数。
  - 只不过是延迟启动一个线程，不适合处理大量的、频繁的定时任务。
  - 例：
>>> t = threading.Timer(3.0, print, ('hello',))
>>> t.start()        # 启动线程
>>> hello

>>> t.cancel()        # 取消该进程
##
##
##

♢ queue
## queue：Python的标准库，用于创建线程间通信的队列。
- queue模块提供了三种队列，都是基于生产者-消费者模式，自身实现了线程锁，是线程安全的。
## class Queue(maxsize: int)
- 功能：创建一个先进先出队列（FIFO）。
  - maxsize表示该队列的最大容量，当maxsize<=0时容量为无限大。
- 例：
>>> from queue import Queue
>>> q = Queue(10)
>>> q.qsize()            # 返回队列此时的大小（不可靠，队列的大小可能转瞬就变）
0
>>> q.empty()            # 判断队列是否为空
True
>>> q.full()                # 判断队列是否满了
False
- Queue.put(item, block=True, timeout=None)
  - 功能：往队列中写入一个元素（可以是任意类型）。
  - 当队列满了时，写入操作会一直阻塞，直到队列中有元素被消费掉。
如果block=False，则不阻塞，直接抛出queue.Full异常。
如果输入了timeout参数，则最多阻塞timeout秒，然后抛出异常。
  - 例：
>>> q.put(0)
>>> q.put("Hello", block=False)
>>> q.put([1, 2, 3], timeout=1)
- Queue.get(block=True, timeout=None)
  - 功能：从队列中取出一个元素。
  - 当队列为空时，读取操作会一直阻塞，直到队列中写入了新元素。
如果block=False，则不阻塞，直接抛出queue.Empty异常。
如果输入了timeout参数，则最多阻塞timeout秒，然后抛出异常。
  - 例：
>>> q.get()
0
>>> q.get(block=False)
'Hello'
>>> q.get(timeout=1)
[1, 2, 3]
## class LifoQueue(maxsize=0)
- 功能：创建一个后进先出队列（LIFO）。
- LifoQueue继承自Queue类，因此可使用同样的方法进行操作。
## class PriorityQueue(maxsize: int)
- 功能：创建一个优先级队列（Priority）。
  - 基于heapq模块的heappush()和heappop()实现，只不过加上了线程锁。
- PriorityQueue也继承自Queue类，因此可使用同样的方法进行操作。
  - 不同之处在于，写入的元素需要实现__lt__()方法，从而可以被sorted()排序。
- 例：
class Item:
    def __init__(self, priority, data):
        self.priority = priority
        self.data = data

    def __lt__(self, other):
        return self.priority < other.priority

>>> from queue import PriorityQueue
>>> q = PriorityQueue()
>>> q.put(Item(1, "one"))
>>> q.put(Item(3, "three"))
>>> q.put(Item(2, "two"))
>>> q.get().data
'one'
>>> q.get().data
'two'
>>> q.get().data
'three'
##
##
##

♢ multiprocessing
## multiprocessing：Python的标准库，用于创建多进程。
- class Process(group=None, target=None, name=None, args:Iterable, kwargs:Mapping[Any, Any], daemon:bool)
  - 功能：定义一个进程。
  - 例：
>>> import multiprocessing
>>> p = multiprocessing.Process(target=print, args=('hello',))
>>> p
<Process(Process-1, initial)>
>>> p.start()
>>> hello
  - 进程的方法。
>>> p.is_alive()
False
>>> p.join(1)
>>> p.terminate()        # 强制终止进程
>>> p.terminate()        # 重复终止不会报错
  - 进程的属性。
>>> p.daemon
False
>>> p.exitcode
0
>>> p.name
'Process-1'
>>> p.pid
2798
## 进程池：用于限制进程的最大运行数量。当进程池满了时，新增的进程会被挂起，直到进程池有空位时才开始运行。
- 例：
>>> pool = multiprocessing.Pool(2)          # 创建一个大小为2的进程池（默认等于CPU核数）
>>> for i in range(5):
...     pool.apply_async(fun1, (i,))        # 往进程池中添加进程
...
0
1
2
3
4
>>> pool.close()        # 关闭进程池，不能再加入进程了
>>> pool.join()        # 阻塞当前进程，等pool里的进程运行结束（需要先调用close()方法）
- def apply_async(func, args=(), kwds={}, callback=None, error_callback=None)
  - 功能：异步地创建进程。
  - 调用apply_async()函数会立即完成，不会等子进程运行结束，不会阻塞当前进程。
## 进程之间的通信方式（Inter-Process Communication，IPC）。
- multiprocessing模块提供了进程之间通信的队列类Queue，用法与类queue相似。
>>> q = multiprocessing.Queue()
>>> q.put("hello")
>>> q.get()
'hello'
##
##
##

♢ asyncio
## 协程：即协同程序，又称为异步函数。是指系统在执行某个函数时中断，转去运行另一个函数。
- 协程可以达到多线程并行工作的效果，但它依然是在一个线程内运行。
- 优点：用户可以控制多个协程切换执行的顺序，不用担心线程安全，而且比切换线程的开销小很多。
- 协程常用于实现异步IO。



## Python中可以用关键字async创建协程，用关键字await实现异步工作。
- Python的协程是通过生成器实现的。
- await只能在async函数中使用。
  - await只能调用实现了__await__()方法的对象。
## asyncio：Python的标准库，提供了异步IO的方法。
>>> import asyncio
>>> async def fun1(n):
...     for i in range(n):
...         await asyncio.sleep(1)        # 表示这里要等待1秒的IO，让解释器去执行event_loop中的其它协程
...         print(i)
...
>>> loop = asyncio.get_event_loop()    # 创建事件循环
>>> loop.run_until_complete(fun1(5))    # 开始事件循环
0
1
2
3
4
- async函数不能直接使用，直接调用会返回一个coroutine对象。
>>> fun1(5)
<coroutine object fun1 at 0x7f79d8348a40>
- 可以在event_loop中加入多个任务。
>>> tasks = [asyncio.ensure_future(fun1(i)) for i in [2, 3, 3]]
>>> loop.run_until_complete(asyncio.wait(tasks))
0
0
0
1
1
1
2
2
({<Task finished coro=<fun1() done, defined at <stdin>:1> result=None>, <Task finished coro=<fun1() done, defined at <stdin>:1> result=None>, <Task finished coro=<fun1() done, defined at <stdin>:1> result=None>}, set())
##
##
##




##
##
##


##
##


##
##
##

##
##
##

表格
♢ csv
## 将数据保存成表格时，可保存为CSV类型或Excel类型。
- CSV（Comma Separated Values，逗号分隔值）文件以纯文本的形式存储表格数据。
  - csv文件并没有明确的格式规定，不同来源的csv文件不一定能互通。
  - Python访问csv文件时可以像文本文件一样直接读写，例如f.write("path,content,total pings\n")，也可以导入内置的csv模块。
- xlsx文件是专有格式，只能用Excel软件打开，修改不自由。
  - 用Excel软件也可以直接打开 csv文件，还可以把 .xlsx文件保存成 csv文件。
  - 可使用第三方的xlrd和xlwt模块读写xlsx文件，其中xlrd用于读取（只读，不能修改），xlwt用于写入。
  - 还可使用读写功能都具备的openpyxl模块。
- 当csv文件的风格符合以下要求时，在Excel中显示的内容才会与xlsx文件一致。
  - 每行数据以换行符 '\r\n' 分隔，每行的各个字段以英文逗号 , 分隔。
  - 单个字段中如果出现了英文逗号、英文双引号，要用英文双引号把这个字符串包住，还要在其中的每个双引号前加上一个双引号进行转义。
  - 例如，用Excel编辑xlsx文件，写入如下三个单元格（每格之间用Tab分隔）：
1    A,B    A,"B"
用Excel将它保存为csv文件，用notepad++打开后的显示内容为：
1,"A,B","A,""B"""
用Python读取该csv文本，实际上每行末尾还有换行符（除非是最后一行）：
>>> with open("test.csv", newline="") as f:
...     f.read()
...
'1,"A,B","A,""B"""\r\n'
## csv：Python的标准库，用于读写csv文件。
- 写入的方法如下。
>>> import csv
>>> data = [["Hello world!"], [1, 2, 3, 4, 5], {'a': 1, 'b': 2, 'c': 3}]
>>> with open("test.csv", 'w', newline='') as f:# 设置newline=''，避免写入文件时自动转换换行符
...     csv_writer = csv.writer(f)                # 在文件流f上创建一个csv写入器
...     csv_writer.writerow("Hello")            # 写入一行，输入必须是可迭代对象
...     csv_writer.writerows(data)                # 写入多行，输入必须是可迭代对象
...
  - 检查保存结果：
>>> with open("test.csv") as f:
...     f.read()
...
'H,e,l,l,o\nHello world!\n1,2,3,4,5\na,b,c\n'
  - 用notepad++打开该文件，显示为：
H,e,l,l,o        # 直接拿一个字符串作为一行，转换成csv格式时就会被拆散成单个字符
Hello world!
1,2,3,4,5
a,b,c            # 这种情况下，字典只被保存了键名
- 读取的方法如下。
>>> with open("test.csv", 'r') as f:
...     csv_reader = csv.reader(f)        # 在一个可迭代对象（比如文件流、list）上创建csv阅读器
...     for line in csv_reader:        # 迭代csv_reader的内容
...             print(line)
...
['H', 'e', 'l', 'l', 'o']
['Hello world!']
['1', '2', '3', '4', '5']
['a', 'b', 'c']
  - 也可用csv.reader()直接解析csv格式的字符串：
>>> [i for i in csv.reader(["a,b,c\n"])]
[['a', 'b', 'c']]
## 用csv.writer()写入csv文件时，还可以选择csv风格，如下。
- csv.writer()的定义为csv.writer(fileobj [, dialect='excel']），其中dialect='excel'表示默认转换成excel的风格。
- 查看现有的所有dialect：
>>> csv.list_dialects()
['excel', 'excel-tab', 'unix']
  - 'excel'的定义为：
class excel(Dialect):
    delimiter = ','                # 一行中每个字段的分隔符
    quotechar = '"'                # 引用号，用于引用一个字段（避免被当作多个字段处理）
    doublequote = True            # 使用引用号时是否在字段的前后都加上引用号，还是只在前面加上引用号
    skipinitialspace = False        # 忽略分隔符delimiter之后的空格
    lineterminator = '\r\n'        # 分行符
    quoting = QUOTE_MINIMAL        # 控制何时使用引用号quotechar
# quoting 的取值：QUOTE_ALL表示引用所有字段，QUOTE_MINIMAL表示只引用包含特殊字符的字段
register_dialect("excel", excel)
  - 'excel-tab'与'excel'的区别在于：delimiter = '\t'
  - 'unix'与'excel'的区别在于：lineterminator = '\n'，quoting = QUOTE_ALL
- 自定义dialect的方法如下：
>>> class myDialect(csv.excel):
...     delimiter='|'
...
>>> csv.register_dialect("myDialect", myDialect)            # 登记自定义的dialect
>>> with open("test.csv", 'w', newline='') as f:
...     csv_writer = csv.writer(f, dialect='myDialect')        # 选择使用自定义的dialect进行写入
...     csv_writer.writerows(data)
...
>>> csv.unregister_dialect("myDialect")                    # 删除自定义的dialect
## csv模块还可专门读写字典格式的数据。
##
##
##

♢ openpyxl
## openpyxl：Python的第三方库，用于读写xlsx/xlsm文件。
- 安装：pip install openpyxl
- 一般操作流程为：先打开Workbook（即工作簿），再定位Worksheet（即工作表），然后操作Cell（即单元格）。
- 如果要在Excel中插入图片，需要用到pillow库。
## 创建一个Excel表格。
>>> from openpyxl import Workbook        # 从openpyxl模块导入Workbook类，用于创建和写入表格
>>> wb=Workbook()                        # 创建一个工作簿对象
>>> wb.sheetnames                        # 列出所有工作表的名字，新创建的工作簿只有一个默认工作表
['Sheet']
>>> ws=wb.create_sheet("sheet1", 0)    # 在第一个位置插入新工作表。如果不指定位置就默认在最后插入
>>> #ws.title="Sheet1"                # 设置工作表的名字
>>> wb.save("1.xlsx")                    # 把工作簿保存为一个xlsx文件
>>> wb.close()                        # 关闭对该文件的占用，但该文件的内容仍然保留在内存中可以读取
- 保存工作簿时，如果存在同名文件，会直接覆盖而不会提醒。如果其它程序正在使用该文件就无法保存。
## 打开一个现有的Excel表格。例如，在工作表"Sheet1"中有如下数据。

>>> from openpyxl import load_workbook        # 从openpyxl模块导入load_workbook类
>>> wb=load_workbook("1.xlsx")
>>> wb.sheetnames
['Sheet1', 'Sheet2', 'Sheet3']
>>> ws1=wb[wb.sheetnames[0]]                # 用工作表的名字作为工作簿的键值，可得到该工作表对象的引用
>>> ws1
<Worksheet "Sheet1">
>>> ws1.max_row                            # 获得工作表的最大行数
4
>>> ws1.max_column                        # 获得工作表的最大列数
3
- def load_workbook(filename, read_only=False, keep_vba=KEEP_VBA, data_only=False, guess_types=False, keep_links=True)用于打开一个由filename指定的工作簿。
  - keep_vba=KEEP_VBA    表示保留所有Visual Basic元素。
  - data_only=False        表示当单元格中存在公式时，获得原本的公式，不会只读取公式的计算结果。（每次用Excel打开工作簿时会自动计算公式）
  - guess_types=False    表示读取单元格时，不猜测其数据类型。
  - keep_links=True        表示保留与外部工作簿的链接。
## 读写工作表的值。
- 遍历工作表：
>>> for row in ws1:                        # 遍历工作表的每行，ws1相当于ws1.rows
...     print(row)
...
(<Cell 'Sheet1'.A1>, <Cell 'Sheet1'.B1>, <Cell 'Sheet1'.C1>)
(<Cell 'Sheet1'.A2>, <Cell 'Sheet1'.B2>, <Cell 'Sheet1'.C2>)
(<Cell 'Sheet1'.A3>, <Cell 'Sheet1'.B3>, <Cell 'Sheet1'.C3>)
(<Cell 'Sheet1'.A4>, <Cell 'Sheet1'.B4>, <Cell 'Sheet1'.C4>)
>>> for row in ws1:                        # 遍历每行
...     for cell in row:                    # 遍历每行的单元格
...         print(cell.value, end="\t")        # 取得每个单元格的值
...     print('\n')
...
1       2       3

4       5       6

None    None    None                        # 单元格为空时，返回的值为None

10      11      12

>>> for row in ws1.values:                # 使用工作表的values属性遍历所有单元格的值
...     print(row)
...
(1, 2, 3)
(4, 5, 6)
(None, None, None)
(10, 11, 12)
>>> for x in range(1,11):                    # 通过cell方法遍历一个10行10列的区域，range从1开始
...     for y in range(1,11):
...             ws1.cell(x, y).value
...
（显示略）
- 工作表对象支持索引，用行名、列名或单元格的名字作为工作表的键值，从而访问指定的单元格。
>>> ws1['A']                    # 获得A列所有不为空的单元格的引用
(<Cell 'Sheet1'.A1>, <Cell 'Sheet1'.A2>, <Cell 'Sheet1'.A3>, <Cell 'Sheet1'.A4>)
>>> ws1['1']                    # 获得第1行所有不为空的单元格的引用
(<Cell 'Sheet1'.A1>, <Cell 'Sheet1'.B1>, <Cell 'Sheet1'.C1>)
>>> ws1['A1']                # 获得A1单元格的引用
<Cell 'Sheet1'.A1>
>>> ws1['A1'].value            # 通过单元格的 value 属性获得其值
1
>>> ws1['A1']=2                # 给单元格赋值时不需要指定 value 属性
- 工作表对象支持切片，可以访问某个范围的单元格。
>>> ws1['A1':'B2']
((<Cell 'Sheet1'.A1>, <Cell 'Sheet1'.B1>), (<Cell 'Sheet1'.A2>, <Cell 'Sheet1'.B2>))
- 使用工作表对象的 cell() 方法可以操作一个指定单元格，其原型为def cell(row, column, value=None)。
>>> ws1.cell(2,3)
<Cell 'Sheet1'.C2>
>>> ws1.cell(2,3,12)            # 通过 cell() 方法给单元格赋值
<Cell 'Sheet1'.C2>
>>> ws1.cell(2,3).value        # 使用cell()方法时，即使没有赋值，也会在内存中创建一个单元格，其值为None
12
>>> ws1.cell(2,3).coordinate    # 获得该单元格的坐标
'C2'
## 使用只读或只写模式可以节省占用的内存。
- 用wb = Workbook(write_only=True)可以创建一个只写的工作簿，它的内存开销很小。
  - 它不会创建一个默认的工作表，必须要主动创建。
  - 它只能通过 append() 写入数据。例如：
>>> from openpyxl.worksheet.write_only import WriteOnlyCell
>>> from openpyxl.styles import Font
>>> cell = WriteOnlyCell(ws, value="hello world")
>>> cell.font = Font(name='Courier', size=36)
>>> ws.append([cell, 3.14, None])
  - 这个被创建的只写工作簿只能被保存一次，否则会报错。（可以再创建一个新的）
## 其它笔记。
- 用工作表的append()方法可以在工作表后附加一个可迭代的对象，比如tuple、list、dict、range、generator，也可附加某个或某些单元格。例如：
>>> column1=ws1['A']
>>> ws1.append(column1)
>>> for i in ws1.values:
...     print(i)
...
(1, 2, 3, None)
(4, 5, 12, None)
(None, None, None, None)
(10, 11, 12, None)
(1, 4, None, 10)        # 附加一列会变成一行加在工作表的末尾，这里多出来一列，空白的单元格也会被创建
- 给单元格赋值时，可以输入Excel的公式，例如：ws1["D4"] = "=SUM(A1:C4)"
- 设置行高和列宽的方法：
ws1.column_dimensions['A'].width = 90        # 只写的表格要在写入内容之前设置列宽
ws1.row_dimensions[1].height = 20
- openpyxls提供了多种设置单元格样式的类。例如，下方是使用Font类。
from openpyxl.styles import Font
font1 = Font(name='Calibri',        # 字体
            size=11,                # 字号
            bold=False,            # 加粗
            italic=False,            # 斜体
            underline='None',        # 下划线
            color='FF000000'        # 字体颜色
            ...)
ws1['A1'].Font=font1
ws1['A2'].Font=font1
- 调用以下函数可以转换列的数字序号和字母序号。
>>> from openpyxl.utils import get_column_letter, column_index_from_string
>>> get_column_letter(2)
'B'
>>> column_index_from_string('AA')
27




##
##
##


GUI软件
♢ tkinter
## tkinter（全名为Tk Interface）是Python的标准GUI包，可以兼容类Unix系统、Windows系统，显示经典桌面风格的GUI界面。
- tkinter通过回调函数来响应事件。
- 编写了基于tkinter的脚本之后，可用pyinstaller打包成可执行文件。
## 显示窗口。
- 创建一个窗口的代码如下：
import tkinter

w1 = tkinter.Tk()                      # 创建一个窗口类（在终端执行该命令时会立即显示窗口）
w1.title("mainWindow")                # 设置窗口的标题

w1.geometry("500x300+0+0")            # 设置窗口的尺寸和坐标，格式为widthxheight+x+y
w1.resizable(width=True, height=True)    # 设置宽度、高度是否可变
w1.minsize(500, 300)                    # 设置窗口的最小尺寸

w1.mainloop()                          # 进入主循环
  - 运行mainloop()时会阻塞当前线程，保持窗口的显示，检测到用户的操作就执行相应的动作。
  - mainloop()必须在创建它的线程中运行，在其它线程中调用会使程序崩溃。
  - 运行mainloop()时，tkinter会抓住一些不重要的异常，即使它们发生了也不会使GUI关闭，只会将报错信息显示在终端上。
- 窗口类有一个attributes()方法，功能很强大，如下：
w1.attributes("-topmost", True,     # 使该窗口置顶
                   # "-fullscreen", True,  # 使该窗口为全屏
                   # "-disabled", True,    # 使该窗口无法操作（用户对它的点击、输入统统无效）
                   # "-toolwindow", True,  # 使该窗口为toolwindow
                   # "-alpha", 0.9,        # 设置该窗口的透明度，0代表完全透明，1代表完全不透明
                   )
  - 设置窗口全屏时不会显示窗口的边框，因此不能点击标题栏上的关闭按钮来关闭它。
  - 设置窗口disable之后，按alt+F4也关闭不了它。
  - 尝试了同时设置窗口topmost、fullscreen、disable，结果发现关闭不了它，连任务管理器都不能调出来。最后，新建了一个win10桌面，打开DOS窗口，用taskkill命令才关闭了该窗口。
##
##
##

控件
## 显示控件（widget）。
- 在tkinter中，每个控件都有三种布局方法：pack()、grid()、place()。例如：
  - pack()方法。
L1.pack()                # 将该控件直接放到窗口上，让它自己调整位置
L1.pack(side="top")        # 设置该控件在窗口的位置，可选top、bottom、left、right
L1.pack(fill='y')        # 设置该控件在某一方向填满窗口，可选none、x、y、both
  - grid()方法。
略
  - place()方法。
L1.place(width=10, height=20, x=10, y=20)        # 设置该控件在父容器中的宽度、高度、坐标
L1.place(relwidth=0.5, relheight=0.5, relx=0.2, rely=0.2)    # 设置相对宽度、高度、坐标
  - 可随时调用三种方法来修改控件的位置，但是调用另一种布局方法时可能会毁掉之前的设置。
  - 每个控件在创建时要指定父容器（master），创建后要调用一个布局方法放到窗口中才能显示。例如：
tkinter.Label(w1, text="one", bg="pink").pack()    # 可以在创建该控件的同时打包
- 窗口、控件都可用destroy()方法销毁，这会同时销毁掉以它为父容器的其它控件。例如：
w1.destroy()
## tkinter提供了多种控件，常用的如下。
- Label：标签。可显示文本或图片。
L1 = tkinter.Label(master=w1, text="label1", fg="#FFF",
                     bg="#000", bd=10, font=("Arial", 12), width=10, height=5)
L1.pack()
L1["text"] = "Hello"    # 修改label的显示内容
  - 输入的参数中，text是要显示的文本（默认居中对齐），fg是前景色（即文本的颜色），bg是后景色（用三个十六进制数或已有的颜色名设定一种颜色，不设置的话就没有颜色，是透明的），bd是边框的宽度。
  - tkinter只支持PNG、GIF、PGM、PPM格式的图片，用以下函数导入：
img = tkinter.PhotoImage(file=r"C:\Users\Will\Desktop\1.png", width=200, height=100)
tkinter.Label(w1, image=img).pack(side="left")

- Frame：框架。用于包装一堆控件，作为它们的master。
F1 = tkinter.Frame(w1)
F2 = tkinter.Frame(F1)
tkinter.Label(F2, text="one").pack()
tkinter.Label(F2, text="two").pack()
F2.pack()
F1.pack()
- Button：按钮。
B1 = tkinter.Button(master=w1, text="close", command=B1.destroy)
B1.pack()
B1.flash()        # 让按钮在未激活与激活的外观之间闪烁几次
  - button控件可以将一个函数名赋值给command，当button被触发（即鼠标左键按下再松开）时就会执行该函数。
  - 可以用lambda函数作为command参数，如下：
B1 = tkinter.Button(w1, text="close", command=lambda: print("closing..."))
- Checkbutton：复选按钮。
Check1_var = tkinter.IntVar()        # 创建一个可及时刷新的变量，用于保存复选按钮的状态（1或0）
Check1 = tkinter.Checkbutton(w1, text = "run", variable = Check1_var)
Check1.pack()

Check1.select()        # 设置为选中状态
Check1.deselect()    # 设置为不选中状态
Check1.toggle()        # 在选中与不选中状态之间切换
Check1.invoke()        # 调用此方法相当于模拟用户点击一次复选按钮

Check1_var.get()        # 通过变量Check1_var获得复选按钮的状态
- Entry：输入框。只能让用户输入一行文本。
E1_var = tkinter.Variable()        # 创建一个可及时刷新的变量，用于保存输入框的文本内容
E1 = tkinter.Entry(w1, textvariable=E1_var)
E1.pack()

def get_entry():
    line=E1_var.get()+'\n'        # 获取输入框的文本内容
    T1.insert("end",line)

B1 = tkinter.Button(w1, text="Entry", command=get_entry)
B1.pack()
- Text：文本框。可以让用户输入多行文本，可以插入文本、图片、按钮，甚至当做网页浏览器使用。
T1=tkinter.Text(w1)
T1.pack()
T1.insert("1.0", "Hello\n")    # 在指定位置插入一个字符串，这个位置可以是第几行或已命名的特殊位置
T1.delete("1.2","end")        # 删除从第一行第2个字符到文本末尾之间的内容

T1.config(state="disabled")    # 使文本框不可编辑（用户和程序都不可以对它编辑）
T1.config(state="normal")        # 使文本框可编辑

B1 = tkinter.Button(w1, text="UP")
T1.window_create("end", window=B1)        # 插入按钮

img = tkinter.PhotoImage(file=r"C:\Users\Will\Desktop\scene.png")
T1.image_create("end", image=img)        # 插入图片

## messagebox：消息框，不需要设定master，可以直接显示，但是同时只能显示一个消息框，关闭之后才会显示下一个。
from tkinter import messagebox        # 从tkinter包中导入messagebox模块

# 显示一个信息框，只有一个“确定”按钮
messagebox.showinfo(title="OK", message="operation completed!")
messagebox.showwarning("warning")
messagebox.showerror("error")

# 显示一个询问框，有“确定”、“取消”两个按钮，被用户点击后分别返回True、False
if messagebox.askokcancel("ask", "即将开始更新，确定or取消"):
    messagebox.showerror("更新失败！")

# 显示一个询问框，有“是”、“否”、“取消”三个按钮，被用户点击后分别返回True、False、None
messagebox.askyesnocancel("ask","是or否or取消")

# 显示一个询问框，有“是”、“否”两个按钮
messagebox.askyesno("ask","是or否")
##
##
##

绑定事件
## 每个控件都可以用方法bind()在某个事件上绑定一个函数，一旦该事件发生就调用该函数，并将一个event对象传给函数。例如：
# 在L1的<ButtonPress-1>事件上绑定一个函数print()
L1.bind("<ButtonPress-1>", print)

# 在L1的<Enter>事件上绑定一个用lambda定义的简单命令
L1.bind("<Enter>", lambda event: print(L1["text"]))

- event对象描述了一个事件的多种信息，使用时自行提取event的属性即可。例如：
E1 = tkinter.Entry(w1, text='')
E1.pack()

def check_status(event):
    print(event)
    print(event.keysym)

E1.bind("<Key>", check_status)

# 运行该程序，按下Esc键，终端的显示如下：
<KeyPress event state=Mod1 keysym=Escape keycode=27 char='\x1b' x=289 y=53>
Escape

- 常用的event如下：
<ButtonPress-1>        鼠标左键按下
<ButtonRelease-1>    鼠标左键释放
<Double-Button-1>    鼠标左键双击
# 把上面三个事件名中的1改成2、3，就变成了鼠标滚轮、鼠标右键

<Enter>                鼠标移入该控件
<Leave>                鼠标离开该控件
<Motion>                鼠标在该控件上方移动
<B1-Motion>            在该控件上方按住鼠标左键的前提下，移动鼠标
<FocusIn>            该控件得到焦点（比如用户按Tab切换到它）
<FocusOut>            该控件失去焦点

<Key>                按住任意按键（注意是“按住”，如果用户一直按着，就会反复触发）
# 可以按下任意按键，用.bind("<Key>", print)查看该event的内容，其中就包括键名和键值
# 如果按下字母按键时被中文输入法挡住，程序可能会读取到异常的键值，导致程序出错
<Key-Return>            按住回车键
<Key-y>                输入小写的y
<Key-Y>                输入大写的Y（比如按Shift+Y输入，后切换大小写）
<Shift-Y>            在按住Shift的前提下，按住Y

<Configure>            窗口的大小改变

  - 可以自定义event，需要在前后各加两个尖括号，例如：
E1.bind("<<myEvent>>", print)
- 每个控件都可以用event_generate()方法主动生成一个事件，例如：
E1.bind("<Key-Return>", print)
E1.event_generate("<Key-Return>", when="tail")        # when="tail"是为了让该事件按顺序排队
  - 如果事件是<Key>类型，当焦点不在该控件上时，生成一个事件该控件也不会有反应。
  - 可以使用方法after(self, ms, func=None, *args)让tkinter在指定毫秒后执行某函数（这是tkinter内置的方法，如果使用time.sleep实现该功能就会阻塞线程）。
- bind()方法不输入参数则返回绑定的事件元组，可以用unbind()解绑一个事件。例如：
>>> E1.bind("<<myEvent>>", print)
'15615600print'
>>> print(E1.bind())
('<<myEvent>>',)
>>> E1.unbind("<<myEvent>>")
>>> print(E1.bind())
()
  - 对窗口进行绑定，例如w1.bind()，会绑定其中的所有子控件。
##
##
##

♢ PyQt5
## PyQt5：Python的第三方库，使得Python可以调用Qt5的大部分API。
- 安装：pip install PyQt5==5.10 PyQt5-sip==12.7.0
  - PyQt5-sip库用于让PyQt调用Qt的C++ API。
- 例：
from PyQt5.QtWidgets import QApplication, QWidget
import sys

app = QApplication(sys.argv)    # 每个Qt程序在启动时首先要创建一个QApplication对象，可以输入参数
w = QWidget()                # 创建主窗口
w.show()                        # 显示窗口

sys.exit(app.exec())            # 进入app的主循环，一旦app结束就终止程序

- Qt是一个GUI软件开发框架，基于C++，兼容Windows、Linux、MacOS、iOS、Android。
  - Qt5重构了底层模块，不兼容Qt4。
- 控件：指UI上显示的各种对象，比如窗口、按钮。
  - 通常先创建一个顶级窗口，再以它为父控件，创建其它控件。
  - 当父控件被销毁时，它的所有子控件都会被自动销毁。
  - 多个控件可以叠加显示在同一位置，后显示的控件会显示在上层。
##
##
##
##
##

Qtcore模块
##
##
##
## QTimer类：定时器。
- QTimer(parent: QObject = None)
- 例：
>>> timer = QTimer(w)                            # 创建一个定时器
>>> timer.timeout.connect(lambda:print(1))        # 绑定timeout信号
<PyQt5.QtCore.QMetaObject.Connection object at 0x000001EA668E9668>
>>> timer.setInterval(1000)                    # 设置触发timeout信号的间隔时间（单位为毫秒）
>>> timer.start()                                # 启动定时器（定时器会一直运行，循环触发timeout信号）
1                                            # 可以用timer.start(1000)，在启动时设置间隔时间
1
1
>>> timer.stop()                                # 停止定时器）
>>> timer.start()                                # 可以再次启动
1
1
1
- 下例是设置定时任务，定时器触发一次timeout信号之后就自动停止。
>>> QTimer.singleShot(1000, lambda:print(1))
1
##
##
## QThread类：多线程。
- 用法：自定义一个类，继承QThread类，并重载run()方法。
- 与Python自带的Threading模块相比，QThread创建的线程可以方便地使用信号进行通信。但依然受到GIL的限制。
##
##
##

处理事件
## 为了让Qt程序处理用户触发的事件，可以设置信号与槽函数，也可以重载控件的某种事件的处理函数。
## 信号与槽函数：将控件的某个信号绑定到一个槽函数。
- 例：
w = QWidget()
b = QPushButton("Close", w)
b.clicked.connect(w.close)        # 将一个信号对象与一个槽函数绑定
b.clicked.disconnect(w.close)        # 解绑（如果不存在该绑定关系则报错）

  - 当用户单击按钮时，按钮控件会发送click信号给所有与之绑定的槽函数，从而对该事件做出响应。
  - 一个信号对象可以绑定多个槽函数。
  - 可以将一个信号对象与另一个信号对象绑定，即前一个信号发生时会触发后一个信号。
b2 = QPushButton("Button2", w)
b2.clicked.connect(b.clicked)
- 例：
from PyQt5.QtWidgets import QApplication, QWidget
from PyQt5.QtCore import pyqtSignal

class MyWindow(QWidget):
    _signal = pyqtSignal(str)        # 自定义一个信号，它的形参列表要与其槽函数一致

    def __init__(self):
        super().__init__()
        self._signal.connect(self._slot)
        self._signal.emit("testing...")    # 可以用emit()方法主动发送某种信号

    def _slot(self, string):
        print(string)
        print(self.sender())        # 在槽函数中，可以用self.sender()方法返回信号的发送者的引用

## 常见的信号对象。
- clicked
-
-
-
-
-
## 重载控件的某种事件的处理函数。
- 例：
class Example(QWidget):
    def __init__(self):
        super().__init__()
    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Escape:        # 如果用户按下Esc键，则关闭窗口
            self.close()
-
## 常见的事件处理函数。
- def keyPressEvent(self, event):
    print(event.key())        # 获取用户按下的按键键值，比如按键A的键值是65（不受大小写的影响）
- def mouseMoveEvent(self, event):
    print(event.pos())        # 获取鼠标在窗口内的相对坐标
    print(event.globalPos())    # 获取鼠标在窗口内的全局坐标
  - 默认当用户按住鼠标并移动时才会触发mouseMoveEvent事件。如果设置self.setMouseTracking(True)，则只要用户在窗口范围内移动鼠标，就会触发mouseMoveEvent事件。
-
##
##


QTime类
## QTime类。
- 例：
>>> time = QTime.currentTime()        # 获取当前时间
>>> time
PyQt5.QtCore.QTime(22, 8, 3, 113)        # 一个QTime对象包含时、分、秒、毫秒四项参数
>>> time.hour()
22
>>> time.minute()
8
>>> time.second()
3
>>> time.msec()
113
>>> time.toPyTime()                    # 转换成datetime对象
datetime.time(22, 8, 3, 113000)
>>> time.toString()                    # 转换成字符串
'22:08:03'
## QDate类。
- 例：
>>> date = QDate.currentDate()
>>> date.year()
2019
>>> date.month()
10
>>> date.day()
9
>>> date.dayOfWeek()                    # 获取周几
3
>>> date.toPyDate()
datetime.date(2019, 10, 9)
## QDateTime类。
- 例：
>>> datetime = QDateTime.currentDateTime()
>>> datetime
PyQt5.QtCore.QDateTime(2019, 10, 9, 22, 19, 14, 330)
>>> datetime.toTime_t()            # 转换成时间戳
1570630754
>>> datetime.toPyDateTime()        # 转换成datetime对象
datetime.datetime(2019, 10, 9, 22, 19, 14, 330000)
- PyQt获取的时间默认为本地时间。
>>> datetime_UTC = QDateTime.currentDateTimeUtc()        # 获取UTC时区的时间
>>> datetime.timeZone().id()                            # 查看时区
PyQt5.QtCore.QByteArray(b'Asia/Shanghai')
>>> datetime.toUTC()                                    # 转换成UTC时间
PyQt5.QtCore.QDateTime(2019, 10, 9, 14, 19, 14, 330, PyQt5.QtCore.Qt.TimeSpec(1))
>>> datetime_UTC.toLocalTime()                        # 转换成本地时间
PyQt5.QtCore.QDateTime(2019, 10, 9, 22, 19, 14, 330)
>>> datetime_UTC.toLocalTime().toLocalTime()            # 重复转换也不会出错，该操作有幂等性
PyQt5.QtCore.QDateTime(2019, 10, 9, 22, 19, 14, 330)
##
##
##

QtWidgets模块
QApplication类
## QApplication类：用于创建Qt应用（它采用单例模式）。需要导入：from PyQt5.QtWidgets import QApplication
- app = QApplication.instance()
  - 功能：返回Qt应用的引用，总是返回一个单例对象。
- app.closeAllWindows() -> None
  - 功能：关闭所有窗口。
- app.quit() -> None
  - 功能：终止Qt应用。
-
  - 功能：
-
  - 功能：
-
  - 功能：
-
  - 功能：

##
##
##
##
##

QWidget类
## QWidget类：用于创建普通窗口。需要导入：from PyQt5.QtWidgets import QWidget
- QWidget是所有窗口的基类，是QDialog、QMainWindow、QFrame的父类。
- w = QWidget(parent: QWidget = None)
  - 功能：创建一个窗口。
  - 如果它没有父控件，它就会成为唯一的顶级窗口。
- w.show() -> None
  - 功能：显示控件。
  - 父控件在第一次显示时会初始化布局，将它的各个子控件也显示出来。如果在父控件初始化之后才加入子控件，则需要主动调用子控件的show()方法。
- w.close() -> bool
  - 功能：关闭控件的显示（但并没有销毁）。
  - 如果成功关闭显示，或者该控件本来就没有显示，则返回True。
-
-
## 窗口的特有方法。
- w.setWindowTitle(str) -> None
  - 功能：设置窗口的标题。
- w.setWindowIcon(QIcon) -> None
  - 功能：设置窗口的图标。
  - 例：
from PyQt5.QtGui import QIcon
w.setWindowIcon(QIcon(r"C:\Users\Leo\Pictures\1.jpg"))
- w.isMaximized() -> bool
  - 功能：判断窗口是否被最大化了。
  - 窗口最大化时不一定是全屏，比如限制了窗口最大尺寸时，不能填满屏幕。
- w.isMaximized() -> bool
  - 功能：判断窗口是否被最小化了。
## 控件的通用方法。
- w.setFocus() -> None
  - 功能：使控件得到焦点。
- w.setEnabled(bool) -> None
  - 功能：设置控件是否可以被用户操作，这会影响到它的所有子控件。
- w.isActiveWindow() -> bool
  - 功能：判断控件是否获得了屏幕焦点。
- w.isVisible() -> bool
  - 功能：判断控件现在是被show()显示了，还是被close()关闭显示了。
- w.setToolTip(str) -> None
  - 功能：设置提示语。当鼠标悬停在该控件上方时就会立即显示。
  - 例：
w.setToolTip("This is a tip.\n")                            # 支持转义字符
w.setToolTip("这是一个提示。")                                # 支持Unicode字符
w.setToolTip('This is a <font color="red">tip</font>.')        # 支持HTML语法
  - 可定义ToolTip的字体：
from PyQt5.QtWidgets import QToolTip
from PyQt5.QtGui import QFont
QToolTip.setFont(QFont("微软雅黑", 12))
w.setToolTip('This is a <font color="red">tip</font>.')
-
  - 功能：
-
  - 功能：
-
  - 功能：
-
##
##
##
##

QMainWindow类
## QMainWindow类：用于创建包含菜单栏、工具栏、状态栏的经典风格的窗口。
- w = QMainWindow(parent: QWidget = None)
  - 功能：创建一个主窗口。
## 菜单栏。
- menubar = w.menuBar()
  - 功能：第一次调用将创建菜单栏，重复调用将返回菜单栏这个单例对象的引用。
- menubar.addMenu(str) -> QMenu                # 输入名字
menubar.addMenu(QIcon, str) -> QMenu        # 输入图标和名字
menubar.addMenu(QMenu) -> QMenu            # 输入一个QMenu对象
  - 功能：加入一个菜单。
  - 可以在一个菜单中嵌套另一个菜单，称为子菜单。例：
file_menu = menubar.addMenu("File")
sub_menu = file_menu.addMenu("Recent Files...")
- QMenu.addAction(str) -> QAction
QMenu.addAction(QIcon, str) -> QAction
QMenu.addAction(QAction) -> QAction
  - 功能：在某个菜单下加入一个动作（按钮）。
  - 下例是定义一个普通的动作：
from PyQt5.QtWidgets import QAction

# 定义动作
exit_action = QAction(QIcon(r'C:\Users\Leo\Pictures\1.jpg'), "Exit", w)
exit_action.setShortcut("Ctrl+Q")                        # 设置快捷键
exit_action.setStatusTip("Exit the application.")        # 设置显示在状态栏的提示
exit_action.triggered.connect(app.quit)                # 绑定到一个槽函数

menubar = w.menuBar()
file_menu = menubar.addMenu("File")        # 创建菜单
file_menu.addAction(exit_action)            # 添加动作
  - 下例是定义一个勾选的动作：
def debug_mode(state):        # 触发该槽函数时，会传入一个参数，表示当前按钮是否被勾选
    if state:
        w.statusBar().showMessage("Debug mode is enabled")
    else:
        w.statusBar().showMessage("Debug mode is disabled")

debug_action = QAction("Debug mode", w, checkable=True)
debug_action.setChecked(True)        # 设置按钮初始的状态是否被勾选
debug_action.triggered.connect(debug_mode)

menubar = w.menuBar()
fileMenu = menubar.addMenu("fileMenu")
fileMenu.addAction(debug_action)
- QAction(parent: QWidget = None) -> QAction
QAction(str, parent: QWidget = None) -> QAction
QAction(QIcon, str, parent: QWidget = None) -> QAction
  - 功能：定义一个动作。
## 上下文菜单：即右键菜单。
- 定义上下文菜单需要重载contextMenuEvent()方法。如下：
class MyWindow(QMainWindow):
    def contextMenuEvent(self, event):
        contextMenu = QMenu(self)
        open_action = contextMenu.addAction("open")
        quit_action = contextMenu.addAction("quit")

## 工具栏：显示一些常用的动作，便于使用。
- 例：
w.exit_tool = w.addToolBar("Exit")
w.exit_tool.addAction(exit_action)
## 状态栏。
- statuebar = w.statusBar()
  - 功能：第一次调用将创建状态栏，重复调用将返回状态栏这个单例对象的引用。
- statuebar.showMessage(str, msecs: int = 0)
  - 功能：在状态栏中显示一行字符串。默认永久显示，输入msecs参数可设置最大显示时长。
##
##
##

坐标、尺寸
## 坐标。
- w.pos() -> QPoint
  - 功能：查看控件的坐标，返回一个QPoint对象。
  - 例：
>>> w.pos()
PyQt5.QtCore.QPoint(639, 237)
>>> pos = w.pos()
>>> pos.x()
639
>>> pos.y()
237
  - 顶级窗口的坐标代表其左上角相对于屏幕左上角的距离，子控件的坐标代表其左上角相对于父控件左上角的距离。
  - 顶级窗口的坐标可以移动到屏幕之外，子控件的坐标可以移动到父控件的显示区域之外。
>>> w.mapToGlobal(w.pos())        # 从局部坐标转换成全局坐标（即加上当前控件的坐标）
PyQt5.QtCore.QPoint(1279, 512)
>>> w.mapFromGlobal(w.pos())        # 从全局坐标转换成局部坐标（即减去当前控件的坐标）
PyQt5.QtCore.QPoint(-1, -38)
- w.move(int, int) -> None            # 输入横坐标x、纵坐标y（单位为pixel）
w.move(QPoint) -> None            # 输入一个QPoint对象
  - 功能：移动控件到指定坐标。
## 尺寸。
- w.size() -> QSize
  - 功能：查看控件的尺寸，返回一个QSize对象。
  - 例：
>>> w.size()
PyQt5.QtCore.QSize(640, 480)
>>> size = w.size()
>>> size.width()
640
>>> size.height()
480
- w.resize(int, int) -> None        # 输入宽度width、高度height（单位为pixel）
w.resize(QSize) -> None            # 输入一个QSize对象
  - 功能：调整控件的尺寸。
  - 控件的尺寸不能设置为0或负数，否则控件会被关闭显示。
  - 控件的尺寸不能超过屏幕的可用显示范围，即使用resize()设置了更大的尺寸也不会生效，即使用户用鼠标拖动窗口边框也不能变得更大。
- w.adjustSize() -> None
  - 功能：根据控件需要显示的内容，自动调整尺寸。
- 设置最大尺寸。
w.setMaximumHeight(int) -> None
w.setMaximumWidth(int) -> None
w.setMaximumSize(int, int) -> None
w.setMaximumSize(QSize) -> None
- 设置最小尺寸。
w.setMinimumHeight(int) -> None
w.setMinimumWidth(int) -> None
w.setMinimumSize(int, int) -> None
w.setMinimumSize(QSize) -> None
- 设置固定尺寸。
w.setFixedHeight(int) -> None
w.setFixedWidth(int) -> None
w.setFixedSize(int, int) -> None
w.setFixedSize(QSize) -> None
  - 可以在程序运行时随时改变窗口的尺寸，但是如果设置了固定尺寸，用户就不能再拖动窗口的边界了，只能由程序改变。
## 几何属性。
- w.geometry() -> QRect
  - 功能：查看控件的几何属性，返回一个QRect对象。
  - 例：
>>> w.geometry()
PyQt5.QtCore.QRect(640, 275, 640, 480)
>>> geometry = w.geometry()
>>> geometry.x()            # QRect对象兼容QPoint对象、QSize对象的属性和方法
640
>>> geometry.y()
275
>>> geometry.width()
640
>>> geometry.height()
480
- w.setGeometry(int, int, int, int) -> None        # 输入x、y、width、height
w.setGeometry(QRect) -> None                    # 输入一个QRect对象
  - 功能：设置控件的几何属性。
  - QRect对象提供了一些移动控件的方法，但不会影响到原控件。可以先修改QRect对象，再把它应用到原控件。
>>> geometry = w.geometry()
>>> geometry.right()                # 同理还有left()、top()、bottom()
1279
>>> geometry.moveRight(1000)        # 同理还有moveLeft()、moveTop()、moveBottom()
>>> geometry.topLeft()            # 同理还有topRight()、bottomLeft()、bottomRight()、center()
PyQt5.QtCore.QPoint(361, 275)        # 返回一个QPoint对象
>>> geometry.moveTopLeft(geometry.center())
# 同理还有moveTopRight()、moveBottomLeft()、moveBottomRight()、moveCenter()
>>> w.setGeometry(geometry)        # 把QRect对象应用到原控件
## 获取桌面的尺寸信息。
- 获取桌面窗口的实例：
>>> from PyQt5.QtWidgets import QDesktopWidget
>>> desktop = QDesktopWidget()
- 它兼容QWidget的部分方法，可像QWidget一样查看尺寸：
>>> desktop.size()
PyQt5.QtCore.QSize(1920, 1080)
- 它的特有方法：
>>> desktop.availableGeometry()                # 查看桌面的可用显示范围（略小于屏幕尺寸，因为要减去边框）
PyQt5.QtCore.QRect(0, 0, 1920, 1030)
##
##

布局
## 设置控件的位置时，使用布局方法比使用绝对坐标更好，因为使用布局方法可以适应窗口的伸缩变化，而且在不同平台上的显示效果都一致。
- 不可以直接将多个水平布局、垂直布局组合在一起，但可以将一个布局嵌套成另一个布局中的元素。
- 给一个控件设置了布局之后，只能在该布局的基础上进行修改，不能换成另一个布局。
## QHBoxLayout类：用于实现水平布局（Horizontal Layout），使多个控件在水平方向均匀排列。
## QVBoxLayout类：用于实现垂直布局（Vertical Layout），使多个控件在垂直方向均匀排列。
- 例：
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QHBoxLayout, QVBoxLayout
import sys

app = QApplication(sys.argv)
w = QWidget()
w.show()
button1 = QPushButton("One")
button2 = QPushButton("Two")

hbox = QHBoxLayout()            # 创建一个水平布局（即一行空间）
hbox.addStretch(1)            # 添加一个拉伸因子（拉伸因子会尽可能地挤占空白空间）
hbox.addWidget(button1)        # 添加控件（这些空间会按添加的先后顺序排列）
hbox.addWidget(button2)

vbox = QVBoxLayout()            # 创建一个垂直布局（即一列空间）
w.setLayout(vbox)            # 采用该布局（之后再修改该布局时，会立即生效）
vbox.addStretch(1)
vbox.addLayout(hbox)            # 添加一个布局作为元素
  - 拉伸因子的值越大，挤占空间的优先级越高。
## QGridLayout类：用于实现网格布局，将空间分成多行多列，将控件放在某个格子内，或者占据多个格子。
- 例：
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QGridLayout
import sys

app = QApplication(sys.argv)
w = QWidget()
w.show()

grid = QGridLayout()
w.setLayout(grid)
grid.setSpacing(10)        # 设置每个格子的间距

button1 = QPushButton("Send")
grid.addWidget(button1)                # 添加一个控件，默认使用垂直布局
grid.addWidget(button1, 0, 0)            # 添加一个控件，放在第0行、第0列
textEdit1 = QTextEdit()
grid.addWidget(textEdit1, 1, 0, 2, 2)    # 添加一个控件，占据从第1行、第0列到第2行、第2列之间的格子

- 下例是添加一些按矩阵排列的控件：
positions = [(i, j) for i in range(5) for j in range(4)]
names = ['Cls', 'Bck', '', 'Close',
         '7', '8', '9', '/',
         '4', '5', '6', '*',
         '1', '2', '3', '-',
         '0', '.', '=', '+']
for position, name in zip(positions, names):
    if name == '':
        continue
    button = QPushButton(name)
    grid.addWidget(button, *position)
##
##
##

控件
按钮
## QPushButton类：普通按钮。
- QPushButton(parent: QWidget = None)                # 只输入父控件，则显示一个空白按钮
QPushButton(str, parent: QWidget = None)            # 输入显示内容、父控件
QPushButton(QIcon, str, parent: QWidget = None)        # 输入图标、显示内容、父控件
- 例：
>>> button = QPushButton("Quit", w)
>>> button.clicked.connect(QApplication.instance().quit)    # 将按钮按下的信号绑定到一个槽函数
>>> button.text()                                # 返回按钮的名字
'Quit'
- 可以让普通按钮保持在“按下”或“未按下”状态。
def changeState(pressed):
    if pressed:
        print("On")
    else:
        print("Off")

button.setCheckable(True)                        # 使普通按钮可以保持状态
button.clicked[bool].connect(changeState)        # 绑定信号
button.toggle()                                # 切换状态
## QToolButton类：点击时不会显示虚线边框。
## QCheckBox类：勾选按钮。有“选中”、“未选中”两种状态。
- QCheckBox(parent: QWidget = None)
QCheckBox(str, parent: QWidget = None)
- 例：
def changeState(self, state):
    if state == Qt.Checked:
        print("On")
    else:
        print("Off")

>>> checkBox = QCheckBox("On", w)
>>> checkBox.stateChanged.connect(changeState)        # 将状态改变的信号绑定到一个槽函数
>>> checkBox.isChecked()                            # 判断是否被选中了
True
>>> checkBox.setChecked(True)                        # 设置状态
>>> checkBox.toggle()                                # 切换状态
## QRadioButton类：单选按钮。
##
##
##
##
##
##
##
##
##
##
##
##
##

关于输入
## QLineEdit类：单行输入框，用于输入一行字符串。
- QLineEdit(parent: QWidget = None)
QLineEdit(str, parent: QWidget = None)        # str参数表示输入框的初始内容
- 例：
>>> lineEdit = QLineEdit(w)
>>> lineEdit.show()
>>> lineEdit.setText("hello")            # 设置输入框的内容
>>> lineEdit.text()                    # 获取输入框的内容
'hello'
>>> lineEdit.setMaxLength(10)            # 设置输入内容的最大长度
>>> lineEdit.setReadOnly(True)        # 使输入框变成只读
>>> lineEdit.setEchoMode(QLineEdit.Password)        # 使输入框的内容按密文显示
- 常用信号：
lineEdit.textChanged.connect(...)            # 当输入框的内容改变时（不管是被用户改变，还是被程序改变）
lineEdit.editingFinished.connect(...)        # 当用户输入结束时（比如按下回车、焦点从输入框移动到其它控件）
lineEdit.selectionChanged.connect(...)        # 当用户的选中范围改变时（没有选中范围时不会触发）
## QTextEdit类：多行输入框，用于输入多行字符串，可以插入富文本。
- QTextEdit(parent: QWidget = None)
QTextEdit(str, parent: QWidget = None)
- 当输入的字符串行数过多时，会自动显示一个垂直滚动条。
- 例：
>>> textEdit = QTextEdit(w)
>>> textEdit.show()
>>> textEdit.toPlainText("Hello")            # 设置输入框的纯文本内容
>>> textEdit.toPlainText()                # 获取输入框的纯文本内容（QTextEdit对象没有text()方法）
'Hello'
>>> textEdit.setHtml("<h1>标题一</h1>")    # 设置输入框的html内容
>>> textEdit.toHtml()                        # 获取输入框的html内容
'<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">\n<html><head><meta name="qrichtext" content="1" /><style type="text/css">\np,...
>>> textEdit.clear()                        # 清空输入框
- 关于插入文本：
>>> textEdit.append("Hello")                    # 在末尾附加内容（这会新起一行）
>>> from PyQt5.QtGui import QTextCursor
>>> textEdit.moveCursor(QTextCursor.Start)        # 将光标移动到最前面
>>> textEdit.moveCursor(QTextCursor.End)        # 将光标移动到最后面
>>> textEdit.insertPlainText("Hello")            # 在光标处插入纯文本
>>> textEdit.insertHtml("<h1>标题一</h1>")        # 在光标处插入html
- 下例是将stdout、stderr重定向到textEdit。
from PyQt5.QtWidgets import QApplication, QWidget
from PyQt5.QtCore import QObject, pyqtSignal
from PyQt5.QtGui import QTextCursor

class EmittingStream(QObject):
    output = pyqtSignal(str)      # 定义output信号，接收一个str参数
    def write(self, text):
        self.output.emit(str(text))
    def flush(self):
        pass

class MyWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.log_view = QTextEdit(self)

        # 重定向stdout、stderr，让它们触发output信号，并把信号绑定到logger槽函数
        sys.stdout = EmittingStream(output=self.logger)
        # sys.stderr = sys.stdout        # 重定向stderr的话，程序就不能捕捉异常，容易崩溃

    def logger(self, text):
        """ 接收log信号的槽函数，用于记录日志 """
        self.log_view.moveCursor(QTextCursor.End)
        self.log_view.insertPlainText(text)

# 尝试发送stdout、stderr
print("hello")
raise RuntimeError("testing...")

## QComboBox类：下拉列表。
- QComboBox(parent: QWidget = None)
- 例：
>>> combo = QComboBox(w)
>>> combo.show()
>>> combo.addItem("One")        # 添加一个选项（只是显示一个str）
>>> combo.addItem("Two")
>>> combo.currentText()        # 获取当前的选项
'One'
- 常用信号：
def onActivated(text):
    print(text)

combo.activated[str].connect(onActivated)
## QScrollBar类：滚动条，用于拖动显示区域。
## QSlider类：滑动条，用户可以通过拖动滑动条来调整某个数值。
- QSlider(parent: QWidget = None)
QSlider(Qt.Orientation, parent: QWidget = None)
  - Qt.Orientation有水平、竖直两种显示方向，默认是Qt.Vertical，可设置成Qt.Horizontal。
- 例：
>>> slider = QSlider(Qt.Horizontal, w)            # 创建一个水平显示的滑动条
>>> slider.show()
>>> slider.setValue(100)                        # 设置值（取值范围为0~99，超出范围则设置成最大/小值）
>>> slider.value()
99
- 常用信号：
def changeValue(value):
    print(value)
slider.valueChanged[int].connect(changeValue)    # 绑定取值改变的信号（取值范围为0~99）
## QCalendarWidget类：日历。用于让用户方便地选择一个日期。
- QCalendarWidget(parent: QWidget = None)
- 例：
def getDate(date):    # 传入的date参数是QDate对象
    print(date.toString())

calendar = QCalendarWidget(w)
calendar.show()
calendar.clicked[QDate].connect(getDate)
##
##
##
##
##
##
##
##
##

关于输出
## QLabel类：标签，用于显示一个只读的字符串。
- QLabel(parent: QWidget = None)
QLabel(str, parent: QWidget = None)
- 例：
>>> label = QLabel("hello", w)
>>> label.show()
## QProgressBar类：进度条。
- QProgressBar(parent: QWidget = None)
- 例：
>>> progressBar = QProgressBar(w)
>>> progressBar.show()
>>> progressBar.setValue(100)        # 设置进度值。取值范围为0~100
>>> progressBar.value()
100
>>> progressBar.setValue(99.99)    # 小数部分的值会被舍去
>>> progressBar.value()
99
##
##
##
##
##
##
##
##
##
##
##
##
##
##

关于布局
## QFrame类：框架，用于将多个控件组合在一起。
## QSplitter类：分割器。插入到控件之间，从而用户用户拖动控件的边界。
- QSplitter(parent: QWidget = None)
QSplitter(Qt.Orientation, parent: QWidget = None)
- 例：
from PyQt5.QtWidgets import QApplication, QWidget, QFrame, QHBoxLayout, QSplitter
from PyQt5.QtCore import Qt
import sys

app = QApplication(sys.argv)
w = QWidget()

frame1 = QFrame(w)
frame1.setFrameShape(QFrame.StyledPanel)    # 设置frame的主题，以支持QSplitter
frame2 = QFrame(w)
frame2.setFrameShape(QFrame.StyledPanel)
frame3 = QFrame(w)
frame3.setFrameShape(QFrame.StyledPanel)

splitter1 = QSplitter(Qt.Horizontal)        # 创建一个水平方向的分割器splitter1
splitter1.addWidget(frame1)                # 用splitter1分割topleft和topright
splitter1.addWidget(frame2)

splitter2 = QSplitter(Qt.Vertical)
splitter2.addWidget(splitter1)
splitter2.addWidget(frame3)

hbox.addWidget(splitter2)
##
##
## QTableView
## QListView
## QTreeView
## QListWidget
## QTableWidget
## QTabWidget
## QStackedWidget
## QDockWidget
##
##
##
##
##

对话框
## QDialog类：所有对话框窗口的基类。
## QInputDialog类：输入对话框。
- 例：
text, ret = QInputDialog.getText(w, "Input Dialog", "Please input your name:")
if ret:
    print("Your name is:" + text)
  - text存储用户输入的文本，ret是一个bool值，表示用户是否点击了Yes按钮。
## QFontDialog类：选择字体的对话框。
- 例：
font, ret = QFontDialog.getFont()
if ok:
    lable.setFont(font)
## QColorDialog类：选择颜色的对话框。
- 例：
color = QColorDialog.getColor()
if color.isValid():
    w.setStyleSheet("QWidget {{ background-color: {} }}".format(color.name()))
## QFileDialog类：选择文件的对话框。
- 选择一个文件：
filename, _filter = QFileDialog.getOpenFileName(w, "Open file", ".", "*.py")
                    # 输入参数：父控件、窗口名、打开的目录、筛选的文件名
                    # 返回的filename和_filter都是str型
if filename:
    with open(filename, "r") as f:
        textEdit.setText(f.read())
- 选择多个文件：
filenames, _filter = QFileDialog.getOpenFileNames(w, "Open files", ".", "*.py")
                    # 返回的filenames是一个字符串列表
- 选择保存文件的路径：
>>> QFileDialog.getSaveFileName(w, "Save to", ".", "*.py")
('D:/1/move_files/src/1.py', '*.py')
- 选择一个目录：
>>> QFileDialog.getExistingDirectory(w, "Open file", ".")
'D:/1'
## QMessageBox类：消息框，用于通知用户某个消息。
- 提问框：有Yes、No两个选项。
>>> reply = QMessageBox.question(w, "标题...", "内容...")
>>> reply == QMessageBox.Yes
True
>>> reply == QMessageBox.No        # 当用户点击No选项或关闭按钮时，返回值为QMessageBox.No
False
- 提示框：只有一个Ok选项。
>>> reply = QMessageBox.information(w, "标题...", "内容...")
>>> reply == QMessageBox.Ok        # 当用户点击Ok选项或关闭按钮时，返回值为QMessageBox.Ok
True
- 警告框：只有一个Ok选项。
>>> reply = QMessageBox.warning(w, "标题...", "内容...")
>>> reply == QMessageBox.Ok
True
- 错误框：只有一个Ok选项。
>>> reply = QMessageBox.critical(w, "标题...", "内容...")
>>> reply == QMessageBox.Ok
True
##
##
##
##
##
##
##

QtGui模块
## QFont类：用于选择字体。
- 例：
>>> from PyQt5.QtGui import QFont
>>> QFont("微软雅黑", 12)        # 输入字体名、字号
<PyQt5.QtGui.QFont object at 0x0000023BE20F9358>
## QColor类：用于选择颜色。
- QColor(int, int, int, alpha: int = 255)
  - 前三个参数代表RGB三个通道的值（取值为0~255），alpha参数表示不透明度。
- 例：
>>> from PyQt5.QtGui import QColor
>>> color = QColor(0, 0, 255)            # 选择颜色
>>> color.name()                        # 返回颜色的十六进制值
'#0000ff'
>>> color.isValid()                    # 判断是否为有效的颜色值
True
  - 可以单独访问red、green、blue、alpha通道。
>>> color.alpha()
255
>>> color.setAlpha(0)
## QIcon类：用于导入图片。
- 例：
>>> from PyQt5.QtGui import QIcon
>>> QIcon(r"C:\Users\Leo\Pictures\1.jpg")
<PyQt5.QtGui.QIcon object at 0x0000023BE1C45C18>
## QPixmap类：用于显示图片。
- 例：
>>> pic = QPixmap(r"C:\Users\Leo\Pictures\1.jpg")
>>> label = QLabel(w)
>>> label.setPixmap(pic)            # 用图片填充label
>>> label.show()
>>> w.adjustSize()
## QPainter类：用于绘画。
##
## stylesheet：样式表。
- 子控件会自动继承父控件的stylesheet，为了避免这种情况，应该注明stylesheet的作用对象，如下：
QMainWindow{                            # 作用于QMainWindow类对象
background-color: rgb(255, 255, 0);
color: rgb(255, 85, 0);
}
QMainWindow:mainwindow{                # 只作用于mainwindow对象
background-color: rgb(255, 255, 0);
color: rgb(255, 85, 0);
}
-
##
##

♢ pyqt5-tools
## pyqt5-tools：Python的第三方库，提供了Qt的一些工具。
- 安装：pip install PyQt5-tools==5.10.1.1.3
  - 这些工具安装在Python/Scripts目录下，并且注册在环境变量PATH中，可以输入工具名直接调用。
-
-
## designer：用于设计Qt的GUI界面，生成.ui文件。
- 用法：用designer.exe启动，或在命令行输入designer启动。
##
##
##
##
##
## pyuic5：用于将.ui文件转换成.py文件。
- 用法：
pyuic5 mainwindow.ui -o mainwindow_ui.py
- 可以将.ui文件转换成.py文件之后再导入，如下：
import sys
from PyQt5.QtWidgets import QApplication, QMainWindow
from mainwindow_ui import Ui_MainWindow

class MyWindow(QMainWindow, Ui_MainWindow):  # 多继承，QMainWindow是基类，Ui_MainWindow用于配置
    def __init__(self):
        super().__init__()
        self.setupUi(self)

app = QApplication(sys.argv)
w = MyWindow()
w.show()
sys.exit(app.exec())
- 也可以直接导入.ui文件（但这样不能打包到exe文件中），如下：
from PyQt5 import uic

class MyWindow(QMainWindow):                # 不继承
    def __init__(self):
        super().__init__()
        uic.loadUi("mainwindow.ui", self)    # 调用其setupUi()方法
## pyrcc5：用于将.qrc文件转换成.py文件，便于打包。
- 用法：
pyrcc5 resource.qrc -o resource.py
- 导入图片等资源文件的方法有两种：
  - 使用文件路径直接导入，但这样必须将资源文件与程序打包到同一个文件夹发布。
  - 把资源文件记录到.qrc文件中（使用designer的资源窗口），再转换成.py文件，然后在主脚本中导入。如下：
import resource
QIcon(r":resource/img/logo.ico")    # 使用冒号:加文件路径导入图片，该路径必须与.qrc文件中的一致
##
## 用pyinstaller打包PyQt程序。
1.    写好程序，能用Python解释器成功启动。
2.    将.qrc文件转换成.py文件，然后在主脚本中导入。
3.    到源代码目录下，执行：
pyinstaller mainwindow.py -w -i resource/img/logo.ico
  - 如果启动失败，就先不用-w选项，在终端启动，可以看到报错信息。
4.    将源代码目录下的.ui文件、resource目录都拷贝到dist目录下，因为程序打包时没有集成它们，还需要按相对路径导入。
##
##
##
##
##
##
##
##

designer
##
##
## 按F4进入信号-槽的设置模式
可以自定义signal或slot，等导入该ui文件时再定义相应的方法。

## 在designer中导入图片等资源时，要先点击Resource菜单，创建一个.qrc文件，用于记录导入的所有资源。
- 也可以直接导入文件路径。
##
## 自定义widget，做成插件后便可以显示在designer左侧的widget列表中，也可以通过“promoted widget”功能导入。
https://www.xdbcb8.com/archives/1675.html
https://ilmvfx.wordpress.com/2016/02/16/use-promoted-widgets-in-qt-designer/
##
##
##
##
##
##



##
##
##
:::