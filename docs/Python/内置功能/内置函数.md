# 内置函数

- Python 解释器每次启动时，会自动从内置模块 builtins 导入一些内置函数、内置异常。

## 关于输入输出

### print()

```py
print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False) -> None
```
- 功能：将 value 参数的值，输出到终端。
  - 如果输入了多个 value 参数，则在它们之间加上一个 sep 值，从而拼接成一个字符串。
  - 输出 value 之后，在末尾加上一个 end 值。
  - file  参数表示，将 value 输出到哪个文件对象。默认会输出到终端 sys.stdout ，俗称为"打印到终端"。
  - flush 参数默认为 False ，表示调用 print() 函数时，不会立即输出到 file ，而是等缓冲了一定体积的字符串之后才输出。
- 例：
  ```py
  >>> print('Hello', end='\n\n')
  Hello

  >>> print('Hello', 'World', '!')
  Hello World !
  ```
- 例：显示一个动态进度条
  ```py
  >>> for i in range(101):
  ...     print('\rProgress: {:12}{}%'.format((i // 10) * '▇', i), end='', flush=True)
  ...     time.sleep(0.1)
  ...
  Progress: ▇▇▇▇▇▇▇▇▇▇  100%
  ```
  这里配置了 `end=''` ，使得每次输出之后不换行，因此可以通过 `\r` 回到行首，重新输出这一行内容。

### input()

```py
input(prompt=None) -> str
```
- 功能：将 prompt 输出到 stdout ，作为提示语，供用户查看。然后从 stdin 读取一行字符串（由用户键盘输入，会忽略末尾的换行符），将它作为 input() 函数的返回值。
- 例：
  ```py
  >>> a = input('Please input a number: ')
  Please input a number: 1
  >>> a
  '1'         # input() 的返回值为 str 类型
  >>> int(a)
  1
  ```

## 关于执行代码

### exec()

```py
exec(src, globals=..., locals=...) -> None
```
- 功能：输入一段 Python 代码，让 Python 解释器执行。
  - 可选输入 globals 参数（取值为 dict 类型），决定全局作用域有哪些标识符。默认不输入 globals 参数，会继承当前的全局作用域。
  - 可选输入 locals 参数（取值为 dict 类型），决定局部作用域有哪些标识符。默认不输入 locals 参数，会继承当前的局部作用域。

- 例：
  ```py
  >>> exec('a=0')   # 执行 exec() 函数，创建一个变量 a
  >>> a
  0
  >>> exec('print(a)', {'a':1}) # 执行 exec() 函数的同时，指定变量 a 的取值
  1
  >>> a                         # 在 exec() 函数之外，变量 a 的取值不变
  0
  >>> exec('print(a)', globals(), locals()) # 执行 exec() 函数的同时，输入当前的所有标识符，默认就会这样做
  0
  ```

### eval()

```py
eval(src, globals=..., locals=...) -> object
```
- 功能：输入一个 Python 表达式，让 Python 解释器执行，然后返回表达式的值。
- 对比 exec() 与 eval() 函数：
  - exec() 用于执行一段 Python 代码，不考虑返回值。而 eval() 用于执行一个 Python 表达式，并得到其返回值。
    ```py
    >>> exec('1+2')
    >>> eval('1+2')
    3
    >>> eval('[print(i) for i in range(3)]')
    0                       # 这是 print() 打印的内容
    1
    2
    [None, None, None]      # 这是 eval() 的返回值
    ```
  - exec() 可以执行任意类型的 Python 代码，而 eval() 只能执行 Python 表达式。
    ```py
    >>> eval('print(1)')    # 可以调用函数
    1
    >>> eval('a=1')         # 不能赋值
    SyntaxError: invalid syntax
    >>> eval('import sys')  # 不能导入模块
    SyntaxError: invalid syntax
    ```
  - exec() 中能执行多行 Python 代码（通过分号或换行符作为分隔），而 eval() 不能。
    ```py
    >>> exec('1;2')
    >>> eval('1;2')
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<string>", line 1
        1;2
        ^
    SyntaxError: invalid syntax
    ```

### compile()

```py
compile(src, filename, mode) -> code
```
- 功能：将 src 编译成一个 code 对象。
  - filename 参数表示，从某个文件中读取 src 。
  - mode 参数表示编译模式。
    - 如果 src 是一个 Python 模块（也就是多行 Python 代码），则应该传入 mode='exec' 。
    - 如果 src 是一个 Python 表达式（保存为 str 或 bytes 对象），则应该传入 mode='eval' 。
    - 如果 src 是单行 Python 代码（保存为 str 或 bytes 对象），则应该传入 mode='single' 。
  - code 对象可以被 exec() 或 eval() 执行。
- 例：
  ```py
  >>> compile('a=1; print(a)', '', 'exec')
  <code object <module> at 0x00000193EB6BB2F0, file "", line 1>
  >>> exec(_)
  1
  ```

## 关于标识符

### help()

```py
help(name)
```
- 功能：查看一个标识符的说明文档。
- 例：
  ```py
  >>> help(id)
  Help on built-in function id in module builtins:

  id(obj, /)
      Return the identity of an object.
  ```

### callable()

```py
callable(name) -> bool
```
- 功能：判断一个标识符是否可以通过 `name()` 的语法调用。
  - 一般情况下，只有函数名、类名可以调用。
- 例：
  ```py
  >>> callable(1)
  False
  >>> callable(int)
  True
  ```

### dir()

```py
dir(...) -> list
```
- 功能：查询某个作用域（也就是某个命名空间）中的所有标识符（包括变量、函数、类、模块等）。
- 直接执行 `dir()` ，会返回当前作用域的所有标识符：
  ```py
  >>> dir()
  ['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']
  ```
  不过这会省略 Python 的内置函数、内置异常名，如果想查看这些标识符，可以执行：
  ```py
  >>> import builtins
  >>> dir(builtins)
  ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', ...]
  ```
- 执行 `dir(object)` ，会返回指定对象的所有属性：
  ```py
  >>> dir('hello')
  ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', ...]
  ```

### globals()

```py
globals() -> dict
```
- 功能：返回一个 dict ，包含全局作用域的所有标识符。
- 例：
  ```py
  >>> globals()
  {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>}
  ```

### locals()

```py
locals() -> dict
```
- 功能：返回一个 dict ，包含当前作用域的所有标识符。
- 如果在全局作用域执行 `locals()` ，则相当于执行 `globals()` ：
  ```py
  >>> locals()
  {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>}
  ```
- 如果在局部作用域执行 `locals()` ，则只会看到局部的标识符：
  ```py
  >>> def fun1():
  ...     x = 1
  ...     print(locals())
  ...
  >>> fun1()
  {'x': 1}
  ```

## 关于类

### isinstance()

```py
isinstance(obj, class_or_tuple) -> bool
```
- 功能：判断一个对象，是否为某个 class 创建的实例。
- 例：
  ```py
  >>> isinstance(1, float)
  False
  >>> isinstance(1, (int, float)) # 可以将多个 class 放在一个 tuple 中，只要匹配其中一个 class ，就返回 True
  True
  ```

### issubclass()

```py
issubclass(cls, class_or_tuple) -> bool
```
- 功能：判断一个类 cls ，是否为 class_or_tuple 其中一个类，或它们的子孙类。
- 例：
  ```py
  >>> class Test(int):
  ...     pass
  ...
  >>> issubclass(Test, Test)
  True
  >>> issubclass(Test, float)
  True
  >>> issubclass(Test, (int, float))
  False
  ```

## 关于反射

- 如何访问一个对象的某个成员？
  - 一般做法是，使用成员运算符 `.` ，执行 `<object>.<meber>` 形式的代码。
    - 这种做法的缺点：编写代码时，就固定了成员的名称，不能改变。
    - 例：
      ```py
      >>> 'hello'.encode
      <built-in method encode of str object at 0x0000025E41188C30>
      ```
  - 另一种做法：根据某个成员的名称，获取这个成员的引用。名称是一个字符串，可以随时改变。
    - 这种做法称为反射（reflection）。
    - 大部分编程语言都不支持反射，而 Python 支持反射，体现了它作为一种动态语言的灵活性。

### getattr()

```py
getattr(obj, name:str, default=...) -> attribute
```
- 功能：获取对象中，名为 name 的那个属性（又称为成员）。
  - 如果不存在该属性，且未传入 default 参数，则抛出异常。
  - 如果不存在该属性，且传入了 default 参数，则返回 default 值。
- 例：
  ```py
  >>> a = 'hello'           # 创建一个对象，赋值给变量 a
  >>> getattr(a, 'encode')  # 获取对象中，名为 encode 的那个属性
  <built-in method encode of str object at 0x0000025E41188C30>
  >>> _()   # 调用 encode() 方法，相当于执行 a.encode()
  b'hello'
  >>> getattr(a, 'len')
  AttributeError: 'str' object has no attribute 'len'
  ```

### hasattr()

```py
hasattr(obj, name:str) -> bool
```
- 功能：判断对象中，是否存在名为 name 的属性。
- 例：
  ```py
  >>> hasattr('hello', 'encode')
  True
  >>> hasattr('hello', 'len')
  False
  ```

### setattr()

```py
setattr(obj, name:str, attribute) -> None
```
- 功能：在对象中，给名为 name 的那个属性赋值，让它引用 attribute 。
- 例：
  ```py
  >>> class Test:
  ...     pass
  ...
  >>> t1 = Test()
  >>> setattr(t1, 'name', 't1')   # 添加一个名为 name 的属性，它的取值为 't1' 字符串，因此 t1.name 是一个变量
  >>> t1.name
  't1'
  >>> setattr(t1, 'print', print) # 添加一个名为 print 的属性，它的取值为 print 函数，因此 t1.print 是一个方法
  >>> t1.print('hello')
  hello
  ```

- 如果声明了类的内置变量 `__slots__` ，则只允许对指定名称的属性，进行 setattr()、delattr() 操作。
  ```py
  >>> class Test:
  ...     __slots__ = ('name', 'method1')
  ...     def method2(self):
  ...         pass
  ...
  >>> t1 = Test()
  >>> setattr(t1, 'name', 't1')     # 相当于执行 t1.name = 't1'
  >>> setattr(t1, 'method1', print) # 相当于执行 t1.method1 = print
  >>> setattr(t1, 'method2', print)
  AttributeError: 'Test' object attribute 'method2' is read-only
  ```

### delattr()

```py
delattr(obj, name:str) -> None
```
- 功能：在对象中，删除名为 name 的那个属性。
- 例：
  ```py
  >>> delattr(str(), 'encode')
  AttributeError: 'str' object attribute 'encode' is read-only
  ```

## 关于迭代

### filter()

```py
filter(function=None, iterable) -> Generator
```
- 功能：遍历 iterable 对象中的所有元素，进行过滤，保留部分元素，然后以迭代器的形式返回。
  - 输入一个函数 function 用于决定如何过滤：每迭代一个元素 x ，会调用 function(x) ，如果函数返回值为 True ，才保留该元素。
- 例：
  ```py
  >>> def is_int(x):
  ...     try:
  ...         _ = int(x)
  ...         return True
  ...     except ValueError:
  ...         return False
  ...
  >>> iterable = [1, '2', 'three']
  >>> filter(is_int, iterable)
  <filter object at 0x0000025520DDCDC0>
  >>> list(_)
  [1, '2']
  ```
