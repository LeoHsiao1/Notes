# 关于时间

## 时间标准

- 1884 年，国际子午线会议决定，以经过格林尼治的经线，作为本初子午线，也就是 0 度经线。将全球 360 度经线，平均分为 24 个时区。
  - 格林威治天文台，位于英国伦敦。人们将这里的时间，称为格林威治时间（Greenwich Mean Time，GMT），代表 0 时区，又被称为世界时（Universal Time，UT）。
  - 格林威治天文台，会定期公布当前的 GMT 时间。而世界各地 ±N 时区的人们，会在 GMT 时间的基础上，加减 N 小时，作为当地时区的时间。
  - GMT 时间，是基于天文观测进行计时。比如将太阳运行到天空最高点的时刻，记作正午。

- 1955 年，人们发明了铯原子钟，提供了一种比天文观测更精准的计时方法。
  - 基于铯原子钟，人们发明了一种新的时间标准，称为国际原子时（TAI）。
    - 它表示从 `1958-01-01T00:00:00+00:00` 开始，到当前为止，经过的秒数。
    - 1958 年这个开始时刻，称为它的纪元（epoch）。

- 人们在世界各地存放了多个铯原子钟。经过协调同步，它们的秒数会同时递增，几乎没有误差。通过这种方式得到的时间，称为协调世界时（UTC）。
  - 例如，每个 GPS 卫星，包含一个铯原子钟。
  - GMT、UTC 都是指 0 时区的当前时间，可用于计算其它时区的时间。

- 闰秒（leap second）
  - 人们将地球自转一周的时长，称为 1 天。每天分为 24 个小时，每小时分为 60 分钟，每分钟分为 60 秒，总共 86400 秒。
  - 但是，地球的自转速度在逐渐变慢（由于潮汐摩擦等原因），导致一天的时长比 86400 秒多一点点。累计多日之后，这种误差会越来越大。
  - 因此，当 UTC time 与 GMT time 的误差越来越大，接近 0.9 秒时，国际计量局就会进行闰秒：将 UTC time 调慢一秒，使得某天的最后一分钟包含 61 秒。
    - 换句话说，原本 UTC time 与 TAI time 一致。但是人为增加闰秒之后，UTC time 偏离 TAI time ，变成与 GMT time 一致。
  - 大部分软件，不会考虑到闰秒。因此闰秒的出现，可能导致某些软件发生故障。
  - 截止到 2022 年，UTC time 已经增加了几十次闰秒，与 TAI time 的偏移量达到 -37 秒，或者说滞后 37 秒。
  - 2022 年，国际计量大会决定，于 2035 年取消闰秒。

- Unix 时间戳（Unix timestamp）
  - 又称为 Unix time、POSIX time ，它是类 Unix 操作系统中常用的一种时间。
  - 它表示从 `1970-01-01T00:00:00+00:00` 开始，到当前为止，经过的秒数。
    - 1970 年这个开始时刻，称为它的纪元。
    - 某些软件，用 32 bits 长度的变量存储 Unix time ，导致最大时间只能记录到 2038 年，存在隐患。
  - 大部分计算机都包含一个硬件时钟，即使主机关机，也会一直累计 Unix time 。
    - 硬件时钟，通常是基于石英晶体的振荡进行计时，误差大于铯原子钟。换句话说，硬件时钟不能准确计量 1 秒的时长，可能偏快、偏慢。
    - 除了误差之外，Unix time 是直接累计秒数，不考虑闰秒。因此计算机运行几年之后，累计的 Unix time ，必然偏离 UTC time 。
    - 因此，只靠 Unix time 不能得知正确的 UTC time 。大部分计算机会通过 NTP 等网络协议，自动获取最新的 UTC time 。
  - 总之，Unix time 是每个计算机独自累计的秒数，容易偏离 UTC time ，因此需要定期修改、纠正。
  - 例如，2016 年底进行了一次闰秒：
    - UTC time 为 `2016-12-31T23:59:59+00:00` 时，对应的 Unix time 为 `1483142399` 。
    - 下一秒，UTC time 为 `2016-12-31T23:59:60+00:00` ，属于闰秒。此时 Unix time 递增一秒，变为 `1483142400` 。
    - 下一秒，UTC time 为 `2017-01-01T00:00:00+00:00` ，符合常见的 24 小时制。此时 Unix time 停顿一秒，依然为 `1483142400` ，从而与 UTC time 一致。

- 上面介绍的几种时间标准，是以秒数的格式查看时间。但普通人更习惯以字符串格式，查看时间（包括年份、月份、日期），此时推荐采用 ISO8601 格式。
  - 例：
    ```sh
    1970-01-01T00:00:00Z        # 末尾的字母 Z 表示 0 时区
    1970-01-01T00:08:00+08:00   # 末尾的 +8 表示东八区
    ```
  - 特点：
    - 采用 24 小时制。
    - 用字母 T 分隔 day 与 hour 。
    - 各个字段从大到小排列：year、month、day、hour、minute、second
    - 各个字段的长度固定，比如年份总是 4 个字符，月份总是 2 个字符。缺位则用 0 补齐。

- 夏令时（Daylight Saving Time，DST）
  - 20 世纪，一些国家开始采用夏令时的制度。
    - 夏天的太阳更早升起，所以当夏天开始时，将时钟拨快一小时，从而早睡早起，提高日光的利用率，减少晚上的照明耗能。
    - 当夏天结束时，将时钟调慢一小时，恢复原状。

- CST 是一种缩写，可能表示以下几个时区之一：
  - 中国标准时间：China Standard Time UTC+8:00
  - 美国中部时间：Central Standard Time (USA) UTC-6:00
  - 澳大利亚中部时间：Central Standard Time (Australia) UTC+9:30
  - 古巴标准时间：Cuba Standard Time UTC-4:00

## import time

：Python 的标准库，用于获取时间。
- [官方文档](https://docs.python.org/3/library/time.html)
- Python 解释器本身不知道当前时间，只能调用本机操作系统的 API ，获取 UTC time 等信息。

- 例：获取 0 时区的时间
  ```py
  >>> import time
  >>> time.time()     # 返回当前的 Unix 时间戳，取值为 float 类型
  1544593113.593077
  >>> time.gmtime(time.time())  # 将 Unix 时间戳转换成一个 struct_time 对象，包含年、月、日等信息
  time.struct_time(tm_year=2018, tm_mon=12, tm_mday=12, tm_hour=5, tm_min=38, tm_sec=33, tm_wday=2, tm_yday=346, tm_isdst=0)
  >>> time.gmtime()             # 不输入参数时，相当于输入 time.time()
  time.struct_time(tm_year=2018, tm_mon=12, tm_mday=12, tm_hour=5, tm_min=38, tm_sec=33, tm_wday=2, tm_yday=346, tm_isdst=0)
  >>> time.gmtime().tm_year     # 获取 struct_time 对象的一个字段
  2018
  ```
  - struct_time 对象不包含毫秒。
  - tm_wday 表示当前是本周的第几天。
  - tm_yday 表示当前是本年的第几天。
  - tm_isdst 表示是否属于夏令时。

- 例：获取本地时区的时间
  ```py
  >>> time.localtime(time.time()) # 将 Unix 时间戳，转换成本地时区的 struct_time 对象
  time.struct_time(tm_year=2018, tm_mon=12, tm_mday=12, tm_hour=13, tm_min=38, tm_sec=33, tm_wday=2, tm_yday=346, tm_isdst=0)
  >>> time.localtime().tm_year    # 不输入参数时，相当于输入 time.time()
  2018
  ```

- 例：时间与字符串的转换
  ```py
  >>> time.strftime('%Y/%m/%d %H:%M:%S', time.localtime())  # 将 struct_time 对象，转换成指定格式的字符串
  '2018/12/12 13:38:33'
  >>> time.strptime('2018/12/12 13:38:33', '%Y/%m/%d %H:%M:%S') # 将指定格式的字符串，转换成 struct_time 对象
  time.struct_time(tm_year=2018, tm_mon=12, tm_mday=12, tm_hour=13, tm_min=38, tm_sec=33, tm_wday=2, tm_yday=346, tm_isdst=-1)
  >>> time.asctime()  # 返回 C 语言风格的时间字符串
  'Wed Dec 12 13:38:33 2018'
  ```

- 关于 Python 解释器：
  ```py
  >>> time.sleep(1)   # 让当前线程睡眠 1 秒，或者说阻塞 1 秒
  ```
  ```py
  >>> time.perf_counter() # 返回当前 Python 解释器启动之后，经过的时长
  16.795266047
  >>> time.process_time() # 返回当前进程，累计占用的 CPU 时长，不包括 sleep 的时长
  0.078125
  >>> time.thread_time()  # 返回当前线程，累计占用的 CPU 时长，不包括 sleep 的时长
  0.078125
  ```
