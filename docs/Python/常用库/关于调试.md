# 关于调试

## import traceback

：Python 的标准库，用于读取 traceback 。
- [官方文档](https://docs.python.org/3/library/traceback.html)
- Python 解释器会将抛出的异常，暂存在 traceback 堆栈中。因此，可以通过 traceback 读取当前的异常。
- 例：
  ```py
  >>> import traceback
  >>> try:
  ...     raise RuntimeError('an error')
  ... except:
  ...     traceback.print_exc()         # 打印当前的所有异常
  ...     info = traceback.format_exc() # 保存异常的内容
  ...
  Traceback (most recent call last):
    File "<stdin>", line 2, in <module>
  RuntimeError: an error
  >>> info
  'Traceback (most recent call last):\n  File "<stdin>", line 2, in <module>\nRuntimeError: an error\n'
  >>> traceback.format_exc()  # 之前的异常已经被 except 捕捉，此时 traceback 中不存在异常
  'NoneType: None\n'
  ```

## import inspect

：Python 的标准库，用于进行一些检查。
- [官方文档](https://docs.python.org/3/library/inspect.html)

- 检查对象的类型：
  ```py
  >>> import inspect
  >>> inspect.ismodule(inspect)
  True
  >>> inspect.isclass(int)
  True
  >>> inspect.isfunction(print) # 检查对象是否为函数，不能检查 built-in 函数
  False
  >>> inspect.isfunction(lambda : ...)
  True
  >>> inspect.isgenerator((i for i in range(5)))  # 检查对象是否为生成器
  True
  ```

- 检查源代码：
  ```py
  >>> inspect.getfile(inspect.getfile)  # 找到该对象是在哪个 .py 文件中创建的
  '/usr/lib64/python3.6/inspect.py'
  >>> inspect.getfile(int)    # 不能查找 built-in 的对象
  TypeError: <class 'int'> is a built-in class
  >>> inspect.getsourcelines(inspect.getfile) # 返回该对象的源代码
  (['def getfile(object):\n', '    """Work out which source or compiled file an object was defined in."""\n', '    if ismodule(object):\n', " ...], 655)
  ```

- 检查函数形参：
  ```py
  >>> def fun1(a, b: str, c: int = 0):
  ...     pass
  ...
  >>> sign = inspect.signature(fun1)  # 查看函数的调用签名，返回一个 Signature 对象
  >>> sign
  <Signature (a, b: str, c: int = 0)>
  >>> sign.parameters # 获取函数的形参列表，返回一个 Map 对象
  mappingproxy(OrderedDict([('a', <Parameter "a">), ('b', <Parameter "b: str">), ('c', <Parameter "c: int = 0">)]))
  >>> sign.parameters['c'].name
  'c'
  >>> sign.parameters['c'].default
  0
  >>> sign.parameters['c'].annotation
  <class 'int'>
  ```
  ```py
  >>> sign.bind(1)    # 可以模拟给函数传入参数
  TypeError: missing a required argument: 'b'
  >>> sign.bind(1, b=2)
  <BoundArguments (a=1, b=2)>
  >>> _.args          # 获取元组类型的所有参数
  (1, 2)
  ```

## import unittest

：Python 的标准库，用于编写测试脚本。
- [官方文档](https://docs.python.org/3/library/unittest.html)
- 它是一个单元测试框架，借鉴 Java 的 JUnit 。

### 原理

- unittest ，工作流程如下：
  - 指定要查找的目录（默认是当前目录）。
    如果子目录属于 Python 包，则也加入查找范围。
  - 然后在该目录下查找名称匹配 `test*.py` 的文件。
  - 接着在该文件中查找继承 `unittest.TestCase` 的类，
  - 最后查找该类中名称以 `test` 开头的方法，作为测试用例来执行。

- 如果执行测试用例时没有抛出异常，则测试通过，显示 ok 。否则不通过，显示 FAIL 。
- unittest 会捕获执行过程中出现的所有异常，在执行完所有测试用例之后再打印出来。

### 用例

1. 先定义一个继承 `unittest.TestCase` 的测试类，在其中定义测试方法：
    ```py
    import unittest

    class TestMath(unittest.TestCase):
        def test_add(self):
            assert 1 + 1

        def test_minus(self):
            assert 1 - 1

    ```

2. 用 unittest 模块执行这些测试方法：
    ```sh
    [root@CentOS ~]# python3 -m unittest -v
    test_add (__main__.TestMath) ... ok
    test_minus (__main__.TestMath) ... FAIL

    ======================================================================
    FAIL: test_minus (__main__.TestMath)
    ----------------------------------------------------------------------
    Traceback (most recent call last):
    File "testSample.py", line 8, in test_minus
        assert 1 - 1
    AssertionError

    ----------------------------------------------------------------------
    Ran 2 tests in 0.002s

    FAILED (failures=1)
    ```
