# 模块与包

- 模块（Module）
  - 一个 py 脚本文件，可以被 Python 解释器直接运行，也可以被其它脚本文件通过 import 语句调用，此时该脚本文件称为一个模块。

- 包（Package）
  - 在一个文件目录中，添加一个名为 `__init__.py` 的文件（内容可以为空），Python 解释器就会将该目录识别为包。
  - 使用包，方便管理一个目录下的多个 Python 模块。
  - 一个包目录，可以嵌套包含多个包目录。

## import

- 用关键字 `import` 可以将某个模块，导入到当前脚本。
  - 例：
    ```py
    >>> import sys      # 导入一个名为 sys 的模块
    >>> sys
    <module 'sys' (built-in)>
    >>> sys.platform    # 调用 sys 模块的成员
    'linux'
    ```

- 用关键字 `import` 也可以导入一个包，但本质上是导入包中的一个模块。
  - 执行 `import <package>` 语句，相当于执行 `import <package>.__init__` ，导入包中一个名为 `__init__` 的模块。
  - 因此，每个包必须包含一个名为 `__init__.py` 的文件。

- 执行 `from xx import xx` 语句，可以从某个模块或包，导入某个成员。
  - 例：
    ```py
    >>> from sys import platform
    >>> platform    # 这样标识符较短，比 sys.platform 更方便。但是 platform 这个名称，
    'linux'
    ```
  - 这种语法的优点：
    - 编写代码更方便。不必输入 `sys.platform` 这样较长的标识符，只需输入 `platform` 这样较短的标识符。
  - 这种语法的缺点：
    - `platform` 这样的标识符，没有前缀，可能与当前作用域的某个标识符重名。
    - 代码的可读性差。当读者看到 `platform` 这样的标识符时，不知道它是当前脚本定义的变量，还是通过 import 导入的。
  - 可以同时导入多个成员，用逗号分隔：
    ```py
    >>> from sys import platform, path
    ```
  - 用 * 可以导入全部成员。但这样不能看出究竟导入了哪些成员，导致代码的可读性更差，建议不要这样做。
    ```py
    from sys import *
    ```

- 用关键字 `as` 可以将导入的标识符重命名：
  ```py
  import sys as _sys
  from sys import path as _path
  ```

- 一般将 import 语句写在 Python 脚本的开头，使得导入的标识符，可在全局作用域内访问。
  - 也可以将 import 语句写在某个函数或方法内，使得执行该语句块时才会执行 import 语句，并且导入的模块只能在该局部作用域内被访问。
    - pyinstaller 在打包 Python 脚本时，会将局部导入的各个模块一起收集，即使该 import 语句位于不会被执行的 if 分支。

### 寻址

- 执行 `import xx` 可以导入某个模块或包，但 Python 解释器如何知道这个模块或包，的实际文件路径？
  - `sys.path` 是一个 list 类型的变量，记录了当前计算机上常用的几个目录。Python 解释器会到这些目录及其子目录中，查找名为 xx 的 Python 模块文件，Python 包目录。
    ```py
    >>> sys.path
    ['', '/usr/lib64/python36.zip', '/usr/lib64/python3.6', ...]
    ```
  - 如果找到了，则导入。如果没找到，则抛出异常： `ModuleNotFoundError: No module named 'xx'`
  - 用户可以主动添加其它目录到 `sys.path` 中。不过每次重启 Python 解释器时，都会重置 `sys.path` 的值。
    ```py
    >>> sys.path.append('/tmp')
    ```

- 如果一个脚本位于一个包内，则可以通过相对地址导入其它模块或包：
  ```py
  from .utils import *    # 从当前目录导入（需要当前目录是一个包）
  from .. import *        # 从上层目录导入（需要当前目录、上层目录都是包）
  ```
  - 如果该脚本被间接执行，则 Python 解释器会自动将这些相对地址，转换成绝对地址。
  - 如果该脚本被直接执行，则 Python 解释器不能处理相对地址，会报错。

- 如果模块名、包名会变化，如何导入？可以调用 importlib 模块的 import_module() 函数，输入一个 str 字符串作为模块名、包名，然后导入。
  ```py
  >>> from importlib import import_module
  >>> m = import_module('os')                   # 相当于 import os
  >>> m
  <module 'os' from '/usr/lib64/python3.6/os.py'>
  >>> m = import_module('os.path')              # 相当于 import os.path
  >>> m
  <module 'posixpath' from '/usr/lib64/python3.6/posixpath.py'>
  >>> m = import_module('sys', package='os')    # 相当于 from os import sys
  >>> m
  <module 'sys' (built-in)>
  ```

### 间接执行

- 通过 import 导入一个模块时，实际上会执行一遍该模块的全部 Python 代码，然后将其中创建的所有对象，保存到当前脚本的作用域，供当前脚本访问。
  - 例如：用 Python 解释器执行 a.py ，而 a.py 导入了 b.py ，则最终两个脚本都会被执行一次，只不过一个是被直接执行，一个是被间接执行。
  - 例如，编写一个 test.py ：
    ```py
    print('Hello')

    def fun1():
        print('fun1')

    def fun2():
        print('fun2')
        fun1()
    ```
  - 然后在终端导入该脚本：
    ```py
    >>> from test import fun2
    Hello                         # 执行 print('Hello')
    >>> fun2()
    fun2
    fun1                          # 导入一个函数或类时，其调用的其它内容会被自动导入
    >>> fun1()                    # 但是并不能被直接访问
    NameError: name 'fun1' is not defined
    >>> from test import fun1     # 多次导入一个模块时，只会执行一次作为初始化，不会重复执行它，因此这里不会再执行 print('Hello')
    >>> fun1()
    fun1
    ```

### 循环导入

- 循环导入，是指两个 Python 模块相互导入，或者多个 Python 模块的导入关系形成一个回路。
  - 这种操作是可行的，并不会引发报错。
  - 此时相当于将多个模块中的所有 Python 语句，按导入顺序组合成一个大型脚本，可能产生冲突。
- 例：
  1. 创建两个循环导入的脚本文件：\
      A.py ：
      ```py
      print('start', __name__)

      import B
      id = 1
      print(B.id)

      print('end', __name__)
      ```
      B.py ：
      ```py
      print('start', __name__)

      import A
      id = 2
      print(A.id)

      print('end', __name__)
      ```
  2. 执行时输出如下：
      ```sh
      [root@CentOS ~]# python3 A.py
      start __main__
      start B
      start A                               # 此时 B.py 导入 A.py ，从头执行其中的代码，重复执行了 print('start', __name__)
      Traceback (most recent call last):
        File "A.py", line 3, in <module>    # 此时 A.py 尚未完成初始化，就导入 B.py ，输出 start B
          import B
        File "B.py", line 3, in <module>    # 此时 B.py 尚未完成初始化，就导入 A.py ，输出 start A
          import A
        File "A.py", line 5, in <module>    # 此时在 A.py 中访问 B.id ，但该变量尚未创建，所以报错
          print(B.id)
      AttributeError: partially initialized module 'B' has no attribute 'id' (most likely due to a circular import)
      ```
  3. 将 A.py 中的 `print(B.id)` 改为 `print(dir(B))` ，就可以循环导入。如下：
      ```sh
      [root@CentOS ~]# python3 A.py
      start __main__
      start B
      start A
      ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']
      end A             # 此时 B.py 尚未完成初始化，但导入的 A.py 已经完整执行了一次，完成了初始化
      1                 # 此时可以在 B.py 中访问 A.id
      end B
      ['A', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'id']
      end __main__
      ```
      也可以将 A.py 中的 print(B.id) 放到不会立即执行的代码块中：
      ```py
      def test():
          print(B.id)

      ```

### 内置变量

每个 Python 脚本文件，存在以下内置变量：

- `__file__`
  - ：脚本的文件路径，由 Python 解释器自动赋值。
  - 当脚本被直接运行时，其值为执行该脚本时使用的文件路径（可能为绝对路径、相对路径）。
  - 当脚本被间接运行时，其值为该脚本的绝对路径。

- `__name__`
  - ：脚本的名称，由 Python 解释器自动赋值。
  - 当脚本被直接运行时，其值为固定值 `"__main__"` 。
  - 当脚本被间接运行时，其值为该脚本的模块名，即将脚本的文件名去掉 .py 后缀。
  - 例：编写一个 test.py
    ```py
    print(__file__)
    print(__name__)
    ```
    在终端执行该脚本时，其输出为：
    ```sh
    [root@CentOS ~]# python test.py
    test.py
    __main__

    [root@CentOS ~]# python /root/test.py
    /root/test.py
    __main__
    ```
    在 Python 解释器中导入该脚本时，其输出为：
    ```py
    >>> import test
    /root/test.py
    test
    ```
  - 例：如果当前脚本被执行运行，则会执行以下语句块。如果当前脚本被间接运行，则不会执行以下语句块。
    ```py
    if __name__ == '__main__':
        try:
            main()
        except:
            raise
    ```

- `__all__`
  - ：一个列表，决定了用 `from xx import *` 导入该脚本时会导入哪些成员。
  - 如果用户没有定义该属性，则默认会导入该脚本内的所有公有成员（即不以下划线 `_` 开头的标识符）。
  - 例：
    ```py
    from sys import path

    __all__ = ['path', 'fun1']

    def fun1():
        pass
    ```
