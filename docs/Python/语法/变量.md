# 变量

## 赋值

- C 语言中，给一个变量赋值之前，需要事先定义该变量，声明其数据类型，例如 `int a;`。而 Python 中，不需要这么做。因为：
  - 给一个名为 a 的变量赋值时，如果该名称的变量不存在，则 Python 会自动创建该变量，然后赋值。
  - Python 的变量不区分数据类型，变量所指的对象才区分数据类型。
  - 例：
    ```py
    >>> a = 1         # 给变量 a 赋值为 1 。实际上是让变量 a ，指向 1 这个 int 数据类型的对象
    >>> a = 'hello'   # 给变量 a 赋值为 'hello' 。实际上是让变量 a ，指向 'hello' 这个 str 数据类型的对象
    >>> type(a)       # 用函数 type() 可以查看变量所指对象的类名
    <class 'str'>
    >>> del a         # 用关键字 del 可以删除一个变量，但不会删除它所指的对象
    >>> a             # 再次读取变量 a ，会报错说它不存在
    NameError: name 'a' is not defined
    ```

- C 语言中，可以用关键字 const 将一个变量声明为常量。而 Python 中，不支持将变量声明为常量，而是采用以下做法：
  - 通常将变量名大写所有字母，表示该变量被当作常量使用，不应该被修改。
  - Python 中 int、float、complex、tuple、str、bytes 等数据类型的对象，是只读的，相当于常量。

## 标识符

- 变量名、函数名、类名等符号，统称为标识符。
  - 每个标识符的命名格式：
    - 可以由阿拉伯数字、英文字母、下划线几种字符组成。
    - 不能以数字开头。
    - 字母区分大小写。

- 单独的下划线 `_` 是一种特殊的标识符。
  - 编程时，可以将不会使用的临时变量命名为 _ ，表示读者不需要关心该变量。例如：
    ```py
    for _ range(10):
        print('hello')
    ```
  - 在 Python 终端中交互式编程时，如果执行某条语句的返回值不为 None ，则会自动赋值给名为 _ 的变量。例如：
    ```py
    >>> _           # 刚打开 Python 终端时，变量 _ 尚未创建
    NameError: name '_' is not defined
    >>> 1           # 该语句的返回值不会 None ，因此会被赋值给变量 _
    1
    >>> _
    1
    >>> print(2)    # 执行该语句的返回值为 None ，因此不会赋值给变量 _
    2
    >>> _
    1
    ```
  - 进行 I18N 国际化、L10N 本地化时，通常将翻译字符串的函数命名为 _ ，便于调用。例如：
    ```py
    def _(message):
        return message

    print(_('hello'))
    ```

## 对象

- Python 是一种纯面向对象的编程语言。Python 中的所有值，都是以对象的形式保存。
  - C++ 虽然也是一种面向对象的编程语言，但 int 等基本数据类型的值，不会保存为对象。例如：
    ```cpp
    int a = 1;
    char* b = "hello";        // 变量 b 是一个指针，不是对象
    std::string c = "hello";  // 变量 c 是一个 std::string 对象
    ```
  - Python 中，即使用户输入 int 等基本数据类型的值，也会被自动保存为某个内置 class 的实例对象。例如：
    ```py
    >>> type(1)
    <class 'int'>
    >>> type('hello')
    <class 'str'>
    ```

### 内存管理

- Python 会自动为对象分配内存、回收内存，不需要用户主动管理内存。
  - C 语言中，存储一段数据时，需要调用 malloc() 申请 n bytes 的内存空间。当该数据停止使用时，需要调用 free() 回收其内存空间。
  - Python 中，会自动管理每个对象占用的内存。例如：
    ```py
    >>> a = list()    # 创建一个 list 对象，此时不需要用户主动分配内存空间
    >>> a.append(1)   # 往 list 对象中添加一个元素，此时它会自动占用更多内存空间
    ```

- Python 如何自动回收内存？
  - Python 解释器会记录每个对象的引用数，从而得知它被多少个变量、其它对象引用了。
  - 如果某个对象的引用数减少至 0 ，则说明该对象停止使用，Python 解释器会自动回收该对象的内存空间。
  - 用户可以主动查询一个对象的引用数：
    ```py
    >>> import sys
    >>> a = 'hello'
    >>> sys.getrefcount(a)  # 一个新对象的引用数为 2
    2
    >>> b = a
    >>> sys.getrefcount(a)  # 该对象被变量 b 引用，因此引用数加 1
    3
    ```
  - 在 CPython 解释器的底层，每个 Python 对象用一个 C 语言的结构体表示：
    ```c
    typedef struct _object {
        Py_ssize_t ob_refcnt;         // 该对象的引用数
        struct _typeobject *ob_type;  // 该对象的类型
    } PyObject;
    ```

## 引用

### id()

- 函数 `id()` 用于查询一个对象的 id 。
  - 例：
    ```py
    >>> id(1)       # 1 这个值，会作为一个 int 类型的对象保存
    2400851487024
    >>> a = 1
    >>> id(a)       # 如果给 id() 输入一个变量，则会查询该变量所指对象的 id
    2400851487024
    ```
  - Python 解释器每创建一个对象，会给该对象分配一个 id ，取值随机、全局唯一。如果两个对象的 id 相同，则说明它们是同一个对象。
  - CPython 解释器中，是使用对象的内存地址作为 id 。
  - 为了节省开销，当用户创建 `[-5, 256]` 范围内的 int 类型对象、20 位以内的 str 类型对象时，Python 解释器会将这些对象缓存起来，不会销毁，方便用户未来重复创建这些对象。例如：
    ```py
    >>> a = 256
    >>> b = 256
    >>> a is b
    True        # 两个变量，指向同一个对象
    >>> a = 257
    >>> b = 257
    >>> a is b
    False       # 两个变量，指向不同的对象
    ```

### 引用传递

- Python 中的变量，用法像 C 语言中的通用指针，可以指向任何类型的对象。
  - 变量本身不会存储数据，只是一个标识符、一个名称代号。
  - 给一个变量赋值时，不会让该变量直接存储该值，而是让该变量，指向（或者说引用），这个值（或者说对象）。例如：
    ```py
    >>> a = 'hello'
    >>> id(a)
    2858938357104
    >>> a = 'world' # 给变量 a 赋予另一个值
    >>> id(b)       # 可见，变量 a 指向了另一个对象
    2858938356480
    ```

- Python 中的变量，虽然用法像 C 语言的通用指针，但实际上并不是指针，而是引用。
  - 例如 C 语言中的以下语句，是创建一个 `char *` 类型的指针变量 p ，存储一块内存空间的首地址。
    ```c
    char *p = malloc(10*sizeof(char));
    ```
  - 用户使用指针时，知道了对象的内存首地址，就可以访问从首地址开始的第 n 个字节。但指针比较危险：
    - 一个指针变量，存储的内存地址可能是无效的（比如用户修改了指针存储的内存地址），使用该指针可能导致程序崩溃。
    - 用户可以故意访问特殊的内存地址，比如缓冲溢出攻击。
  - 为了提高安全性，C++、Java、C#、Python 等编程语言，将指针类型的变量，改进为引用类型的变量。
    - 引用，只能定位对象，不允许用户直接操作内存地址。
    - C++ 代码示例：
      ```cpp
      int a  = 1;   // 1 属于基本数据类型，将它赋值给变量时，会采用值传递，将 1 这个值拷贝到变量 a 的内存空间中存储
      int *b = &a;  // 这是创建一个指针类型的变量
      int &c = a;   // 这是创建一个引用类型的变量。将变量 a 的引用传递给变量 c 时，会采用引用传递，让变量 c 指向同一个对象
      ```

### 值传递

- Python 中的赋值，一般采用引用传递，而不是值传递。因此原对象只存储了一份，修改该对象时，会影响所有引用者。
  - 例：
    ```py
    >>> a = [0, 1]
    >>> b = a     # 这是引用传递
    >>> b
    [0, 1]
    >>> a[0] = 1  # 这是值传递，修改 a[0] 的值
    >>> a         # 此时变量 a 与 b 所看见的对象，都被修改了
    [1, 1]
    >>> b
    [1, 1]
    >>> a = []    # 这是引用传递，让变量 a 指向另一个对象
    >>> a         # 此时变量 a 与 b 指向不同对象
    []
    >>> b
    [1, 1]
    ```
  - 如果用户希望进行值传递，对于 list 类型的对象，可使用切片、list.copy() 等方法，实现浅拷贝。例：
    ```py
    >>> a = [0, 1]    # [0, 1] 像 C 语言中一个指针数组，第一个指针指向 1 这个对象，第二个指针指向 2 这个对象
    >>> b = a.copy()  # 浅拷贝时，是创建一个新 list ，将每个指针所指的对象拷贝一份
    >>> b
    [0, 1]
    >>> a == b        # 两个 list 的取值相等
    True
    >>> b is a        # 两个 list 不是同一对象
    False
    ```
  - 之所以叫浅拷贝，是因为这样只会拷贝第一层指针所指的对象，不会拷贝第一层对象所指的其它对象。例：
    ```py
    >>> a = [0, 1, [2]]
    >>> b = a.copy()
    >>> b
    [0, 1, [2]]
    >>> a is b
    False
    >>> a[2] is b[2]    # a[2] 指向 [2] 这个对象，该对象在 copy() 时是引用传递，因此 a[2] 与 b[2] 指向同一对象
    True
    >>> a[2].append(3)  # 修改 a[2] ，会导致 b[2] 也变化，因为它们指向同一对象
    >>> a
    [0, 1, [2, 3]]
    >>> b
    [0, 1, [2, 3]]
    ```
