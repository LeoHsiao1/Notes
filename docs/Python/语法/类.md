# 类

- Python 既支持创建函数（function），也支持创建类（class），从而实现面向对象编程。
  - 使用类，可以创建一组相似的对象（object），作为该类的不同实例（instance）。
  - 例如：Python 中的 int 数据类型，定义为一个名为 int 的类。1、2、3 等整数，是 int 类的不同实例。

## 定义

- Python 中，使用关键字 `class` 可以定义一个类，一般语法为：
  ```py
  def class_name:
      def method1(args):
          statement_block
      def method2(args):
          statement_block
  ```

- 例：
  ```py
  >>> class Test:
  ...     def __init__(self, a=None, b=None):
  ...         self.a = a    # 这里将输入参数 a ，赋值给实例变量 self.a
  ...         self.b = b
  ...         print(self)
  ...         print('an instance has been initialized.')
  ...     def method1(self):
  ...         print(self.a, self.b)
  ...
  >>> t1 = Test(a=1)   # 创建一个 Test 类的实例，赋值给变量 t1
  <__main__.Test object at 0x0000029AA65C5760>
  an instance has been initialized.
  >>> t1              # 变量 t1 指向一个实例
  <__main__.Test object at 0x0000029AA65C5760>
  >>> t2 = Test()     # 再创建一个实例，可见它拥有不同的 object id
  <__main__.Test object at 0x0000029AA63B9430>
  an instance has been initialized.
  >>> t1 is t2        # t1 与 t2 是不同的对象
  False
  >>> t1.method1()    # 调用 t1 实例的一个方法
  1 None
  ```
  - 调用 `class_name()` 即可创建某个类的一个实例。
  - 调用 `class_name(实参列表)` 可以在创建实例的同时，输入一些参数。这些实参，会被传入 `__init__()` 方法。
  - 创建实例时，不管是否传入参数，都会执行一次 `__init__()` 方法，进行初始化。

## 类的成员

- 类是一种高级的数据结构。在一个类中，
  - 可以定义多个变量，称为该类的属性（attribute）。分为几种：
    - 实例变量（instance variable）
    - 类变量（class variable）
  - 可以定义多个函数，称为该类的方法（method）。分为几种：
    - 实例方法
    - 类方法
    - 静态方法
  - 属性、方法，都称为该类的成员（member）。

- 根据访问权限的不同，可将类成员分为几类：
  - public
    - ：公有成员。名称不以下划线 `_` 开头，可以被任何对象访问，可以通过 import 语句导入其它脚本。
  - protected
    - ：受保护成员。名称以一个下划线 `_` 开头，只能在当前类或子类中访问，或通过实例访问。
  - private
    - ：私有成员。名称以两个下划线 `__` 开头，只能在当前类中访问。
  - 例：
    ```py
    >>> class Test:
    ...     a = 0
    ...     _b = 0
    ...     __c = 0
    ...
    >>> Test.a
    0
    >>> Test._b
    0
    >>> Test.__c
    AttributeError: 'Test' object has no attribute '__c'
    ```

## 属性

### 实例变量

- ：一个类的每个实例，分别存储一份实例变量，互不影响。
- 如何访问？
  - 定义类时，只能在方法内，通过 `self.<variable>` 访问实例变量。
    - `self` 是一个内置变量，指向类的当前实例。像 C++ 中使用的 `this` 指针。
  - 定义类之后，只能通过 `<instance>.<variable>` 访问实例变量。
- 例：
  ```py
  >>> class Test:
  ...     def __init__(self, num=0):
  ...         self.num = num
  ...     def get_num(self):
  ...         return self.num
  ...
  >>> t1 = Test(1)
  >>> t1.num
  1
  >>> t1.get_num()
  1
  ```

### 类变量

- ：一个类中只存储一份类变量，被该类的所有实例共享。
- 如何访问？
  - 定义类时，
    - 在方法外，创建的变量，都会被视作类变量。
    - 在方法内，可以通过 `cls.<variable>` 或 `self.__class__.<variable>` 访问类变量。
      - `cls` 是一个内置变量，相当于 `self.__class__` ，指向当前类。
    - 在方法内，也可以通过 `class.<variable>` 访问类变量。
  - 定义类之后，
    - 可以通过 `<class>.<variable>` 访问类变量。
    - 也可以通过 `<instance>.<variable>` 访问，但不能与实例变量重名，否则优先访问实例变量。
- 例：
  ```py
  >>> class Test:
  ...     total = 0
  ...     def __init__(self, num=0):
  ...         self.num = num
  ...         Test.total += num
  ...     def get_total(cls):
  ...         return cls.total
  ...
  >>> t1 = Test(1)
  >>> t1.get_total()
  1
  >>> t1.total
  1
  >>> Test.total
  1
  >>> t2 = Test(2)
  >>> Test.total    # 不同实例，修改的是同一个类变量
  3
  ```

- Python 允许给一个已经定义的类，添加属性。
  ```py
  >>> t1 = Test()
  >>> t1.name
  AttributeError: 'Test' object has no attribute 'name'
  >>> t1.name = 't1'
  >>> Test.name
  AttributeError: type object 'Test' has no attribute 'name'
  >>> Test.name = 'Test'
  >>> Test.__id = 1   # 私有成员不能在类外被访问，但这里还是赋值成功了
  ```
  - 因此，给一个类或实例，的属性进行赋值时，即使该属性不存在，也可以赋值成功。这可能引发 bug ，建议通过 `__slots__` 声明只允许存在哪些成员。

### 内置属性

- 一个对象，具有以下内置属性：
  - `__class__`
    - ：指向当前对象所属的类。
    - 例：
      ```py
      >>> a = 1
      >>> a.__class__
      <class 'int'>
      >>> type(a)           # 用内置函数 type() 也能查看一个对象所属的类
      <class 'int'>
      >>> int.__class__     # 一个类，也有 __class__ 属性。可见在 Python 底层，类是通过基类 type 定义的
      <class 'type'>
      >>> print.__class__   # 一个函数，也有 __class__ 属性。可见在 Python 底层，函数是通过 class 定义的
      <class 'builtin_function_or_method'>
      ```

- 一个函数，具有以下内置属性：
  - `__name__`
    - ：取值为 str 类型，用于存储函数的名称。
    - 例：
      ```py
      >>> f = print   # 即使将函数名赋值给一个变量， __name__ 依然存储的是原来的函数名
      >>> f.__name__
      'print'
      ```
  - `__doc__`
    - ：取值为 str 类型，用于存储函数的说明文档。
    - 例：
      ```py
      >>> print.__doc__   # 函数的说明文档，也就是执行 help(print) 看到的帮助文档
      "print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\nPrints the values ..."
      ```
  - `__defaults__`
    - ：取值为 tuple 类型，用于存储函数各个形参的默认值。
    - 例：
      ```py
      >>> def fun1(x=[], y=[]):
      ...     print(fun1.__defaults__)
      ...     print(x, y)
      ...     y.append(0)   # 形参 y 的默认值为 list 类型，可以被修改，修改结果会持久保留在 __defaults__ 中
      ...
      >>> fun1()
      ([], [])
      [] []
      >>> fun1()
      ([], [0])
      [] [0]
      ```
  - `__annotations__`
    - ：取值为 dict 类型，用于存储函数头中的注释。
    - 例：
      ```py
      >>> def fun1(a, b: 'str或None', c: int = 0) -> int:    # 定义函数时，可以用冒号 : 给形参添加注释
      ...     pass
      ...
      >>> fun1.__annotations__
      {'b': 'str或None', 'c': <class 'int'>, 'return': <class 'int'>}
      ```
  - `__closure__`
    - ：对于非闭包函数，它取值为 None ，没有用处。对于闭包函数，它取值为 tuple 类型，用于存储函数引用的所有自由变量。
    - 例：
      ```py
      >>> def fun1():
      ...     x = 1
      ...     def fun2():
      ...         print(x)
      ...     return fun2
      ...
      >>> fun2 = fun1()
      >>> fun2.__closure__
      (<cell at 0x000001EF96373970: int object at 0x000001EF962E6930>,)
      >>> fun2.__closure__[0].cell_contents
      1
      ```

- 类的一个方法，具有以下内置属性：
  - `__self__`
    - ：它指向当前实例，相当于 self 指针。
    - 例：
      ```py
      >>> class Test:
      ...     def method1(self):
      ...         pass
      ...     @classmethod
      ...     def method2(cls):
      ...         pass
      ...     @staticmethod
      ...     def method3():
      ...         pass
      ...
      >>> t1 = Test()
      >>> t1.method1.__self__   # 实例方法的 __self__ 属性，指向当前实例
      <__main__.Test object at 0x000001EF96C73370>
      >>> t1 is _
      True
      >>> t1.method2.__self__   # 类方法的 __self__ 属性，指向当前类
      <class '__main__.Test'>
      >>> Test is _
      True
      >>> t1.method3.__self__   # 静态方法实际上就是一个函数，没有 __self__ 属性
      AttributeError: 'function' object has no attribute '__self__'
      ```
  - `__func__`
    - ：它指向当前方法绑定的函数名。
    - 在 Python 底层，类的每个方法，是通过函数实现的。
      - 普通方法、类方法会绑定到一个函数，各个实例都是调用该函数。
      - 静态方法实际上就是一个函数，没有 `__func__` 属性。
    - 例：
      ```py
      >>> class Test:
      ...     def method1(self, a):
      ...         return a
      ...
      >>> t1 = Test()
      >>> t1.method1.__func__
      <function Test.method1 at 0x000001EF96C780D0>
      >>> t1.method1.__func__()       # __func__ 属性指向一个函数，可以调用它，但需要传入 self 参数
      TypeError: method1() missing 2 required positional arguments: 'self' and 'a'
      >>> t1.method1.__func__(t1, 'hello')
      'hello'
      ```
