# 类

## 定义

- Python 既支持创建函数（function），也支持创建类（class），从而实现面向对象编程。
  - 使用类，可以创建一组相似的对象（object），作为该类的不同实例（instance）。
  - 例如：Python 中的 int 数据类型，定义为一个名为 int 的类。1、2、3 等整数，是 int 类的不同实例。
- Python 中，使用关键字 `class` 可以定义一个类，一般语法为：
  ```py
  def class_name:
      def method1(args):
          statement_block
      def method2(args):
          statement_block
  ```

- 例：
  ```py
  >>> class Test:
  ...     def __init__(self, a=None, b=None):
  ...         self.a = a    # 这里将输入参数 a ，赋值给实例变量 self.a
  ...         self.b = b
  ...         print(self)
  ...         print('an instance has been initialized.')
  ...     def method1(self):
  ...         print(self.a, self.b)
  ...
  >>> t1 = Test(a=1)   # 创建一个 Test 类的实例，赋值给变量 t1
  <__main__.Test object at 0x0000029AA65C5760>
  an instance has been initialized.
  >>> t1              # 变量 t1 指向一个实例
  <__main__.Test object at 0x0000029AA65C5760>
  >>> t2 = Test()     # 再创建一个实例，可见它拥有不同的 object id
  <__main__.Test object at 0x0000029AA63B9430>
  an instance has been initialized.
  >>> t1 is t2        # t1 与 t2 是不同的对象
  False
  >>> t1.method1()    # 调用 t1 实例的一个方法
  1 None
  ```
  - 调用 `class_name()` 即可创建某个类的一个实例。
  - 调用 `class_name(实参列表)` 可以在创建实例的同时，输入一些参数。这些实参，会被传入 `__init__()` 方法。
  - 创建实例时，不管是否传入参数，都会执行一次 `__init__()` 方法，进行初始化。

### 成员

- C 语言中，用关键字 struct 可以定义一个结构体，将多个变量封装在一起，作为一种高级的数据结构。
- Python 中，用关键字 class 可以定义一个类，将多个变量、函数封装在一起，作为一种高级的数据结构。
  - 一个类中，可以定义任意个变量。分为几种：
    - 实例变量（instance variable）
    - 类变量（class variable）
  - 一个类中，可以定义多个函数，称为该类的方法（method）。分为几种：
    - 实例方法
    - 类方法
    - 静态方法
  - 变量、方法，都属于该类的成员（member），又称为属性（atrribute）。
    - 可通过 `class_name.member_name` 的形式，访问类中的某个成员。

- 根据访问权限的不同，可将成员分为几类：
  - public
    - ：公有成员。名称不以下划线 `_` 开头，可以被任何对象访问，可以通过 import 语句导入其它脚本。
  - protected
    - ：受保护成员。名称以一个下划线 `_` 开头，只能在当前类或子类中访问，或通过实例访问。
  - private
    - ：私有成员。名称以两个下划线 `__` 开头，只能在当前类中访问。
  - 例：
    ```py
    >>> class Test:
    ...     a = 0
    ...     _b = 0
    ...     __c = 0
    ...
    >>> Test.a
    0
    >>> Test._b
    0
    >>> Test.__c
    AttributeError: 'Test' object has no attribute '__c'
    ```

## 变量

### 实例变量

- 用户根据 class 创建多个实例时，在 Python 底层，会自动为每个实例创建一个专用的命名空间，用于存储实例变量等标识符。
  - 每个名称的实例变量，会在每个实例的命名空间中，分别存储一份，互不影响。

- 如何访问？
  - 定义类时，只能在方法内访问。一般通过 `self.<variable>` 的形式访问。
  - 定义类之后，一般通过 `<instance>.<variable>` 的形式访问。
- 例：
  ```py
  >>> class Test:
  ...     def __init__(self, num=0):
  ...         self.num = num
  ...     def get_num(self):
  ...         return self.num
  ...
  >>> t1 = Test(1)
  >>> t1.num
  1
  >>> t1.get_num()
  1
  ```

### 类变量

- 用户定义一个 class 时，在 Python 底层，会自动为该 class 创建一个命名空间，用于存储类变量、方法等标识符。
  - 在该 class 的命名空间中，可以存储多个名称的类变量。
  - 每个名称的类变量，只存储一份值，被该 class 的所有实例共享。

- 如何访问？
  - 定义类时，
    - 在方法外创建的变量，都会被视作类变量。
    - 在方法内，可以通过以下几种形式访问。
      ```py
      cls.<variable>      # 推荐采用这种形式
      <class>.<variable>
      self.__class__.<variable>
      self.<variable>     # 此时，不能存在同名的实例变量。而且不能赋值，否则 Python 解释器会创建一个名为 self.<variable> 的实例变量
      ```
  - 定义类之后，
    - 可以通过 `<class>.<variable>` 的形式访问。
    - 也可以通过 `<instance>.<variable>` 访问，但不能与实例变量同名，否则优先访问实例变量。
- 例：
  ```py
  >>> class Test:
  ...     total = 0
  ...     def __init__(self, num=0):
  ...         self.num = num
  ...         Test.total += num
  ...     def get_total(cls):
  ...         return cls.total
  ...
  >>> t1 = Test(1)
  >>> t1.get_total()
  1
  >>> t1.total
  1
  >>> Test.total
  1
  >>> t2 = Test(2)
  >>> Test.total    # 不同实例，修改的是同一个类变量
  3
  ```

### 内置变量

#### 函数的内置变量

- `__name__`
  - ：取值为 str 类型，用于存储函数的名称。
  - 例：
    ```py
    >>> f = print   # 即使将函数名赋值给一个变量， __name__ 依然存储的是原来的函数名
    >>> f.__name__
    'print'
    ```
- `__doc__`
  - ：取值为 str 类型，用于存储函数的说明文档。
  - 例：
    ```py
    >>> print.__doc__   # 函数的说明文档，也就是执行 help(print) 看到的帮助文档
    "print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\nPrints the values ..."
    ```
- `__defaults__`
  - ：取值为 tuple 类型，用于存储函数各个形参的默认值。
  - 例：
    ```py
    >>> def fun1(x=[], y=[]):
    ...     print(fun1.__defaults__)
    ...     print(x, y)
    ...     y.append(0)   # 形参 y 的默认值为 list 类型，可以被修改，修改结果会持久保留在 __defaults__ 中
    ...
    >>> fun1()
    ([], [])
    [] []
    >>> fun1()
    ([], [0])
    [] [0]
    ```
- `__annotations__`
  - ：取值为 dict 类型，用于存储函数头中的注释。
  - 例：
    ```py
    >>> def fun1(a, b: 'str或None', c: int = 0) -> int:    # 定义函数时，可以用冒号 : 给形参添加注释
    ...     pass
    ...
    >>> fun1.__annotations__
    {'b': 'str或None', 'c': <class 'int'>, 'return': <class 'int'>}
    ```
- `__closure__`
  - ：对于非闭包函数，它取值为 None ，没有用处。对于闭包函数，它取值为 tuple 类型，用于存储函数引用的所有自由变量。
  - 例：
    ```py
    >>> def fun1():
    ...     x = 1
    ...     def fun2():
    ...         print(x)
    ...     return fun2
    ...
    >>> fun2 = fun1()
    >>> fun2.__closure__
    (<cell at 0x000001EF96373970: int object at 0x000001EF962E6930>,)
    >>> fun2.__closure__[0].cell_contents
    1
    ```

#### 类的内置变量

一个对象，具有以下内置变量：
- `__class__`
  - ：指向当前对象所属的类。
  - 例：
    ```py
    >>> a = 1
    >>> a.__class__
    <class 'int'>
    >>> type(a)           # 用内置函数 type() 也能查看一个对象所属的类
    <class 'int'>
    >>> int.__class__     # 一个类，也有 __class__ 变量。可见在 Python 底层，类是通过基类 type 定义的
    <class 'type'>
    >>> print.__class__   # 一个函数，也有 __class__ 变量。可见在 Python 底层，函数是通过 class 定义的
    <class 'builtin_function_or_method'>
    ```

类的一个方法，具有以下内置变量：
- `__self__`
  - ：它指向当前实例，相当于 self 指针。
  - 例：
    ```py
    >>> class Test:
    ...     def method1(self):
    ...         pass
    ...     @classmethod
    ...     def method2(cls):
    ...         pass
    ...     @staticmethod
    ...     def method3():
    ...         pass
    ...
    >>> t1 = Test()
    >>> t1.method1.__self__   # 实例方法的 __self__ 变量，指向当前实例
    <__main__.Test object at 0x000001EF96C73370>
    >>> t1 is _
    True
    >>> t1.method2.__self__   # 类方法的 __self__ 变量，指向当前类
    <class '__main__.Test'>
    >>> Test is _
    True
    >>> t1.method3.__self__   # 静态方法实际上就是一个函数，没有 __self__ 变量
    AttributeError: 'function' object has no attribute '__self__'
    ```
- `__func__`
  - ：它指向当前方法绑定的函数名。
  - 在 Python 底层，类的每个方法，是通过函数实现的。
    - 普通方法、类方法会绑定到一个函数，各个实例都是调用该函数。
    - 静态方法实际上就是一个函数，没有 `__func__` 变量。
  - 例：
    ```py
    >>> class Test:
    ...     def method1(self, a):
    ...         return a
    ...
    >>> t1 = Test()
    >>> t1.method1.__func__
    <function Test.method1 at 0x000001EF96C780D0>
    >>> t1.method1.__func__()       # __func__ 变量指向一个函数，可以调用它，但需要传入 self 参数
    TypeError: method1() missing 2 required positional arguments: 'self' and 'a'
    >>> t1.method1.__func__(t1, 'hello')
    'hello'
    ```

#### 添加属性

- Python 属于动态语言，允许给一个已经定义的类，添加属性。
  - 例：添加实例变量
    ```py
    >>> class Test:
    ...     pass
    ...
    >>> t1 = Test()
    >>> t1.name
    AttributeError: 'Test' object has no attribute 'name'
    >>> t1.name = 't1'
    >>> t1.name
    't1'
    ```
  - 例：添加类变量
    ```py
    >>> Test.name
    AttributeError: type object 'Test' has no attribute 'name'
    >>> Test.name = 'Test'
    >>> Test.__id = 1   # 私有属性不能在类外被访问，但这里还是赋值成功了
    ```
  - 例：添加方法
    ```py
    >>> def method1(self, x):
    ...     return x
    ...
    >>> Test.method1 = method1
    >>> t1.method1('hello')   # 该类的所有实例，都可以访问到新方法
    'hello'
    ```

- 因此，给一个类或实例，的某个属性进行赋值时，即使该属性不存在，也可以赋值成功。这可能引发 bug ，建议通过类的内置变量 `__slots__` ，声明只允许存在哪些名称的属性。
  ```py
  >>> class Test:
  ...     __slots__ = ('name', 'length')
  ...
  >>> t1 = Test()
  >>> t1.name = 't1'
  >>> t1.title = 't1'
  AttributeError: 'Test' object has no attribute 'title'
  ```
  - 定义一个类时，如果未声明 `__slots__` ，则不会继承父类的 `__slots__` ，因此允许添加任何属性。
  - 定义一个类时，如果声明了 `__slots__` ，则会与父类的 `__slots__` 合并。

## 方法

### 实例方法

- 假设一个名为 Test 的类中，定义了多个 method 。从该类创建了两个实例 t1、t2 。
  - t1、t2 都属于 Test 类，都可以调用 Test 类的所有 method 。
  - t1、t2 调用同一个 method 时，效果可能不同。因为有的 method ，会根据当前的实例的不同，执行不同的操作，这种 method 称为实例方法。

- 如何定义？
  - 在类中，像函数一样定义，但第一个形参是特殊的，通常命名为 `self` 。
    - `self` 指向当前实例，像 C++ 中使用的 `this` 指针。
    - `self` 有什么用处？通过它，可以找到当前实例绑定的命名空间，从而访问该命名空间中存储的各个标识符，比如各个实例变量、实例方法。
    - `self` 取值从何而来？调用实例方法时，Python 解释器会自动传入当前实例的引用，作为第一个实参，赋值给 `self` 形参。

- 如何调用？
  - 一般通过 `<instance>.<method>` 的形式调用。
  - 也可通过 `<class>.<method>` 的形式调用，此时需要手动传入第一个参数 self 。

- 例：
  ```py
  >>> class Test:
  ...     def __init__(self, num):
  ...         self.num = num
  ...     def get_num(self):
  ...         return self.num
  ...
  >>> t1 = Test(1)
  >>> t1.get_num()
  1
  >>> Test.get_num()
  TypeError: get_num() missing 1 required positional argument: 'self'
  >>> Test.get_num(t1)
  1
  ```

### 类方法

- 如何定义？
  - 要使用 Python 的一个内置装饰器 `@classmethod` ，将当前方法声明为类方法。
  - 第一个形参是特殊的，通常命名为 `cls` 。
    - `cls` 指向当前类，相当于 `self.__class__` 。
    - 调用类方法时，Python 解释器会自动传入当前类的引用，作为第一个实参，赋值给 `cls` 形参。

- 如何调用？
  - 一般通过 `<class>.<method>` 的形式调用。
  - 也可通过 `<instance>.<method>` 的形式调用。

- 例：
  ```py
  >>> class Test:
  ...     sum = 0
  ...     @classmethod
  ...     def get_sum(cls):
  ...         return cls.sum
  ...
  >>>
  >>> Test.get_sum()
  0
  >>> Test.sum = 1
  >>> Test.get_sum()
  1
  >>> Test().get_sum()
  1
  ```

### 静态方法

- 如何定义？
  - 要使用 Python 的一个内置装饰器 `@staticmethod` ，将当前方法声明为静态方法。
  - 没有特殊的形参，不必传入 self、cls 参数。像一个普通的函数。

- 如何调用？
  - 可以通过 `<class>.<method>` 或 `<instance>.<method>` 的形式调用。

- 例：
  ```py
  >>> class Test:
  ...     @staticmethod
  ...     def sum(a, b):
  ...         return a+b
  ...
  >>> Test.sum(1, 2)
  3
  >>> Test().sum(1, 2)
  3
  ```

### @property

- `@property` 是 Python 的一个内置装饰器，用于将类的某个方法，转换成只读变量。
  - 优点：当用户读取该变量时，会调用该方法，从而能执行一些业务代码，例如记录该变量被读取了多少次。
  - 例：
    ```py
    >>> class Test:
    ...     def __init__(self):
    ...         self._sum = 0     # 这里实例变量名为 _sum ，因为不能与实例方法 sum 同名
    ...     @property
    ...     def sum(self):
    ...         self._sum += 1
    ...         return self._sum
    ...
    >>>
    >>> t1 = Test()
    >>> t1.sum
    1
    >>> t1.sum
    2
    >>> t1.sum = 0    # 被 @property 装饰的方法，相当于一个只读变量，不允许赋值
    AttributeError: can't set attribute
    >>> t1.sum()      # 被 @property 装饰的方法，只能当作变量读取，不能当作方法调用
    TypeError: 'int' object is not callable
    ```

### 内置方法

- 用户定义一个 class 时，可以包含任意个 method ，每个 method 的名称由用户任意决定。但有些特殊的 method 名称，被 Python 解释器占用了，称为内置方法。
  - 内置方法的命名特点：以两个下划线 `__` 开头，以两个下划线 `__` 结尾。
  - 内置方法用于实现一些特殊的功能。
    - 例如定义了 `__add__()` 方法，就可以让当前类的实例，支持加法运算。
    - 由于内置方法的功能特殊，它们又被称为魔法方法（magic method）。
  - Python 总共设计了几十种内置方法。
    - 用户定义一个 class 时，不需要定义所有内置方法。
    - 用户定义一个 class 时，即使不主动定义内置方法，也会从元类、父类，继承一些基础的内置方法，例如 `__new__()`、`__init__()`、`__str__()`、`__repr__()`

- 一些内置方法：
  ```py
  __len__()       # 执行 len(object) 时，会自动调用该方法，计算对象的长度
  __sizeof__()    # 返回对象占用的内存大小，单位为 bytes 。例如 'hello'.__sizeof__()

  __getitem__()   # 执行 object[index] 时，会自动调用该方法，通过索引获取对象中某个元素，返回它的值
  __setitem__()   # 执行 object[index] = value 时，会自动调用该方法，通过索引获取对象中某个元素，给它赋值

  __iter__()      # 执行 iter(object) 时，会自动调用该方法
  __next__()      # 执行 next(object) 时，会自动调用该方法

  __enter__()     # 用于通过关键字 with 进行上下文管理
  __exit__()
  ```

#### 关于类

- 用户调用 `class_name()` ，即可创建某个类的一个实例。每个实例的创建过程如下：
  - 自动调用一次 `class_name.__new__()` 方法，创建实例。
  - 自动调用一次 `class_name.__init__()` 方法，初始化实例，比如创建一些实例变量。
  - 例：
    ```py
    >>> class Test:
    ...     def __new__(cls):
    ...         return super().__new__(cls) # 通常调用父类的 __new__() 方法来创建对象，这样用户不必亲自创建对象、分配内存
    ...     def __init__(self, a, b):
    ...         self.a = a
    ...         self.b = b
    ...         # super().__init__()        # 可选调用父类的 __init__() 方法
    ...
    >>> Test()      # 这里创建实例失败，报错说 __init__() 方法需要传入两个参数
    TypeError: __init__() missing 2 required positional arguments: 'a' and 'b'
    >>> Test(1, 2)  # 这里创建实例失败，报错说 __new__() 方法传入了多余的参数
    TypeError: __new__() takes 1 positional argument but 3 were given
    ```
    - 用户调用 `class_name(实参列表)` 创建一个实例时，实参列表会先传入 `__new__()` 方法，然后传入 `__init__()` 方法，因此这两个方法的形参列表需要一致，或者兼容。
    - 上例中，将 `def __new__(cls):` 改为 `def __new__(cls, *args, **kwargs):` ，即可接收实参列表，从而能创建一个对象。
- `__new__()`
  - ：用于创建一个实例，并返回该实例（的引用）。
  - 它要求输入当前 class 作为第一个实参。
    ```py
    >>> str.__new__()
    TypeError: str.__new__(): not enough arguments
    >>> str.__new__(str, 'hello')
    'hello'
    ```
  - 如果让 `__new__()` 总是返回同一个实例，则可以实现单例模式。
    ```py
    >>> class Test:
    ...     def __new__(cls):
    ...         if not hasattr(cls, 'instance'):
    ...             cls.instance = super().__new__(cls)
    ...         return cls.instance
    ...
    >>> Test()
    <__main__.Test object at 0x00000140699F54C0>
    >>> Test()
    <__main__.Test object at 0x00000140699F54C0>
    >>> Test() is Test()
    True
    ```
- `__init__()`
  - ：用于在新建实例之后，初始化该实例。类似于 C++ 中的构造函数。
  - 它要求输入当前实例，作为第一个实参。
- `__del__()`
  - ：用于销毁实例。类似于 C++ 中的析构函数。
  - 用关键字 del 删除一个对象，并不会调用该对象的 `__del__()` 方法，只是使得其被引用数减 1 。
  - 当一个对象的被引用数，减少到 0 时，Python 解释器会自动调用该对象的 `__del__()` 方法，释放其占用的内存空间。
  - 一般情况下，用户不必定义 `__del__()` 方法。但有时，用户希望在每个对象即将被销毁时，执行某些操作，例如记录日志，则可以定义 `__del__()` 方法。
- `__call__()`
  - Python 中，函数也是基于 class 定义的。当用户执行 `function_name()` 调用一个函数时，实际上是调用该函数的 `__call__()` 方法。
  - 因此，用户可以给任何 class 定义 `__call__()` 方法，使得该 class 的实例，可以当作函数被调用。
  - 例：
    ```py
    >>> class Test:
    ...     def __call__(self, *args, **kwargs):
    ...         print(*args, **kwargs)
    ...
    >>> t1 = Test()
    >>> t1('hello')
    hello
    ```
- `__getattr__()`
  - ：当用户访问对象的一个属性时，如果该属性未定义，则自动调用 `__getattr__()` 来查找。如果依然找不到，则抛出 AttributeError 异常。
  - 例：
    ```py
    >>> class Test:
    ...     def __getattr__(self, attr):
    ...         if attr == 'num':
    ...             return 0
    ...         else:
    ...             raise AttributeError("this object has no attribute '{}'".format(attr))
    ...
    >>> Test().num
    0
    >>> Test().name
    AttributeError: this object has no attribute 'name'
    ```

#### 关于字符串

```py
__repr__()    # 将一个对象打印到 Python 终端时，会自动调用该方法
__str__()     # 执行 str(object) 将一个对象转换成 str 类型时，会自动调用该方法，并期望该方法返回一个 str 对象
```
- 例：
  ```py
  >>> 'hello'.__repr__()
  "'hello'"
  >>> 'hello'.__str__()
  'hello'
  >>> 'hello'   # 这相当于执行 print('hello'.__repr__())
  'hello'
  ```
- 例：
  ```py
  >>> class Test:
  ...     def __repr__(self):
  ...         return 'TEST'
  ...     def __str__(self):
  ...         return 'test'
  ...
  >>> Test()
  TEST
  >>> str(Test())
  'test'
  >>> print(Test())   # print() 函数会先将对象转换成 str 类型，然后打印到终端
  test
  ```

#### 关于运算符

```py
__add__()       # 左加。当对象出现在加号 + 的左边时，会自动调用该方法
__radd__()      # 右加。当对象出现在加号 + 的右边时，会自动调用该方法

__sub__()       # 左减
__rsub__()      # 右减

__mul__()       # 左乘
__rmul__()      # 右乘

__truediv__()   # 左除
__rtruediv__()  # 右除
```
- 例：
  ```py
  >>> class Test:
  ...     def __init__(self, num):
  ...         self.num = num
  ...     def __sub__(self, other):
  ...         return self.num - other
  ...     def __rsub__(self, other):
  ...         return other - self.num
  ...
  >>> Test(1) - 2
  -1
  >>> 2 - Test(1)
  1
  ```

## 继承

### 单继承

- 定义一个 class 时，可以继承另一个 class 。前者称为子类，后者称为父类。
  - 例：
    ```py
    >>> class Person:
    ...     num = 0
    ...
    >>> class Man(Person):  # 创建一个 Man 类，继承 Person 类
    ...     pass
    ...
    ```

- 子类会继承父类的成员（主要是类变量、方法），但内置变量、内置方法不一定会继承。
  - 如下，子类的类变量，与父类的类变量，指向同一个对象。
    ```py
    >>> Person.num, Man.num
    (0, 0)
    >>> Person.num is Man.num
    True
    ```
  - 如果父类的类变量被赋值、改值，则子类的类变量也会变化，此时两个类变量依然指向同一个对象。
    ```py
    >>> Person.num = []
    >>> Person.num, Man.num
    ([], [])
    >>> Person.num is Man.num
    True
    ```
    ```py
    >>> Person.num.append(0)
    >>> Person.num, Man.num
    ([0], [0])
    >>> Person.num is Man.num
    True
    ```
  - 如果子类的类变量被改值，则父类的类变量也会变化，此时两个类变量依然指向同一个对象。
    ```py
    >>> Man.num.append(1)
    >>> Person.num, Man.num
    ([0, 1], [0, 1])
    >>> Person.num is Man.num
    True
    ```
  - 如果子类的类变量被赋值，则会指向另一个对象，从此与父类的类变量取消联系。
    ```py
    >>> Man.num = []
    >>> Person.num, Man.num
    ([0, 1], [])
    >>> Person.num is Man.num
    False
    ```

- 执行完 class 定义语句之后，如果重新定义父类，则子类不受影响，依然继承旧的父类。
  ```py
  >>> class Person:
  ...     name = ''
  ...
  >>> Man.name
  AttributeError: type object 'Man' has no attribute 'name'
  ```

- C++ 支持方法重载：在一个类及其子类中，可以定义名称相同、形参列表不同的多个方法。但 Python 不支持方法重载。
  - Python 中，如果在一个类中，定义了名称相同的多个方法，则只会保留最后一个定义的方法。
  - Python 中，如果子类定义了一个方法，与父类的某个方法同名，则会覆盖父类的这个方法，不再继承它。

### 多继承

- 定义一个 class 时，可以同时继承多个父类。
  - 例：
    ```py
    class User(Man, Woman):
        pass
    ```

- 多继承时，如果多个父类，存在同名的成员，则应该继承哪个父类的？Python 会根据 MRO 列表，按顺序查找。
  - 例：
    ```py
    >>> class Person:
    ...     name = 'Person'
    ...
    >>> class Man(Person):
    ...     name = 'Man'
    ...
    >>> class Woman(Person):
    ...     name = 'Woman'
    ...
    >>> class User(Man, Woman):
    ...     pass
    ...
    >>> User.name     # 这里继承的是 Man 类的成员，因为 Man 类在 MRO 列表中排序靠前
    'Man'
    >>> User.mro()    # 查看当前类的 MRO 列表
    [<class '__main__.User'>, <class '__main__.Man'>, <class '__main__.Woman'>, <class '__main__.Person'>, <class 'object'>]
    ```
  - 定义子类时，Python 会自动确定其 MRO（Method Resolution Order，方法继承顺序）：将子类及其所有父类，记录在一个列表中。子类排序在前，父类排序在后，每个类只出现一次。
  - 子类调用父类的一个成员时，会按 MRO 列表的顺序，从左往右，逐一检查各个父类（或祖先类）。
    - 如果当前 class 找到了指定名称的成员，则立即访问它。并停止查找，不再检查其它 class 。
    - 如果当前 class 没找到，则到下一个 class 中查找。

- 如何调用父类的一个方法？
  - 可以执行 `父类名.方法名(self)` 。
    - 缺点：
      - 需要手动输入父类的名称，比较麻烦。
      - 可能重复调用某个父类（或祖先类）的方法。
    - 例：
      ```py
      >>> class Person:
      ...     def __init__(self):
      ...         print('\t\t Person.__init__ start')
      ...         print('\t\t Person.__init__ end')
      ...
      >>> class Man(Person):
      ...     def __init__(self):
      ...         print('\t Man.__init__ start')
      ...         Person.__init__(self)
      ...         print('\t Man.__init__ end')
      ...
      >>> class Woman(Person):
      ...     def __init__(self):
      ...         print('\t Woman.__init__ start')
      ...         Person.__init__(self)
      ...         print('\t Woman.__init__ end')
      ...
      >>> class User(Man, Woman):
      ...     def __init__(self):
      ...         print('User.__init__ start')
      ...         Man.__init__(self)
      ...         Woman.__init__(self)
      ...         print('User.__init__ end')
      ...
      >>> user = User()
      User.__init__ start
              Man.__init__ start
                      Person.__init__ start
                      Person.__init__ end
              Man.__init__ end
              Woman.__init__ start
                      Person.__init__ start   # 这里重复调用了 Person.__init__
                      Person.__init__ end
              Woman.__init__ end
      User.__init__ end
      ```
  - 更推荐执行 `super().方法名()` 。
    - 优点：
      - 不必手动输入父类名称。例如在 User 类中执行 `super().__init__()` ，相当于执行 `super(User, self).__init__()` 。这会自动找到父类的方法，然后传入当前的 self 参数。
      - 不会重复调用某个父类（或祖先类）的方法。因为 `super()` 会根据 MRO 列表查找父类，每个父类最多被调用一次。
    - 例：
      ```py
      >>> class Person:
      ...     def __init__(self):
      ...         print('\t\t Person.__init__ start')
      ...         print('\t\t Person.__init__ end')
      ...
      >>> class Man(Person):
      ...     def __init__(self):
      ...         print('\t Man.__init__ start')
      ...         super().__init__()
      ...         print('\t Man.__init__ end')
      ...
      >>> class Woman(Person):
      ...     def __init__(self):
      ...         print('\t Woman.__init__ start')
      ...         super().__init__()
      ...         print('\t Woman.__init__ end')
      ...
      >>> class User(Man, Woman):
      ...     def __init__(self):
      ...         print('User.__init__ start')
      ...         super().__init__()    #
      ...         print('User.__init__ end')
      ...
      >>> user = User()
      User.__init__ start
              Man.__init__ start      # 在 User 类中执行 super() ，会发现 MRO 列表中最靠前的是 Man 类，于是调用 Man.__init__
              Woman.__init__ start    # 在 Man 类中执行 super() ，指向的是 Woman 类，而不是 Person 类。因为此时 self 参数来自 User 类，在其 MRO 列表中，位于 Man 类之后的是 Woman 类
                      Person.__init__ start
                      Person.__init__ end
              Woman.__init__ end
              Man.__init__ end
      User.__init__ end
      ```
