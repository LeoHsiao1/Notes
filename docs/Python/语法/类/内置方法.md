# 内置方法

- 用户定义一个 class 时，可以包含任意个 method ，每个 method 的名称由用户任意决定。但有些特殊的 method 名称，被 Python 解释器占用了，称为内置方法。
  - 内置方法的命名特点：以两个下划线 `__` 开头，以两个下划线 `__` 结尾。
  - 内置方法用于实现一些特殊的功能。
    - 例如定义了 `__add__()` 方法，就可以让当前类的实例，支持加法运算。
    - 由于内置方法的功能特殊，它们又被称为魔法方法（magic method）。
  - Python 总共设计了几十种内置方法。
    - 用户定义一个 class 时，不需要定义所有内置方法。
    - 用户定义一个 class 时，即使不主动定义内置方法，也会从元类、父类，继承一些基础的内置方法，例如 `__new__()`、`__init__()`、`__str__()`、`__repr__()`

- 一些内置方法：
  ```py
  __len__()       # 执行 len(object) 时，会自动调用该方法，计算对象的长度
  __sizeof__()    # 返回对象占用的内存大小，单位为 bytes 。例如 'hello'.__sizeof__()

  __getitem__()   # 执行 object[index] 时，会自动调用该方法，通过索引获取对象中某个元素，返回它的值
  __setitem__()   # 执行 object[index] = value 时，会自动调用该方法，通过索引获取对象中某个元素，给它赋值

  __enter__()     # 用于通过关键字 with 进行上下文管理
  __exit__()
  ```

## 关于类

- `__new__()`
  - ：用于创建一个实例，并返回该实例（的引用）。
  - 它要求输入当前 class 作为第一个实参。
    ```py
    >>> str.__new__()
    TypeError: str.__new__(): not enough arguments
    >>> str.__new__(str, 'hello')
    'hello'
    ```
  - 如果让 `__new__()` 总是返回同一个实例，则可以实现单例模式。
    ```py
    >>> class Test:
    ...     def __new__(cls):
    ...         if not hasattr(cls, 'instance'):
    ...             cls.instance = super().__new__(cls)
    ...         return cls.instance
    ...
    >>> Test()
    <__main__.Test object at 0x00000140699F54C0>
    >>> Test()
    <__main__.Test object at 0x00000140699F54C0>
    >>> Test() is Test()
    True
    ```

- `__init__()`
  - ：用于在新建实例之后，初始化该实例。类似于 C++ 中的构造函数。
  - 它要求输入当前实例，作为第一个实参。

- `__del__()`
  - ：用于销毁实例。类似于 C++ 中的析构函数。
  - 用关键字 del 删除一个对象，并不会调用该对象的 `__del__()` 方法，只是使得其被引用数减 1 。
  - 当一个对象的被引用数，减少到 0 时，Python 解释器会自动调用该对象的 `__del__()` 方法，释放其占用的内存空间。
  - 一般情况下，用户不必定义 `__del__()` 方法。但有时，用户希望在每个对象即将被销毁时，执行某些操作，例如记录日志，则可以定义 `__del__()` 方法。

- `__call__()`
  - Python 中，函数也是基于 class 定义的。当用户执行 `function_name()` 调用一个函数时，实际上是调用该函数的 `__call__()` 方法。
  - 因此，用户可以给任何 class 定义 `__call__()` 方法，使得该 class 的实例，可以当作函数被调用。
  - 例：
    ```py
    >>> class Test:
    ...     def __call__(self, *args, **kwargs):
    ...         print(*args, **kwargs)
    ...
    >>> t1 = Test()
    >>> t1('hello')
    hello
    ```

- `__getattr__()`
  - ：当用户访问对象的一个属性时，如果该属性未定义，则自动调用 `__getattr__()` 来查找。如果依然找不到，则抛出 AttributeError 异常。
  - 例：
    ```py
    >>> class Test:
    ...     def __getattr__(self, attr):
    ...         if attr == 'num':
    ...             return 0
    ...         else:
    ...             raise AttributeError("this object has no attribute '{}'".format(attr))
    ...
    >>> Test().num
    0
    >>> Test().name
    AttributeError: this object has no attribute 'name'
    ```

## 关于字符串

```py
__repr__()    # 将一个对象打印到 Python 终端时，会自动调用该方法
__str__()     # 执行 str(object) 将一个对象转换成 str 类型时，会自动调用该方法，并期望该方法返回一个 str 对象
```
- 例：
  ```py
  >>> 'hello'.__repr__()
  "'hello'"
  >>> 'hello'.__str__()
  'hello'
  >>> 'hello'   # 这相当于执行 print('hello'.__repr__())
  'hello'
  ```
- 例：
  ```py
  >>> class Test:
  ...     def __repr__(self):
  ...         return 'TEST'
  ...     def __str__(self):
  ...         return 'test'
  ...
  >>> Test()
  TEST
  >>> str(Test())
  'test'
  >>> print(Test())   # print() 函数会先将对象转换成 str 类型，然后打印到终端
  test
  ```

## 关于运算符

```py
__add__()       # 左加。当对象出现在加号 + 的左边时，会自动调用该方法
__radd__()      # 右加。当对象出现在加号 + 的右边时，会自动调用该方法

__sub__()       # 左减
__rsub__()      # 右减

__mul__()       # 左乘
__rmul__()      # 右乘

__truediv__()   # 左除
__rtruediv__()  # 右除
```
- 例：
  ```py
  >>> class Test:
  ...     def __init__(self, num):
  ...         self.num = num
  ...     def __sub__(self, other):
  ...         return self.num - other
  ...     def __rsub__(self, other):
  ...         return other - self.num
  ...
  >>> Test(1) - 2
  -1
  >>> 2 - Test(1)
  1
  ```

## 关于迭代

- 很多编程语言，都支持迭代这种操作：遍历一个对象中的所有元素，每次获取一个元素。

- Python 中，存在 list、str、set、dict 等多种数据类型的对象。
  - 这些对象，可以存放大量元素，因此称为容器。
  - 这些容器的数据类型不同，访问方法也不同。例如 list 可通过索引获取元素，而 set 不支持索引。
  - 但大部分类型的容器，都支持迭代，因此用户可通过迭代的方式，统一获取这些容器的元素。

### 可迭代对象

- 如果一个类，实现了 `__iter__()` 方法。则从该类创建的对象，称为可迭代对象（iterable）。
  - `__iter__()`
    - 功能：调用该方法，会返回一个迭代器。
    - 例如，执行 `iter(object)` 时，会自动调用该方法。
    - 例如，用 for 语句迭代一个对象时，会调用该对象的 `__iter__()` 方法，得到一个迭代器，然后开始迭代。
  - 例：
    ```py
    >>> class Number:
    ...     def __iter__(self):
    ...         return iter(range(5))
    ...
    >>> n = Number()
    >>> [i for i in n]
    [0, 1, 2, 3, 4]
    >>> next(n)
    TypeError: 'Number' object is not an iterator
    ```
  - 如果一个对象，只实现了 `__iter__()` 方法，未实现 `__next__()` 方法。则可以被 for 语句遍历，不能被 next() 遍历。
  - 可迭代对象，不一定支持索引，那需要实现 `__getitem__()` 和 `__setitem__()` 方法。

- 相关函数：
  ```py
  def iter(iterable) -> iterator
  ```
  - 功能：将一个可迭代对象，转换成迭代器。
  - 实际上该函数并不懂如何转换，只是调用对象的 `__iter__()` 方法，得到一个迭代器。
  - 例：
    ```py
    >>> iter('Hello')
    <iterator object at 0x7f19cd6e6810>
    >>> list(iter("Hello"))
    ['H', 'e', 'l', 'l', 'o']
    ```

### 迭代器

- 如果一个类，实现了 `__iter__()` 和 `__next__()` 方法。则从该类创建的对象，称为迭代器（iterator）。
  - `__next__()`
    - 功能：调用该方法，会返回迭代器中的下一个元素，如果没有下一个元素，则抛出异常 StopIteration 。
    - 例如，执行 `next(object)` 时，会自动调用该方法。
  - 例：
    ```py
    >>> class Number:
    ...     def __init__(self):
    ...         self.a = 0
    ...     def __iter__(self):
    ...         return self
    ...     def __next__(self):
    ...         if self.a < 5:
    ...             self.a += 1
    ...             return self.a
    ...         else:
    ...             raise StopIteration
    ...
    >>> n = Number()
    >>> n
    <__main__.Number object at 0x00000203210B9460>
    >>> next(n)
    1
    >>> next(n)
    2
    >>> list(n)
    [3, 4, 5]
    >>> list(n)   # 此时 n 已经迭代结束，list() 不能获取元素，因此返回一个空列表
    []
    >>> next(n)   # 此时 n 已经迭代结束，不能获取下一个元素，因此抛出异常
    StopIteration
    ```

- 相关函数：
  ```py
  def next(iterator, default=...) -> object
  ```
  - 功能：获取迭代器中的下一个元素。实际上是调用对象的 `__next__()` 方法。
    - 如果不存在下一个元素，且未输入 default 参数，则抛出异常 StopIteration 。
    - 如果不存在下一个元素，但输入了 default 参数，则返回 default 参数的值。
  - 例：
    ```
    >>> a = iter('Hello')
    >>> next(a)
    'H'
    >>> next(a)
    'e'
    ```

- Python 中的迭代器，属于单向只读迭代器：只能向前遍历，不能后退。
  - 由于是单向遍历，迭代器遍历完所有元素之后，就会停止迭代。不过，也可以创建无限循环的迭代器。

### 生成器

- 生成器（generator）是一种特殊的迭代器，它会控制函数的执行进度。
  - 如何创建？
    - 在函数（或方法）中，使用关键字 `yield` 指定返回值，取代关键字 `return` 。
  - 如何使用？
    - 函数执行到 `yield` 语句时，函数会暂停执行，并返回一个生成器。
    - 当用户获取生成器的下一个元素时，会得到 `yield` 语句的返回值，然后使得函数继续执行。
  - 例：
    ```py
    >>> def fun1():
    ...     print('A')
    ...     yield 1
    ...     print('B')
    ...     yield 2
    ...     print('C')
    ...     yield 3
    ...
    >>> g = fun1()
    >>> g
    <generator object fun1 at 0x0000015736089D60>
    >>> next(g)
    A
    1
    >>> next(g)
    B
    2
    >>> next(g)
    C
    3
    >>> next(g)
    StopIteration
    ```
  - 也可使用推导式的语法，创建生成器：
    ```py
    >>> g = (i for i in range(10))
    >>> g
    <generator object <genexpr> at 0x0000015736089890>
    >>> next(g)
    0
    >>> next(g)
    1
    ```

- 为什么使用生成器？通常是为了提高 Python 程序的性能。
  - 假设存在一个 iterable 对象，占用 100MB 内存空间。现在想将 iterable 中每个元素转换成 str 类型。
    - 如果使用列表推导式 `result = [str(i) for i in iterable]` ，此时 result 也会占用 100MB 内存，加上 iterable 就占用 200MB 内存。
    - 如果使用生成器推导式 `result = (str(i) for i in iterable)` ，此时 result 同时只获取一个元素，几乎不占用内存。

  - 除了内存开销，还需要考虑时间开销。
    - 假设遍历 iterable 对象的全部元素，耗时较久（比如几分钟）。等遍历完成之后，才开始处理这些元素，导致用户需要等一段时间才能看到处理结果。
      ```py
      result = [str(i) for i in iterable] # 这一步可能耗时较久
      for i in result:
          print(i)
      ```
    - 而使用生成器，可以每获取一个元素，就立即处理。从而更早地让用户看到处理结果，虽然并不能减少整体耗时。
      ```py
      result = (str(i) for i in iterable) # 这一步几乎没有耗时
      for i in result:
          print(i)
      ```
