# 内置方法

- 用户定义一个 class 时，可以包含任意个 method ，每个 method 的名称由用户任意决定。但有些特殊的 method 名称，被 Python 解释器占用了，称为内置方法。
  - 内置方法的命名特点：以两个下划线 `__` 开头，以两个下划线 `__` 结尾。
  - 内置方法用于实现一些特殊的功能。
    - 例如定义了 `__add__()` 方法，就可以让当前类的实例，支持加法运算。
    - 由于内置方法的功能特殊，它们又被称为魔法方法（magic method）。
  - Python 总共设计了几十种内置方法。
    - 用户定义一个 class 时，不需要定义所有内置方法。
    - 用户定义一个 class 时，即使不主动定义内置方法，也会从元类、父类，继承一些基础的内置方法，例如 `__new__()`、`__init__()`、`__str__()`、`__repr__()`

- 一些内置方法：
  ```py
  __len__()       # 执行 len(object) 时，会自动调用该方法，计算对象的长度
  __sizeof__()    # 返回对象占用的内存大小，单位为 bytes 。例如 'hello'.__sizeof__()

  __getitem__()   # 执行 object[index] 时，会自动调用该方法，通过索引获取对象中某个元素，返回它的值
  __setitem__()   # 执行 object[index] = value 时，会自动调用该方法，通过索引获取对象中某个元素，给它赋值

  __enter__()     # 用于通过关键字 with 进行上下文管理
  __exit__()
  ```

## 关于类

- `__new__()`
  - ：用于创建一个实例，并返回该实例（的引用）。
  - 它要求输入当前 class 作为第一个实参。
    ```py
    >>> str.__new__()
    TypeError: str.__new__(): not enough arguments
    >>> str.__new__(str, 'hello')
    'hello'
    ```
  - 如果让 `__new__()` 总是返回同一个实例，则可以实现单例模式。
    ```py
    >>> class Test:
    ...     def __new__(cls):
    ...         if not hasattr(cls, 'instance'):
    ...             cls.instance = super().__new__(cls)
    ...         return cls.instance
    ...
    >>> Test()
    <__main__.Test object at 0x00000140699F54C0>
    >>> Test()
    <__main__.Test object at 0x00000140699F54C0>
    >>> Test() is Test()
    True
    ```

- `__init__()`
  - ：用于在新建实例之后，初始化该实例。类似于 C++ 中的构造函数。
  - 它要求输入当前实例，作为第一个实参。

- `__del__()`
  - ：用于销毁实例。类似于 C++ 中的析构函数。
  - 用关键字 del 删除一个对象，并不会调用该对象的 `__del__()` 方法，只是使得其被引用数减 1 。
  - 当一个对象的被引用数，减少到 0 时，Python 解释器会自动调用该对象的 `__del__()` 方法，释放其占用的内存空间。
  - 一般情况下，用户不必定义 `__del__()` 方法。但有时，用户希望在每个对象即将被销毁时，执行某些操作，例如记录日志，则可以定义 `__del__()` 方法。

- `__call__()`
  - Python 中，函数也是基于 class 定义的。当用户执行 `function_name()` 调用一个函数时，实际上是调用该函数的 `__call__()` 方法。
  - 因此，用户可以给任何 class 定义 `__call__()` 方法，使得该 class 的实例，可以当作函数被调用。
  - 例：
    ```py
    >>> class Test:
    ...     def __call__(self, *args, **kwargs):
    ...         print(*args, **kwargs)
    ...
    >>> t1 = Test()
    >>> t1('hello')
    hello
    ```

- `__getattr__()`
  - ：当用户访问对象的一个属性时，如果该属性未定义，则自动调用 `__getattr__()` 来查找。如果依然找不到，则抛出 AttributeError 异常。
  - 例：
    ```py
    >>> class Test:
    ...     def __getattr__(self, attr):
    ...         if attr == 'num':
    ...             return 0
    ...         else:
    ...             raise AttributeError("this object has no attribute '{}'".format(attr))
    ...
    >>> Test().num
    0
    >>> Test().name
    AttributeError: this object has no attribute 'name'
    ```

## 关于字符串

```py
__repr__()    # 将一个对象打印到 Python 终端时，会自动调用该方法
__str__()     # 执行 str(object) 将一个对象转换成 str 类型时，会自动调用该方法，并期望该方法返回一个 str 对象
```
- 例：
  ```py
  >>> 'hello'.__repr__()
  "'hello'"
  >>> 'hello'.__str__()
  'hello'
  >>> 'hello'   # 这相当于执行 print('hello'.__repr__())
  'hello'
  ```
- 例：
  ```py
  >>> class Test:
  ...     def __repr__(self):
  ...         return 'TEST'
  ...     def __str__(self):
  ...         return 'test'
  ...
  >>> Test()
  TEST
  >>> str(Test())
  'test'
  >>> print(Test())   # print() 函数会先将对象转换成 str 类型，然后打印到终端
  test
  ```

## 关于运算符

```py
__add__()       # 左加。当对象出现在加号 + 的左边时，会自动调用该方法
__radd__()      # 右加。当对象出现在加号 + 的右边时，会自动调用该方法

__sub__()       # 左减
__rsub__()      # 右减

__mul__()       # 左乘
__rmul__()      # 右乘

__truediv__()   # 左除
__rtruediv__()  # 右除
```
- 例：
  ```py
  >>> class Test:
  ...     def __init__(self, num):
  ...         self.num = num
  ...     def __sub__(self, other):
  ...         return self.num - other
  ...     def __rsub__(self, other):
  ...         return other - self.num
  ...
  >>> Test(1) - 2
  -1
  >>> 2 - Test(1)
  1
  ```
