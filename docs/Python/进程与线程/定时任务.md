# 定时任务

## import apscheduler

- ：Python 的第三方库，用于执行定时任务。
- [官方文档](https://apscheduler.readthedocs.io/en/3.x/userguide.html)
- 安装：`pip install apscheduler`
- 原理：当一个任务达到触发时刻时，就创建一个子线程，来执行该任务。

- 例：
  ```py
  from apscheduler.schedulers.blocking import BlockingScheduler
  from datetime import datetime

  scheduler = BlockingScheduler()  # 创建一个调度器，可以往其中添加多个任务

  # 添加一个任务，只会在指定时刻，执行一次
  scheduler.add_job(func=print, args=('hello',), kwargs=None, trigger='date', next_run_time=datetime(2020, 10, 1, 0, 0, 0))

  # 添加一个任务，每隔一段时间就执行一次。间隔时间可以是 seconds、minutes、hours 等单位
  scheduler.add_job(func=print, args=('hello',), trigger='interval', seconds=3)

  # 添加一个任务，在每天的 12:30 执行一次
  scheduler.add_job(func=print, args=('hello',), trigger='cron', hour=12, minute=30)

  scheduler.start()      # 启动调度器
  scheduler.get_jobs()   # 返回一个列表，包含所有待执行的任务，不包含已经失效的任务
  scheduler.shutdown()   # 终止调度器
  ```
  - trigger 参数，表示任务的触发方式。
  - `trigger='interval'` 类型的任务，可输入以下几种参数，控制触发时间：
    ```py
    weeks       # 每隔几周。取值为 int 类型
    days
    hours
    minutes
    seconds

    start_date  # 开始日期。取值为 datetime 或 str
    end_date    # 结束日志。取值为 datetime 或 str
    ```
  - `trigger='cron'` 类型的任务，可输入以下几种参数，控制触发时间：
    ```py
    year
    month
    week
    day_of_week # 每周的第几天，取值为 0~6
    hour
    minute
    second

    start_date
    end_date
    ```

- 上例创建的 scheduler ，属于 `BlockingScheduler` 。执行 `scheduler.start()` 时，会阻塞当前线程。如果不想阻塞当前线程，可以使用 `BackgroundScheduler` ：
  ```py
  from apscheduler.schedulers.background import BackgroundScheduler
  scheduler = BackgroundScheduler()
  ```
  这样，所有任务会在后台运行，不会阻塞当前线程，但依然会将 stdout、stderr 输出到当前终端。

- 添加到 scheduler 的任务，可以被删除：
  ```py
  job = scheduler.add_job(func=print, args=('hello',), trigger='interval', seconds=3)
  job.remove()
  ```
