# 线程

## 原理

- 进程、线程的原理，参考以下笔记：
  - [进程](https://leohsiao.com/Linux/%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B)
  - [线程](https://leohsiao.com/Linux/%E8%BF%9B%E7%A8%8B/%E7%BA%BF%E7%A8%8B)

- 当一个进程中所有线程都终止时，操作系统才认为该进程已终止，释放该进程占用的系统资源，比如 PID、内存。

- 创建的子线程、子进程，默认会在前台运行，将 stdout、stderr 输出到当前终端。
  - 如果将子线程、子进程设置为 daemon 类型，则它们会在后台运行，不影响当前终端。
  - 如果一个进程中，所有非 daemon 线程都终止了，则操作系统会自动终止所有 daemon 线程，然后终止该进程。
  - 如果一个进程组中，所有非 daemon 进程都终止了，则操作系统会自动终止所有 daemon 线程，然后终止该进程组。

- 如何终止线程？
  - 建议不要从外部杀死线程，否则线程可能来不及做完某些任务。比如尚未将内存中的数据持久化到磁盘。
    - 因此，threading 库没有提供杀死线程的方法。
    - 如果线程为 daemon 类型，则可能被操作系统终止。
  - 建议编写线程的源代码，让它自己决定何时终止。
    - 比如一个线程只会执行少量任务，运行一段时间就会自行终止。
    - 比如一个线程会无限循环，但每隔 1 分钟，就检查一次是否应该终止。

- CPython 解释器采用 GIL（Global Interpreter Lock，全局解释锁）。
  - 原理：
    - 同一进程中，同时只能有一个线程拿到 GIL 锁。
    - 只有拿到 GIL 锁的那个线程，会被 CPU 执行。而其它线程，不会被 CPU 执行。
  - 优点：
    - 同一个进程中的多个线程，可能同时访问一个资源，发生冲突。而 GIL 能避免这种情况。
  - 缺点：
    - 由于 GIL 机制，同一进程中的多个线程，不能同时执行、并发工作。
  - CPython 的多线程，
    - 适合处理 IO 密集型任务。因为这些线程经常处于 iowait 状态，大部分时间不占用 CPU 。
    - 不适合处理 CPU 密集型任务。因为这些线程都需要占用 CPU ，但同时只会执行拿到 GIL 锁的那个线程。导致多个线程的任务处理速度，与单个线程差不多，甚至可能更慢（因为上下文切换的耗时）。
  - CPython 的多进程，
    - 不适合处理 IO 密集型任务。因为这种任务，用多线程就可以处理。创建进程，比起创建线程，需要消耗更多 CPU、内存。
    - 适合处理 CPU 密集型任务。因为 N 个进程，可以同时被 CPU 执行，任务处理速度是单个进程的 N 倍，除非主机的 CPU 核数少于 N 。

## import threading

：Python 的标准库，用于创建多线程。
- [官方文档](https://docs.python.org/3/library/threading.html)

### Thread()

- 定义：
  ```py
  class Thread(group=None, target=None, name=None, args=(), kwargs=None, daemon:bool)
  ```
  - 功能：
    - 输入一些参数，定义一个线程，返回一个 Thread 对象。
  - 参数：
    - group 表示线程组。
    - target 表示在线程中运行的入口函数。
    - name 表示线程的名称。默认按 `Thread-<int>` 的格式命名。
    - args 表示传递元组参数给 target 函数。
    - kwargs 表示传递字典参数给 target 函数。
    - daemon 参数如果未指定，则默认继承当前线程的 daemon 参数。

- 例：
  ```py
  >>> import threading
  >>> t1 = threading.Thread(target=print, args=('hello',))
  >>> t1
  <Thread(Thread-1, initial)>   # 此时线程处于 initial 状态，也就是已经初始化，尚未启动
  >>> t1.start()    # 启动线程
  hello             # 子线程默认在前台运行，将 stdout、stderr 输出到当前终端
  >>> t1.start()    # 每个线程只允许调用一次 start() 方法
  RuntimeError: threads can only be started once
  ```

- 查看线程的信息：
  ```py
  >>> t1
  <Thread(t1, stopped 7712)>
  >>> t1.name             # 返回线程的名称
  'Thread-1'
  >>> t1.native_id        # 返回线程的 TID 。调用 start() 之后，操作系统才会创建线程，分配 TID
  7712
  >>> t1.daemon           # 判断线程是否为 daemon 类型
  False
  >>> t1.is_alive()       # 判断线程是否正在运行
  False
  ```

- 查看所有线程：
  ```py
  >>> threading.active_count()    # 返回当前进程中，正在运行的线程总数
  1
  >>> threading.enumerate()       # 返回当前进程中，正在运行的所有 Thread 对象
  [<_MainThread(MainThread, started 6764)>]
  >>> threading.current_thread()  # 返回当前线程，用 Thread 对象表示
  <_MainThread(MainThread, started 6764)>
  >>> threading.main_thread()     # 返回当前进程中的主线程
  <_MainThread(MainThread, started 6764)>
  ```

### Thread.run()

- 另一种创建线程的方法：定义一个线程类，继承 `threading.Thread` 类，至少重载其 `run()` 方法。

- 例：
  ```py
  >>> class myThread(threading.Thread):
  ...     def __init__(self, a):
  ...         super().__init__()  # 重载 __init__() 方法时，需要调用 Thread.__init__() 方法，才能初始化线程
  ...         self.a = a
  ...     def run(self):
  ...         print(self.a)
  ...
  >>>
  >>> t1 = myThread(a=1)
  >>> t1.start()
  1
  ```
  - `Thread.start()` 方法，会调用 `Thread.run()` 方法，来启动线程。
  - `Thread.run()` 方法，会调用线程的 target 函数，来启动线程。

### 阻塞

- 阻塞当前线程：
  ```py
  >>> t1.join()   # 阻塞当前线程，等到 t1 线程运行终止，才继续运行当前线程
  >>> t1.join(3)  # 最多阻塞当前线程 3 秒。等到 t1 终止，或者 3 秒之后，就恢复运行当前线程
  ```

- `threading.Lock()` 是互斥锁。
  - 如果一个线程获得了互斥锁，则会阻塞同一进程的其它所有线程。
  - 例：
    ```py
    >>> lock = threading.Lock()  # 创建一个互斥锁
    >>> lock.acquire()  # 请求获得锁，这会阻塞当前线程，直到成功获得锁
    True
    >>> do_something()  # 此时只有当前线程在运行，其它线程暂停运行
    >>> lock.release()  # 释放锁
    ```
    ```py
    >>> lock.acquire(blocking=False)  # acquire 时不阻塞当前线程。需要根据返回值 True/False ，判断是否成功获得锁
    True
    >>> lock.acquire(timeout=3)       # 设置超时时间，最多阻塞当前线程多久
    False
    ```
  - 如果一个线程获得互斥锁之后，没有释放，就再次调用 `acquire()` 方法，则会一直等待获得锁，陷入死锁。

- `threading.RLock()` 是可重入的互斥锁。
  - 同一个线程，可以重复获得同一个 `RLock()` ，不会死锁。但是调用了多少次 `acquire()` ，就需要调用多少次 `release()` ，才能完全释放该锁，供其它线程获取。
  - 例：
    ```py
    >>> rlock = threading.RLock()
    >>> rlock.acquire()
    True
    >>> rlock.acquire()
    True
    >>> rlock.release()
    >>> rlock.release()
    >>> rlock.release() # 如果对一个已释放的锁，调用 release() ，则会抛出异常
    RuntimeError: cannot release un-acquired lock
    ```
  - 手动控制 `release()` 的次数挺麻烦，建议通过 with 关键字访问 rlock ，这会自动释放锁：
    ```py
    with rlock:
        rlock.acquire()
        rlock.acquire()
    ```

### Timer()

- 定义：
  ```py
  class Timer(interval, function, args=None, kwargs=None)
  ```
  - 功能：定义一个延迟启动的线程。
  - 不适合处理大量定时任务。

- 例：
  ```py
  >>> t1 = threading.Timer(3.0, print, ('hello',))
  >>> t1.start()   # 启动线程。但线程会等 interval 秒才启动，执行 function 函数
  >>> hello
  >>> t1.cancel()  # 可以提前终止线程
  ```
